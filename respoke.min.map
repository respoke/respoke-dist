{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///build/respoke.min.js","webpack:///webpack/bootstrap 17546c194ed1f389a3e4","webpack:///./index.js","webpack:///./respoke/respoke.js","webpack:///./~/loglevel/lib/loglevel.js","webpack:///./respoke/deps/adapter.js","webpack:///./respoke/event.js","webpack:///./respoke/class.js","webpack:///./~/socket.io-client/dist/socket.io.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/q/q.js","webpack:///./respoke/client.js","webpack:///./respoke/connection.js","webpack:///./respoke/endpoint.js","webpack:///./respoke/textMessage.js","webpack:///./respoke/signalingMessage.js","webpack:///./respoke/group.js","webpack:///./respoke/signalingChannel.js","webpack:///./~/url-template/lib/url-template.js","webpack:///./respoke/directConnection.js","webpack:///./respoke/peerConnection.js","webpack:///./~/statechart/lib/statechart.js","webpack:///./respoke/callState.js","webpack:///./respoke/call.js","webpack:///./respoke/localMedia.js","webpack:///./respoke/remoteMedia.js","webpack:///./respoke/conference.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","global","log","setLevel","levels","WARN","originalFactory","methodFactory","logMethodFactory","methodName","logLevel","logMethod","errorReporter","message","args","Array","prototype","slice","arguments","reporterMessage","join","unshift","apply","EventEmitter","respoke","ridiculous","buildNumber","io","Q","longStackSupport","stackJumpLimit","longStackJumpLimit","stopUnhandledRejectionTracking","instances","needsChromeExtension","window","chrome","opera","navigator","webkitGetUserMedia","needsFirefoxExtension","webrtcDetectedBrowser","hasChromeExtension","hasFirefoxExtension","chooseDesktopMedia","warn","isNwjs","gui","process","nwDispatcher","requireNwGui","Screen","Init","data","callback","mediaSources","source","sourceId","type","extEvent","evt","document","createEvent","initCustomEvent","version","Class","Client","Connection","Endpoint","TextMessage","SignalingMessage","Group","SignalingChannel","DirectConnection","PeerConnection","CallState","Call","LocalMedia","RemoteMedia","Conference","chromeScreenSharingExtensionReady","detail","available","params","Error","sourceIdListener","screenSourceId","removeEventListener","dispatchEvent","addEventListener","fire","info","connect","client","getClient","undefined","debug","stack","createClient","instanceId","callOnce","func","called","makeGUID","chars","split","uuid","rnd","r","i","Math","random","handlePromise","promise","onSuccess","onError","returnUndef","done","hasUserMedia","getUserMedia","mozGetUserMedia","Function","hasRTCPeerConnection","RTCPeerConnection","webkitRTCPeerConnection","mozRTCPeerConnection","hasWebsocket","WebSocket","webkitWebSocket","MozWebSocket","hasScreenShare","clone","JSON","parse","stringify","isEqual","a","b","aKeys","hasOwnProperty","splice","length","Object","keys","sdpHasAudio","sdp","indexOf","sdpHasVideo","sdpHasDataChannel","sdpHasSendOnly","sdpHasReceiveOnly","constraintsHasAudio","constraints","audio","constraintsHasVideo","video","constraintsHasScreenShare","mandatory","chromeMediaSource","mediaSource","convertConstraints","defaults","queueFactory","queue","trigger","action","safeAction","item","err","error","forEach","push","getScreenShareConstraints","screenConstraint","optional","isArray","maxWidth","maxHeight","thing","googTemporalLayeredScreencast","getScreenShareMedia","deferred","defer","criteria","localMedia","element","start","resolve","reject","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","noop","undefinedType","realMethod","console","bindMethod","obj","method","bind","e","enableLoggingWhenConsoleArrives","level","loggerName","replaceLoggingMethods","logMethods","defaultMethodFactory","Logger","name","defaultLevel","self","currentLevel","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","cookie","encodeURIComponent","getPersistedLevel","storedLevel","location","exec","TRACE","DEBUG","INFO","ERROR","SILENT","getLevel","persist","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","attachMediaStream","reattachMediaStream","webrtcDetectedVersion","trace","text","substring","performance","now","toFixed","maybeFixConfiguration","pcConfig","iceServers","url","urls","parseInt","userAgent","match","pcConstraints","RTCSessionDescription","mozRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","createIceServer","username","password","iceServer","urlParts","turnUrlParts","credential","createIceServers","stream","mozSrcObject","setTimeout","play","to","from","result","srcObject","src","URL","createObjectURL","respokeClass","that","className","eventList","once","eventType","listener","isInternal","string","toString","listen","invalidEventType","invalidListener","fn","isNotAlreadyAdded","map","count","toRemove","target","listenerBuilder","hasListeners","every","eachListener","copyParam","__WEBPACK_AMD_DEFINE_ARRAY__","protocol","transports","j","sockets","host","details","uri","util","parseUri","uuri","socket","domain","hostname","port","uniqueUri","options","secure","query","merge","Socket","of","path","re","parts","str","base","addition","chunkQuery","components","part","qs","l","kv","pageLoaded","load","readyState","on","event","capture","attachEvent","request","xdomain","XDomainRequest","ua","hasCORS","XMLHttpRequest","concat","webkit","importScripts","additional","deep","lastseen","seen","depth","prop","mixin","ctor","ctor2","inherit","f","intersect","arr","arr2","ret","longest","shortest","o","toArray","enu","withCredentials","test","iDevice","$events","addListener","removeListener","list","pos","removeAllListeners","listeners","emit","handler","parent","nativeJSON","n","date","d","key","isFinite","valueOf","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","cx","escapable","gap","indent","meta","\b","\t","\n","\f","\r","\"","\\","rep","quote","lastIndex","replace","charCodeAt","holder","k","v","mind","partial","value","Date","String","replacer","space","","reviver","walk","eval","SyntaxError","parser","packets","reasons","advice","encodePacket","packet","endpoint","ack","reason","adv","ev","ackId","encoded","encodePayload","decoded","regexp","decodePacket","pieces","opts","decodePayload","charAt","substr","Number","Transport","sessid","heartbeats","onData","clearCloseTimeout","connected","connecting","reconnecting","setCloseTimeout","msgs","onPacket","setHeartbeatTimeout","onHeartbeat","onConnect","isOpen","closeTimeout","onDisconnect","close","clearTimeouts","clearTimeout","reopenTimeout","send","heartbeat","onOpen","onClose","prepareUrl","scheme","resource","ready","connect timeout","try multiple transports","reconnect","reconnection delay","reconnection limit","Infinity","reopen delay","max reconnection attempts","sync disconnect on unload","auto connect","flash policy port","manualFlush","open","namespaces","buffer","doBuffer","isXDomain","disconnectSync","SocketNamespace","publish","nsp","$emit","empty","handshake","complete","insertAt","getElementsByTagName","script","createElement","parentNode","insertBefore","removeChild","xhr","onreadystatechange","status","responseText","getTransport","override","transport","check","xdomainCheck","sessionid","sid","heartbeatTimeout","origTransports","connectTimeoutTimer","remaining","heartbeatTimeoutTimer","setBuffer","flushBuffer","payload","disconnect","wasConnected","wasConnecting","reconnectionAttempts","reconnectionDelay","maxAttempts","tryMultiple","limit","reset","reconnectionTimer","maybeReconnect","redoTransports","flags","json","Flag","ackPackets","acks","lastArg","namespace","websocket","WS","onopen","onmessage","onclose","onerror","flashsocket","Flashsocket","__addTask","__tasks","init","WEB_SOCKET_SWF_LOCATION","loadFlashPolicyFile","__initialize","body","swfobject","getFlashPlayerVersion","major","WEB_SOCKET_DISABLE_AUTO_INITIALIZATION","D","S","W","q","R","x","O","t","T","U","h","N","I","E","B","J","G","M","aa","getElementById","ah","toLowerCase","Y","platform","ae","ac","af","parseFloat","X","ag","ab","plugins","description","mimeTypes","enabledPlugin","ad","GetVariable","Z","w3","pv","wk","ie","win","mac","detachEvent","callee","top","documentElement","doScroll","s","appendChild","C","K","onload","V","H","setAttribute","callbackFn","success","F","swfVersion","w","ref","z","expressInstall","A","ai","width","getAttribute","height","styleclass","align","P","SetVariable","nodeName","g","title","flashvars","style","display","u","replaceChild","innerHTML","childNodes","nodeType","cloneNode","movie","outerHTML","y","styleSheets","addRule","createTextNode","visibility","L","registerObject","getObjectById","embedSWF","aj","al","am","ak","an","switchOffAutoHideShow","minor","release","hasFlashPlayerVersion","createSWF","showExpressInstall","removeSWF","createCSS","addDomLoadEvent","addLoadEvent","getQueryParamValue","search","hash","expressInstallCallback","protocols","proxyHost","proxyPort","headers","__id","__nextId","__instances","CONNECTING","bufferedAmount","__events","__flash","create","CLOSED","CLOSING","useCapture","events","__handleEvent","flashEvent","jsEvent","__createSimpleEvent","decodeURIComponent","__createMessageEvent","Event","initEvent","bubbles","cancelable","MessageEvent","initMessageEvent","OPEN","loadManualPolicyFile","__swfLocation","container","position","__isFlashLite","left","hasPriority","swliveconnect","allowScriptAccess","__onFlashInitialized","setCallerUrl","href","setDebug","WEB_SOCKET_DEBUG","__onFlashEvent","receiveEvents","webSocketId","__log","__error","task","mimeType","filename","XHR","sendBuffer","get","post","stateChange","posting","sendXHR","req","setRequestHeader","contentType","usesXDomReq","socketProtocol","isXProtocol","htmlfile","HTMLFile","doc","write","parentWindow","iframeC","iframe","destroy","_","CollectGarbage","XHRPolling","retryCounter","abort","indicator","JSONPPolling","index","msg","form","area","iframeId","initIframe","submit","async","webpackPolyfill","deprecate","paths","children","bootstrap","ses","ok","makeQ","previousQ","hasStacks","qStartingLine","captureLine","qFileName","nextTick","head","next","tail","flushing","requestTick","isNodeJS","laterQueue","flush","enter","runSingle","pop","exit","setImmediate","MessageChannel","channel","port1","requestPortTick","port2","postMessage","runAfter","uncurryThis","array_slice","array_reduce","reduce","basis","array_indexOf","array_map","thisp","collect","object_create","Type","object_hasOwnProperty","object_keys","object","object_toString","isObject","isStopIteration","exception","QReturnValue","ReturnValue","STACK_JUMP_SEPARATOR","makeStackTraceLong","stacks","concatedStacks","filterStackString","stackString","lines","desiredLines","line","isInternalFrame","isNodeFrame","stackLine","getFileNameAndLineNumber","attempt1","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qEndingLine","firstLine","alternative","Promise","isPromiseAlike","coerce","fulfill","env","Q_DEBUG","messages","progressListeners","resolvedPromise","promiseDispatch","op","operands","nearerValue","nearer","isPromise","inspect","state","become","newPromise","notify","progress","progressListener","makeNodeResolver","resolver","race","all","passByCopy","spread","answerPs","len","then","makePromise","descriptor","fallback","inspected","fulfilled","rejected","progressed","_fulfilled","_rejected","newException","_progressed","newValue","threw","tap","fcall","thenResolve","when","thenReject","isPending","isFulfilled","isRejected","unhandledReasons","unhandledRejections","reportedUnhandledRejections","trackUnhandledRejections","resetUnhandledRejections","trackRejection","untrackRejection","at","atReport","getUnhandledReasons","rejection","set","rhs","delete","master","isDef","dispatch","array","makeGenerator","continuer","verb","arg","StopIteration","generator","errback","spawn","_return","promised","del","mapply","mcall","invoke","fapply","fbind","fbound","promises","pendingCount","snapshot","any","prev","current","onFulfilled","onRejected","onProgress","allResolved","allSettled","regardless","fail","fin","onUnhandledError","timeout","ms","timeoutId","code","delay","nfapply","nodeArgs","nfcall","nfbind","denodeify","baseArgs","nbind","bound","nmapply","npost","nsend","nmcall","ninvoke","nodeify","nodeback","connectTries","clientSettings","appId","baseURL","developmentMode","token","resolveEndpointPresence","groups","endpoints","calls","signalingChannel","presence","getPresence","saveParameters","eachParam","enableCallDebugReport","connectTimeoutMillis","retVal","endpointId","actuallyConnect","successHandler","authenticate","setPresence","onCall","onDirectConnection","onJoin","onLeave","onMessage","hangup","signal","onReconnect","errorHandler","verifyConnected","leaveGroups","eachGroup","group","isJoined","leave","finallyHandler","sendPresence","getCall","methods","screenshare","did","web","sip","conference","callParams","fromType","switchType","findCall","one","remoteEndpoint","caller","callerId","metadata","conferenceId","toType","number","addCall","removeCall","setOnline","setOffline","sendMessage","getEndpoint","skipPresence","joinConference","recipient","signalOffer","signalParams","signalType","sendSDP","signalAnswer","sessionId","signalConnected","connectionId","sendConnected","signalModify","sendModify","signalCandidate","sendCandidate","signalHangup","sendHangup","signalReport","report","sendReport","startScreenShare","startCall","startAudioCall","startVideoCall","startPhoneCall","startSIPCall","trunk","user","isConnected","joinGroup","groupList","getGroup","addGroup","addMember","connection","getConnection","newGroup","leaveHandler","endpointThatLeft","groupConnectionCount","eachEndpoint","ept","getGroups","grp","skipCreate","registerPresence","endpointList","onPresence","endpointsToSearch","connections","getEndpoints","getConferenceParticipants","ccSelf","startDirectConnection","directConnection","disconnectHandler","resolvePresence","hasAudio","addAudio","sendOnly","screenConstraints","con","needDirectConnection","offerOptions","OfferToReceiveAudio","directConnectionHandler","closeHandler","PRESENCE_CONSTANTS","presenceList","idList","sort","sorter","indexA","indexB","eachConnection","conn","joinedGroup","leftGroup","rawMessage","header","originalRecipient","toOriginal","fromConnection","timestamp","toConnection","requestConnectionReply","required","fromEndpoint","eachAttr","attr","cacheIsValid","clearConnections","validateConnection","validateMembership","leaveGroup","removeMember","absent","skipEvent","getMembers","getGroupMembers","eachMember","template","sdkHeaderValue","billingSuspensionErrorMessage","suspensionErrorMessage","getTime","PendingRequests","contents","counter","add","remove","presenceRegistered","pendingRequests","reconnectTimeout","maxReconnectTimeout","bodySizeLimit","appToken","routingMethods","handlerQueue","errors",400,401,403,404,409,429,500,"isConnecting","isSendingReport","tokenPromise","getToken","newToken","doOpen","httpMethod","parameters","ttl","response","statusCode","tokenId","errorMessage","isBillingSuspensionUnauthorizedResponse","isSuspensionUnauthorizedResponse","buildResponseError","wsCall","urlParams","show","removeConferenceParticipant","destroyConference","participants","par","toRun","saveDeferred","actualJoinGroup","needsToRun","requestJoinsForGroupQueue","ep","eachId","sendACK","sendSignal","signalId","ackedSignalType","finalCandidates","iceCandidates","debugData","firstUpper","routeSignal","doOffer","doConnected","doModify","doAnswer","doIceCandidates","doBye","doUnknown","addHandler","socketOnSignal","knownSignals","socketOnPubSub","groupMessage","socketOnJoin","presenceMessage","socketOnLeave","socketOnMessage","generateConnectHandler","addEachHandlerType","category","addEachHandler","capabilities","iceFinalCandidates","res","socketOnPresence","doReconnect","iterGroups","catch","finHandler","errHandler","connectParams","force new connection","connectFailedHandler","pendingRequest","getTurnCredentials","creds","uris","saveTurnUri","cred","logRequest","bodyLength","encodeURI","expand","tries","durationMillis","handleResponse","thisHandler","sendWebsocketRequest","failWebsocketRequest","App-Token","Respoke-SDK","paramString","makeParamString","unit","getAllResponseHeaders","getResponseHeader","strings","formatParam","xhrResponse","pairs","pair","val","requestId","urltemplate","UrlTemplate","encodeReserved","encodeValue","operator","isDefined","isKeyOperator","getValues","context","modifier","filter","tmp","operators","expression","literal","values","variable","separator","dataChannel","pc","listenDataChannel","onDataChannelError","onDataChannelMessage","onDataChannelOpen","onStart","fireStats","stats","getStats","onStats","MediaStats","onDataChannelClose","createDataChannel","binaryType","accept","answer","skipRemove","removeDirectConnection","isActive","Statechart","toSendHangup","defModify","previewLocalMedia","candidateReceivingQueue","signalCandidateOrig","digitSender","cancellingTones","signalCandidates","candidatesSent","pcOptions","DtlsSrtpKeyAgreement","RtpDataChannels","callStarted","callStopped","callerendpoint","callerconnection","calleeendpoint","calleeconnection","lastSDPString","sdpsSent","sdpsReceived","candidatesReceived","os","initOffer","receiveOnly","makeOptionsReceiveOnly","makeOptionsSendOnly","createOffer","saveOfferAndSend","oSession","setLocalDescription","sessionDescription","sentSDP","localCandidatesFSM","OfferToReceiveVideo","OfferToSendVideo","OfferToSendAudio","offerToReceiveVideo","offerToReceiveAudio","offerToSendVideo","offerToSendAudio","localCandidates","localCandidatesComplete","localCandidatesSent","localCandidatesTimeout","localCandidatesRemaining","collectLocalIceCandidate","candidate","sendRemainingCandidates","remainingCandidates","suppressFinalCandidates","finally","initialState","states","buffering","localIceCandidate","guard","sending","iceSent","waiting","entry","finished","run","processOffer","oOffer","onSetRemoteDescriptionSuccess","processReceivingQueue","createAnswer","saveAnswerAndSend","processedRemoteSDP","callStoppedReason","onSetRemoteDescriptionInitialError","alteredSdp","setRemoteDescription","onSetRemoteDescriptionFinalError","hasDataChannel","newErr","MediaStatsParser","peerConnection","interval","statsHandler","stopStats","servers","onicecandidate","onIceCandidate","oCan","iceGatheringState","forceTurn","disableTurn","oniceconnectionstatechange","onIceConnectionStateChange","iceConnectionState","onaddstream","onremovestream","ondatachannel","getRemoteStreams","getLocalStreams","addLocalTracksFromStream","getTracks","track","addTrack","addStream","removeLocalTracks","stop","getSenders","sender","removeTrack","removeStream","processIce","can","addIceCandidate","sendTones","duration","tones","createDTMFSender","audioTracks","outgoingMedia","getAudioTracks","ontonechange","onToneChange","tone","interToneGap","canInsertDTMF","insertDTMF","toneBuffer","cancelTones","tonesToCancel","cancelledTones","sentSignal","startModify","addRemoteCandidate","receivedSDP","handleAnswerSignal","handleConnectedSignal","handleModifySignal","isState","assert","assertion","opt","construct","myState","mySource","Initial","newInitialState","handled","TOP","flatten","anEventOrNull","equals","superstate","stateOrName","QState","_topState","currentState","statesTable","_flatten","selectState","stateName","anEvent","act","newState","handleUnhandledEvent","QEvent","aStateName","transition","aStateOrName","enterVia","entryLength","lca","idx","fsm","QEventEmpty","QEventEntry","QEventExit","QEventInit","allTimers","answerTimer","answerTimeout","receiveAnswerTimer","receiveAnswerTimeout","connectionTimer","connectionTimeout","modifyTimer","modifyTimeout","oldRole","condition","hasLocalMediaApproval","hasLocalMedia","receivedBye","isAnswered","isModifying","rejectEvent","timer","clear","hasMedia","hangupReason","rejectModify","clearReceiveAnswerTimer","hangupEvent","signalBye","needToObtainMedia","needToApproveDirectConnection","automaticOffering","hasListener","createTimer","time","stateParams","idle","initiate","receiveLocalMedia","receiveOffer","negotiatingContainer","modify","preparing","approve","gettingMedia","approvingDeviceAccess","approvingContent","offeringContainer","sentOffer","offering","receiveRemoteMedia","receiveAnswer","connectingContainer","removeRemoteMedia","modifyingContainer","modifying","connectedContainer","receive","terminatedContainer","terminated","debugOff","getState","oldState","nontransitionEvents","defineProperty","configurable","enumerable","defMedia","hasReceivedRemoteMedia","outgoingMediaStreams","hasVideo","getVideoTracks","incomingMediaStreams","videoIsMuted","audioIsMuted","onLocalMedia","onRemoteMedia","onHangup","onAllow","onAnswer","onApprove","onMute","onRequestingMedia","onToneSent","onToneSendingStarted","onToneSendingCancelled","videoLocalElement","videoRemoteElement","updateOutgoingMediaEstimate","updateIncomingMediaEstimate","buildLocalMedia","constraint","waitAllowHandler","allowHandler","streamReceivedHandler","onRemoteStreamAdded","onRemoteStreamRemoved","remoteMedia","temporary","shift","getLocalElement","getRemoteElement","stopHandler","muted","getOutgoingConstraints","kind","changeMedia","modifyAccepted","addVideo","outgoingConstraints","removeVideo","removeAudio","getDirectConnection","skipModify","onModifySuccess","addDirectConnection","actuallyAddDirectConnection","onModifyError","handleDirectConnectionClose","handleDirectConnectionAccept","handleDirectConnectionOpen","handleDirectionConnectionError","closeDirectConnection","doHangup","localMediaInstance","setSDP","setConstraints","listenOffer","toggleVideo","muteVideo","unmuteVideo","toggleAudio","muteAudio","unmuteAudio","local","remote","handleOfferSignal","handleHangupSignal","handlePeerConnectModifyReject","handlePeerConnectionModifyAccept","dc","handleIceCandidatesSignal","processCandidate","handleAnswer","mediaPromises","screenShareSource","allowTimer","mediaOptions","onReceiveUserMedia","theStream","numPc","autoplay","requestMedia","useFakeMedia","fake","delayPermissionsRequest","chromeMediaSourceId","onUserMediaError","isVideoMuted","enabled","eachTrack","isAudioMuted","onTopic","onPresenter","eventName","getParticipants","removeParticipant"],"mappings":"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","file":"build/respoke.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"respoke\"] = factory();\n\telse\n\t\troot[\"respoke\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*! Copyright (c) 2014, Digium, Inc. All Rights Reserved. MIT Licensed.For details and documentation visit https://www.respoke.io */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"respoke\"] = factory();\n\telse\n\t\troot[\"respoke\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\"use strict\";\n\t/*jshint bitwise: false*/\n\t\n\t// var Airbrake = require('airbrake-js');\n\tvar log = __webpack_require__(2);\n\tlog.setLevel(log.levels.WARN);\n\t\n\tvar originalFactory = log.methodFactory;\n\tlog.methodFactory = function logMethodFactory(methodName, logLevel) {\n\t    var logMethod = originalFactory(methodName, logLevel);\n\t    var errorReporter;\n\t\n\t    // if (!window.skipErrorReporting && methodName === 'error') {\n\t    //     var airbrake = new Airbrake({\n\t    //         projectId: '98133',\n\t    //         projectKey: 'cd3e085acc5e554658ebcdabd112a6f4'\n\t    //     });\n\t    //     errorReporter = function (message) {\n\t    //         airbrake.push({ error: { message: message } });\n\t    //     };\n\t    // } else {\n\t    //     errorReporter = function () { };\n\t    // }\n\t    errorReporter = function () { };\n\t\n\t    return function (message) {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        var reporterMessage = args.join(' ');\n\t\n\t        args.unshift('[Respoke]');\n\t        logMethod.apply(this, args);\n\t        errorReporter(reporterMessage);\n\t    };\n\t};\n\t\n\t__webpack_require__(3);\n\t\n\t/**\n\t * `respoke` is a global static class.\n\t *\n\t *\n\t * Include the [latest version](https://cdn.respoke.io/respoke.min.js) or\n\t * [choose a previous release](http://cdn.respoke.io/list.html).\n\t *\n\t * Or use `npm install --save respoke`.\n\t *\n\t * Interact with Respoke primarily via [`respoke.Client`](respoke.Client.html):\n\t *\n\t *      var client = respoke.createClient();\n\t *\n\t *\n\t * **Development mode without brokered auth**\n\t *\n\t *      var client = respoke.createClient({\n\t *          appId: \"XXXXXXX-my-app-id-XXXXXX\",\n\t *          developmentMode: true,\n\t *          endpointId: \"daveops\"\n\t *      });\n\t *\n\t *      client.connect({\n\t *          onSuccess: function () { ... },\n\t *          onError: function (err) { ... }\n\t *      });\n\t *\n\t *\n\t * **Production mode with brokered auth**\n\t *\n\t *      var client = respoke.createClient();\n\t *\n\t *      // Respoke auth token obtained by your server.\n\t *      // This is how you control who can connect to Respoke app.\n\t *      // See API docs for POST [base]/tokens\n\t *      var tokenId = \"XXXX-XXXX-brokered-auth-token-XXXXX\";\n\t *\n\t *      // connect to respoke with the token\n\t *      client.connect({\n\t *          token: tokenId\n\t *          onSuccess: function () { ... },\n\t *          onError: function (err) { ... }\n\t *      });\n\t *\n\t *      // fetch a new token from your server if it expires\n\t *      client.listen('disconnect', function (evt) {\n\t *          // fetch another token from your server.\n\t *          var newTokenId = \"XXXX-XXXX-brokered-auth-token2-XXXXX\";\n\t *          client.connect({\n\t *              token: newTokenId\n\t *          });\n\t *      });\n\t *\n\t *\n\t *\n\t * ### Event listeners vs callback handlers\n\t *\n\t * There are two ways to attach listeners. It is highly recommended that you choose one pattern\n\t * and stick to it throughout your app.\n\t *\n\t * For every `event-name`, there is a corresponding callback `onEventName`.\n\t *\n\t * **With a listener**\n\t *\n\t *      var client = respoke.createClient();\n\t *      client.listen('connect', function () { });\n\t *\n\t * **or with a callback**\n\t *\n\t *      var client = respoke.createClient({\n\t *          // other options go here\n\t *\n\t *          onConnect: function () { }\n\t *      });\n\t *\n\t *\n\t * @namespace respoke\n\t * @class respoke\n\t * @global\n\t * @link https://cdn.respoke.io/respoke.min.js\n\t */\n\t\n\tvar EventEmitter = __webpack_require__(4);\n\tvar respoke = module.exports = EventEmitter({\n\t    ridiculous: false, // print every websocket tx/rx\n\t    buildNumber: 'v2.1.1',\n\t    io: __webpack_require__(6),\n\t    Q: __webpack_require__(8)\n\t});\n\t\n\trespoke.Q.longStackSupport = true;\n\trespoke.Q.stackJumpLimit = 5;\n\trespoke.Q.longStackJumpLimit = 20;\n\trespoke.Q.stopUnhandledRejectionTracking();\n\t\n\t/**\n\t * A map of respoke.Client instances available for use. This is useful if you would like to separate some\n\t * functionality of your app into a separate Respoke app which would require a separate appId.\n\t * @type {boolean}\n\t */\n\trespoke.instances = {};\n\t\n\t/**\n\t * Indicate whether the user's browser is Chrome and requires the Respoke Chrome extension to do screen sharing.\n\t * @type {boolean}\n\t * @private\n\t */\n\trespoke.needsChromeExtension = !!(window.chrome && !window.opera && navigator.webkitGetUserMedia);\n\t\n\t/**\n\t * Indicate whether the user's browser is Firefox and requires the Respoke Firefox extension to do screen sharing.\n\t * @type {boolean}\n\t * @private\n\t */\n\trespoke.needsFirefoxExtension = window.webrtcDetectedBrowser === 'firefox';\n\t\n\t/**\n\t * Indicate whether the user has a Respoke Chrome extension installed and running correcty on this domain.\n\t * @type {boolean}\n\t * @private\n\t */\n\trespoke.hasChromeExtension = false;\n\t\n\t/**\n\t * Indicate whether the user has a Respoke Firefox extension installed and running correcty on this domain.\n\t * @type {boolean}\n\t * @private\n\t */\n\trespoke.hasFirefoxExtension = false;\n\t\n\t/**\n\t * This method will be overridden in the case that an extension or plugin is available for screen sharing.\n\t *\n\t * @static\n\t * @private\n\t * @memberof respoke\n\t */\n\trespoke.chooseDesktopMedia = function () {\n\t    log.warn(\"Screen sharing is not implemented for this browser.\");\n\t};\n\t\n\t/**\n\t * Indicate whether we are dealing with node-webkit, and expose chooseDesktopMedia if so\n\t * @type {boolean}\n\t * @private\n\t */\n\trespoke.isNwjs = (function () {\n\t    var gui;\n\t    var isNwjs = !!((typeof process !== 'undefined') && (typeof global !== 'undefined') &&\n\t        global.window && global.window.nwDispatcher);\n\t\n\t    if (isNwjs) {\n\t        // expose native node-webkit chooseDesktopMedia (requires nw.js 0.12+)\n\t        gui = window.nwDispatcher.requireNwGui();\n\t        gui.Screen.Init();\n\t\n\t        respoke.chooseDesktopMedia = function (data, callback) {\n\t            // make data param optional\n\t            if (!callback && (typeof data === 'function')) {\n\t                callback = data;\n\t                data = null;\n\t            }\n\t\n\t            /*\n\t             * mediaSources can be one of 'window', 'screen', or 'tab', or an array with multiples\n\t             * https://developer.chrome.com/extensions/desktopCapture\n\t             */\n\t            var mediaSources = data && data.source ? [data.source] : ['window', 'screen'];\n\t\n\t            gui.Screen.chooseDesktopMedia(mediaSources, function (sourceId) {\n\t                callback({\n\t                    type: 'respoke-source-id',\n\t                    sourceId: sourceId\n\t                });\n\t            });\n\t        };\n\t    }\n\t\n\t    return isNwjs;\n\t})();\n\t\n\t/**\n\t * Create an Event. This is used in the Chrome/Firefox extensions to communicate between the library and extension.\n\t * @type {function}\n\t * @private\n\t */\n\trespoke.extEvent = function (type, data) {\n\t    var evt = document.createEvent(\"CustomEvent\");\n\t    evt.initCustomEvent(type, true, true, data);\n\t    return evt;\n\t};\n\t\n\t/**\n\t * `\"v0.0.0\"`\n\t *\n\t * The respoke.min.js version.\n\t *\n\t * Past versions can be found at [cdn.respoke.io/list.html](http://cdn.respoke.io/list.html)\n\t * @type {string}\n\t */\n\trespoke.version = respoke.buildNumber + \"\";\n\t\n\trespoke.log = log;\n\trespoke.Class = __webpack_require__(5);\n\trespoke.EventEmitter = EventEmitter;\n\trespoke.Client = __webpack_require__(9);\n\trespoke.Connection = __webpack_require__(10);\n\trespoke.Endpoint = __webpack_require__(11);\n\trespoke.TextMessage = __webpack_require__(12);\n\trespoke.SignalingMessage = __webpack_require__(13);\n\trespoke.Group = __webpack_require__(14);\n\trespoke.SignalingChannel = __webpack_require__(15);\n\trespoke.DirectConnection = __webpack_require__(17);\n\trespoke.PeerConnection = __webpack_require__(18);\n\trespoke.CallState = __webpack_require__(20);\n\trespoke.Call = __webpack_require__(21);\n\trespoke.LocalMedia = __webpack_require__(22);\n\trespoke.RemoteMedia = __webpack_require__(23);\n\trespoke.Conference = __webpack_require__(24);\n\t\n\t/**\n\t * Get information from the Respoke Screen Sharing Chrome extension if it is installed.\n\t * @private\n\t */\n\tfunction chromeScreenSharingExtensionReady(evt) {\n\t    var data = evt.detail;\n\t    if (data.available !== true) {\n\t        return;\n\t    }\n\t\n\t    respoke.hasChromeExtension = true;\n\t    respoke.chooseDesktopMedia = function (params, callback) {\n\t        if (!callback) {\n\t            throw new Error(\"Can't choose desktop media without callback parameter.\");\n\t        }\n\t\n\t        function sourceIdListener(evt) {\n\t            var data = evt.detail;\n\t\n\t            respoke.screenSourceId = data.sourceId;\n\t            callback(data);\n\t            document.removeEventListener(\"respoke-source-id\", sourceIdListener);\n\t        }\n\t\n\t        document.dispatchEvent(respoke.extEvent('ct-respoke-source-id', {\n\t            source: params.source ? [params.source] : ['screen', 'window']\n\t        }));\n\t\n\t        document.addEventListener(\"respoke-source-id\", sourceIdListener);\n\t    };\n\t\n\t    respoke.fire('extension-loaded', {\n\t        type: 'screen-sharing'\n\t    });\n\t\n\t    log.info(\"Respoke Screen Share Chrome extension available for use.\");\n\t}\n\t\n\t// TODO: remove 'respoke-available' event listener on next major version bump\n\tdocument.addEventListener('respoke-available', chromeScreenSharingExtensionReady);\n\tdocument.addEventListener('respoke-chrome-screen-sharing-available', chromeScreenSharingExtensionReady);\n\tdocument.addEventListener('respoke-firefox-screen-sharing-available', function (evt) {\n\t\n\t    var data = evt.detail;\n\t    if (data !== 'available') {\n\t        return;\n\t    }\n\t\n\t    respoke.hasFirefoxExtension = true;\n\t\n\t    respoke.fire('extension-loaded', {\n\t        type: 'screen-sharing'\n\t    });\n\t\n\t    log.info(\"Respoke Screen Share Firefox extension available for use.\");\n\t});\n\t\n\t/**\n\t * This is one of two possible entry points for interating with the library.\n\t *\n\t * This method creates a new Client object\n\t * which represents your user's connection to your Respoke app.\n\t *\n\t * This method **automatically calls client.connect(params)** after the client is created.\n\t *\n\t * @static\n\t * @memberof respoke\n\t * @param {object} params Parameters to the respoke.Client constructor.\n\t * @param {string} [params.appId]\n\t * @param {string} [params.baseURL]\n\t * @param {string} [params.token]\n\t * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n\t * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n\t * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t * operation and will limit the services you will be able to use.\n\t * @param {boolean} [params.reconnect=false] - Whether or not to automatically reconnect to the Respoke service\n\t * when a disconnect occurs.\n\t * @param {function} [params.onSuccess] - Success handler for this invocation of this method only.\n\t * @param {function} [params.onError] - Error handler for this invocation of this method only.\n\t * @param {function} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t * @param {function} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n\t * @param {function} [params.onMessage] - Callback for when any message is received from anywhere on the system.\n\t * @param {function} [params.onDisconnect] - Callback for Client disconnect.\n\t * @param {function} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n\t * @param {function} [params.onCall] - Callback for when this client's user receives a call.\n\t * @param {function} [params.onDirectConnection] - Callback for when this client's user receives a request for a\n\t * direct connection.\n\t * @param {boolean} [params.enableCallDebugReport=true] - Optional flag defaulting to true which allows sending\n\t * debugging information.\n\t * @returns {respoke.Client}\n\t */\n\trespoke.connect = function (params) {\n\t    var client = respoke.Client(params);\n\t    client.connect(params);\n\t    return client;\n\t};\n\t\n\t/**\n\t * Getter for the respoke client.\n\t *\n\t * You can have more than one active client, so this method provides a way to retrieve a specific instance.\n\t *\n\t * @static\n\t * @memberof respoke\n\t * @param {string} id The Client ID.\n\t * @returns {respoke.Client}\n\t */\n\trespoke.getClient = function (id) {\n\t    if (id === undefined) {\n\t        log.debug(\"Can't call getClient with no client ID.\", new Error().stack);\n\t    }\n\t    if (!respoke.instances[id]) {\n\t        log.debug(\"No client instance with id\", id);\n\t    }\n\t    return respoke.instances[id];\n\t};\n\t\n\t/**\n\t * This is one of two possible entry points for interating with the library.\n\t *\n\t * This method creates a new Client object which represents your user's connection to your Respoke app.\n\t *\n\t * It **does NOT automatically call the client.connect() method** after the client is created.\n\t *\n\t * The `params` argument is the same as `respoke.connect(params)`.\n\t *\n\t * @static\n\t * @memberof respoke\n\t * @param {object} [params] Parameters to respoke.Client - same as respoke.connect()\n\t * @returns {respoke.Client}\n\t */\n\trespoke.createClient = function (params) {\n\t    var client;\n\t    params = params || {};\n\t    if (params.instanceId) {\n\t        client = respoke.getClient(params.instanceId);\n\t        if (client) {\n\t            return client;\n\t        }\n\t    }\n\t    return respoke.Client(params);\n\t};\n\t\n\t/**\n\t * Build a closure from a listener that will ensure the listener can only be called once.\n\t * @static\n\t * @private\n\t * @memberof respoke\n\t * @param {function} func\n\t * @return {function}\n\t */\n\trespoke.callOnce = function (func) {\n\t    return (function () {\n\t        var called = false;\n\t        return function () {\n\t            if (called === false) {\n\t                func.apply(null, arguments);\n\t                called = true;\n\t            }\n\t        };\n\t    })();\n\t};\n\t\n\t/**\n\t * @static\n\t * @private\n\t * @memberof respoke\n\t * @returns {number}\n\t */\n\trespoke.makeGUID = function () {\n\t    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\t    var uuid = new Array(36);\n\t    var rnd = 0;\n\t    var r;\n\t    for (var i = 0; i < 36; i += 1) {\n\t        if (i === 8 || i === 13 ||  i === 18 || i === 23) {\n\t            uuid[i] = '-';\n\t        } else if (i === 14) {\n\t            uuid[i] = '4';\n\t        } else {\n\t            if (rnd <= 0x02) {\n\t                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\n\t            }\n\t            r = rnd & 0xf;\n\t            rnd = rnd >> 4;\n\t            uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\n\t        }\n\t    }\n\t    return uuid.join('');\n\t};\n\t\n\t/**\n\t * This method is used internally to attach handlers to promises that are returned by many methods in the library.\n\t * It's not recommended that this method be used by developers and apps.\n\t * @private\n\t * @static\n\t * @memberof respoke\n\t * @param {Promise} promise\n\t * @param {function} onSuccess\n\t * @param {function} onError\n\t * @returns {Promise|undefined}\n\t */\n\trespoke.handlePromise = function (promise, onSuccess, onError) {\n\t    var returnUndef = false;\n\t    if (onSuccess || onError) {\n\t        returnUndef = true;\n\t    }\n\t\n\t    onSuccess = typeof onSuccess === 'function' ? onSuccess : function () {};\n\t    onError = typeof onError === 'function' ? onError : function () {};\n\t    promise.done(onSuccess, onError);\n\t    return (returnUndef ? undefined : promise);\n\t};\n\t\n\t/**\n\t * Does the browser support `UserMedia`?\n\t * @static\n\t * @memberof respoke\n\t * @returns {boolean}\n\t */\n\trespoke.hasUserMedia = function () {\n\t    return (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) instanceof Function;\n\t};\n\t\n\t/**\n\t * Does the browser support `RTCPeerConnection`?\n\t * @static\n\t * @memberof respoke\n\t * @returns {boolean}\n\t */\n\trespoke.hasRTCPeerConnection = function () {\n\t    return (window.RTCPeerConnection || window.webkitRTCPeerConnection ||\n\t            window.mozRTCPeerConnection) instanceof Function;\n\t};\n\t\n\t/**\n\t * Does the browser support `WebSocket`?\n\t * @static\n\t * @memberof respoke\n\t * @returns {boolean}\n\t */\n\trespoke.hasWebsocket = function () {\n\t    return (window.WebSocket || window.webkitWebSocket || window.MozWebSocket) instanceof Function;\n\t};\n\t\n\t/**\n\t * Does the browser have Screen Sharing enabled via browser extensions?\n\t * @static\n\t * @memberof respoke\n\t * @returns {boolean}\n\t */\n\trespoke.hasScreenShare = function () {\n\t    return respoke.hasChromeExtension || respoke.hasFirefoxExtension;\n\t};\n\t\n\t/**\n\t * Clone an object.\n\t * @static\n\t * @memberof respoke\n\t * @private\n\t * @param {Object} source - The object to clone\n\t * @returns {Object}\n\t */\n\trespoke.clone = function (source) {\n\t    if (source) {\n\t        return JSON.parse(JSON.stringify(source));\n\t    }\n\t    return source;\n\t};\n\t\n\t/**\n\t * Compares two objects for equality\n\t * @static\n\t * @memberof respoke\n\t * @private\n\t * @param {Object} a\n\t * @param {Object} b\n\t * @returns {boolean}\n\t */\n\trespoke.isEqual = function (a, b) {\n\t    var aKeys;\n\t    var i;\n\t\n\t    //check if arrays\n\t    if (a && b && a.hasOwnProperty('length') && b.hasOwnProperty('length') && a.splice && b.splice) {\n\t        if (a.length !== b.length) {\n\t            //short circuit if arrays are different length\n\t            return false;\n\t        }\n\t\n\t        for (i = 0; i < a.length; i += 1) {\n\t            if (!respoke.isEqual(a[i], b[i])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    if (typeof a === 'object' && typeof b === 'object' && Object.keys(a).length === Object.keys(b).length) {\n\t        aKeys = Object.keys(a);\n\t        for (i = 0; i < aKeys.length; i += 1) {\n\t            if (!respoke.isEqual(a[aKeys[i]], b[aKeys[i]])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    return a === b;\n\t};\n\t\n\t/**\n\t * Does the sdp indicate an audio stream?\n\t * @static\n\t * @memberof respoke\n\t * @params {string}\n\t * @returns {boolean}\n\t * @private\n\t */\n\trespoke.sdpHasAudio = function (sdp) {\n\t    if (!sdp) {\n\t        throw new Error(\"respoke.sdpHasAudio called with no parameters.\");\n\t    }\n\t    return (sdp.indexOf('m=audio') !== -1 && sdp.indexOf('a=recvonly') === -1);\n\t};\n\t\n\t/**\n\t * Does the sdp indicate a video stream?\n\t * @static\n\t * @memberof respoke\n\t * @params {string}\n\t * @returns {boolean}\n\t * @private\n\t */\n\trespoke.sdpHasVideo = function (sdp) {\n\t    if (!sdp) {\n\t        throw new Error(\"respoke.sdpHasVideo called with no parameters.\");\n\t    }\n\t    return (sdp.indexOf('m=video') !== -1 && sdp.indexOf('a=recvonly') === -1);\n\t};\n\t\n\t/**\n\t * Does the sdp indicate a data channel?\n\t * @static\n\t * @memberof respoke\n\t * @params {string}\n\t * @returns {boolean}\n\t * @private\n\t */\n\trespoke.sdpHasDataChannel = function (sdp) {\n\t    if (!sdp) {\n\t        throw new Error(\"respoke.sdpHasDataChannel called with no parameters.\");\n\t    }\n\t    return sdp.indexOf('m=application') !== -1;\n\t};\n\t\n\t/**\n\t * Does the sdp indicate the creator is sendOnly?\n\t * @static\n\t * @memberof respoke\n\t * @params {string}\n\t * @returns {boolean}\n\t * @private\n\t */\n\trespoke.sdpHasSendOnly = function (sdp) {\n\t    if (!sdp) {\n\t        throw new Error(\"respoke.sdpHasSendOnly called with no parameters.\");\n\t    }\n\t    return sdp.indexOf('a=sendonly') !== -1;\n\t};\n\t\n\t/**\n\t * Does the sdp indicate the creator is receiveOnly?\n\t * @static\n\t * @memberof respoke\n\t * @params {string}\n\t * @returns {boolean}\n\t * @private\n\t */\n\trespoke.sdpHasReceiveOnly = function (sdp) {\n\t    if (!sdp) {\n\t        throw new Error(\"respoke.sdpHasReceiveOnly called with no parameters.\");\n\t    }\n\t    return sdp.indexOf('a=recvonly') !== -1;\n\t};\n\t\n\t/**\n\t * Do the constraints indicate an audio stream?\n\t * @static\n\t * @memberof respoke\n\t * @params {RTCConstraints}\n\t * @returns {boolean}\n\t * @private\n\t */\n\trespoke.constraintsHasAudio = function (constraints) {\n\t    if (!constraints) {\n\t        throw new Error(\"respoke.constraintsHasAudio called with no parameters.\");\n\t    }\n\t    return (constraints.audio === true);\n\t};\n\t\n\t/**\n\t * Does the constraints indicate a video stream?\n\t * @static\n\t * @memberof respoke\n\t * @params {RTCConstraints}\n\t * @returns {boolean}\n\t * @private\n\t */\n\trespoke.constraintsHasVideo = function (constraints) {\n\t    if (!constraints) {\n\t        throw new Error(\"respoke.constraintsHasVideo called with no parameters.\");\n\t    }\n\t    return (constraints.video === true || typeof constraints.video === 'object');\n\t};\n\t\n\t/**\n\t * Does the constraints indicate a screenshare?\n\t * @static\n\t * @memberof respoke\n\t * @params {RTCConstraints}\n\t * @returns {boolean}\n\t * @private\n\t */\n\trespoke.constraintsHasScreenShare = function (constraints) {\n\t    if (!constraints) {\n\t        throw new Error(\"respoke.constraintsHasScreenShare called with no parameters.\");\n\t    }\n\t\n\t    return (constraints.video && constraints.video.mandatory &&\n\t            (constraints.video.mandatory.chromeMediaSource || constraints.video.mediaSource));\n\t};\n\t\n\t/**\n\t * Convert old-style constraints parameter into a constraints array.\n\t * @static\n\t * @memberof respoke\n\t * @params {Array<RTCConstraints>|RTCConstraints} [constraints]\n\t * @params {Array<RTCConstraints>} [defaults]\n\t * @returns {Array<RTCConstraints>}\n\t * @private\n\t */\n\trespoke.convertConstraints = function (constraints, defaults) {\n\t    constraints = constraints || [];\n\t    defaults = defaults || [];\n\t\n\t    if (!constraints.splice) {\n\t        if (typeof constraints === 'object') {\n\t            constraints = [constraints];\n\t        } else {\n\t            constraints = [];\n\t        }\n\t    }\n\t\n\t    if (constraints.length === 0 && defaults.length > 0) {\n\t        return defaults;\n\t    }\n\t\n\t    return constraints;\n\t};\n\t\n\t/**\n\t * Queue items until a trigger is called, then process them all with an action. Before trigger, hold items for\n\t * processing. After trigger, process new items immediately.\n\t * @static\n\t * @memberof respoke\n\t * @returns {Array}\n\t * @private\n\t */\n\trespoke.queueFactory = function () {\n\t    var queue = [];\n\t    // action replaces Array.push when trigger is called. Thrown errors will be caught and logged.\n\t    queue.trigger = function (action) {\n\t        if (!action) {\n\t            throw new Error(\"Trigger function requires an action parameter.\");\n\t        }\n\t\n\t        function safeAction(item) {\n\t            try {\n\t                action(item);\n\t            } catch (err) {\n\t                log.error(\"Error calling queue action.\", err);\n\t            }\n\t        }\n\t        queue.forEach(safeAction);\n\t        queue.length = 0;\n\t        queue.push = safeAction;\n\t    };\n\t\n\t    return queue;\n\t};\n\t\n\t/**\n\t * Retrieve browser-specific WebRTC getUserMedia constraints needed to start a screen sharing call. Takes a set of\n\t * optional override constraints and amends them for screen sharing.\n\t *\n\t * @memberof respoke\n\t * @static\n\t * @param {object} [params]\n\t * @param {string} [params.source] The media source name to pass to firefox\n\t * @param {RTCConstraints} [params.constraints] constraints to use as a base\n\t * @returns {RTCConstraints}\n\t * @private\n\t */\n\trespoke.getScreenShareConstraints = function (params) {\n\t    params = params || {};\n\t\n\t    var screenConstraint = params.constraints || {\n\t        audio: false,\n\t        video: {\n\t            mandatory: {},\n\t            optional: []\n\t        }\n\t    };\n\t    screenConstraint.audio = false;\n\t    screenConstraint.video = typeof screenConstraint.video === 'object' ? screenConstraint.video : {};\n\t    screenConstraint.video.optional = Array.isArray(screenConstraint.video.optional) ?\n\t        screenConstraint.video.optional : [];\n\t    screenConstraint.video.mandatory = typeof screenConstraint.video.mandatory === 'object' ?\n\t        screenConstraint.video.mandatory : {};\n\t\n\t    if (respoke.needsChromeExtension || respoke.isNwjs) {\n\t        screenConstraint.audio = false;\n\t        screenConstraint.video.mandatory.chromeMediaSource = 'desktop';\n\t        screenConstraint.video.mandatory.maxWidth = typeof screenConstraint.video.mandatory.maxWidth === 'number' ?\n\t            screenConstraint.video.mandatory.maxWidth : 2000;\n\t        screenConstraint.video.mandatory.maxHeight = typeof screenConstraint.video.mandatory.maxHeight === 'number' ?\n\t            screenConstraint.video.mandatory.maxHeight : 2000;\n\t\n\t        if (screenConstraint.video.optional.length > 0) {\n\t            screenConstraint.video.optional.forEach(function (thing) {\n\t                thing.googTemporalLayeredScreencast = true;\n\t            });\n\t        } else {\n\t            screenConstraint.video.optional[0] = {\n\t                googTemporalLayeredScreencast: true\n\t            };\n\t        }\n\t    } else {\n\t        // firefox, et. al.\n\t        screenConstraint.video.mediaSource = params.source || 'screen';\n\t    }\n\t\n\t    return screenConstraint;\n\t};\n\t\n\t/**\n\t * Retrieve a started instance of `respoke.LocalMedia` containing a screen share stream. Useful if you\n\t * want to prepare the stream prior to starting a screen share.\n\t *\n\t *     respoke.getScreenShareMedia().then(function (localMedia) {\n\t *         document.getElementById('#video').appendChild(localMedia.element);\n\t *         group.listen('join', function (evt) {\n\t *             evt.connection.startScreenShare({\n\t *                 outgoingMedia: localMedia\n\t *             });\n\t *         });\n\t *     }).catch(function (err) {\n\t *         console.log(err);\n\t *     });\n\t *\n\t * @static\n\t * @memberof respoke\n\t * @param {object} params\n\t * @param {string} [params.source] - The source you would like to use for your screen share. Values vary by browser.\n\t *  In Chrome, acceptable values are one of 'screen', 'window', or 'tab'.\n\t *  In Firefox, acceptable values are one of 'screen', 'window', or 'application'.\n\t * @param {RTCConstraints|Array<RTCConstraints>} [params.constraints] - constraints to use as a base\n\t * @param {HTMLVideoElement} [params.element] - Pass in an optional html video element to have local\n\t *  video attached to it.\n\t * @param {function} [params.onSuccess] Upon success, called with instance of `respoke.LocalMedia`\n\t * @param {function} [params.onError] Upon failure, called with the error that occurred.\n\t * @returns {Promise|undefined}\n\t * @private\n\t */\n\trespoke.getScreenShareMedia = function (params) {\n\t    params = params || {};\n\t\n\t    var deferred = respoke.Q.defer();\n\t    var criteria = {\n\t        source: params.source,\n\t        constraints: respoke.clone(params.constraints)\n\t    };\n\t    var localMedia = respoke.LocalMedia({\n\t        hasScreenShare: true,\n\t        constraints: respoke.getScreenShareConstraints(criteria),\n\t        source: params.source,\n\t        element: params.element\n\t    });\n\t\n\t    localMedia.start().done(function () {\n\t        deferred.resolve(localMedia);\n\t    }, function (err) {\n\t        deferred.reject(err);\n\t    });\n\t\n\t    return respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n\t* loglevel - https://github.com/pimterry/loglevel\r\n\t*\r\n\t* Copyright (c) 2013 Tim Perry\r\n\t* Licensed under the MIT license.\r\n\t*/\r\n\t(function (root, definition) {\r\n\t    \"use strict\";\r\n\t    if (typeof module === 'object' && module.exports && \"function\" === 'function') {\r\n\t        module.exports = definition();\r\n\t    } else if (true) {\r\n\t        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t    } else {\r\n\t        root.log = definition();\r\n\t    }\r\n\t}(this, function () {\r\n\t    \"use strict\";\r\n\t    var noop = function() {};\r\n\t    var undefinedType = \"undefined\";\r\n\t\r\n\t    function realMethod(methodName) {\r\n\t        if (typeof console === undefinedType) {\r\n\t            return false; // We can't build a real method without a console to log to\r\n\t        } else if (console[methodName] !== undefined) {\r\n\t            return bindMethod(console, methodName);\r\n\t        } else if (console.log !== undefined) {\r\n\t            return bindMethod(console, 'log');\r\n\t        } else {\r\n\t            return noop;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function bindMethod(obj, methodName) {\r\n\t        var method = obj[methodName];\r\n\t        if (typeof method.bind === 'function') {\r\n\t            return method.bind(obj);\r\n\t        } else {\r\n\t            try {\r\n\t                return Function.prototype.bind.call(method, obj);\r\n\t            } catch (e) {\r\n\t                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n\t                return function() {\r\n\t                    return Function.prototype.apply.apply(method, [obj, arguments]);\r\n\t                };\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // these private functions always need `this` to be set properly\r\n\t\r\n\t    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\r\n\t        return function () {\r\n\t            if (typeof console !== undefinedType) {\r\n\t                replaceLoggingMethods.call(this, level, loggerName);\r\n\t                this[methodName].apply(this, arguments);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t\r\n\t    function replaceLoggingMethods(level, loggerName) {\r\n\t        /*jshint validthis:true */\r\n\t        for (var i = 0; i < logMethods.length; i++) {\r\n\t            var methodName = logMethods[i];\r\n\t            this[methodName] = (i < level) ?\r\n\t                noop :\r\n\t                this.methodFactory(methodName, level, loggerName);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function defaultMethodFactory(methodName, level, loggerName) {\r\n\t        /*jshint validthis:true */\r\n\t        return realMethod(methodName) ||\r\n\t               enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n\t    }\r\n\t\r\n\t    var logMethods = [\r\n\t        \"trace\",\r\n\t        \"debug\",\r\n\t        \"info\",\r\n\t        \"warn\",\r\n\t        \"error\"\r\n\t    ];\r\n\t\r\n\t    function Logger(name, defaultLevel, factory) {\r\n\t      var self = this;\r\n\t      var currentLevel;\r\n\t      var storageKey = \"loglevel\";\r\n\t      if (name) {\r\n\t        storageKey += \":\" + name;\r\n\t      }\r\n\t\r\n\t      function persistLevelIfPossible(levelNum) {\r\n\t          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n\t\r\n\t          // Use localStorage if available\r\n\t          try {\r\n\t              window.localStorage[storageKey] = levelName;\r\n\t              return;\r\n\t          } catch (ignore) {}\r\n\t\r\n\t          // Use session cookie as fallback\r\n\t          try {\r\n\t              window.document.cookie =\r\n\t                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n\t          } catch (ignore) {}\r\n\t      }\r\n\t\r\n\t      function getPersistedLevel() {\r\n\t          var storedLevel;\r\n\t\r\n\t          try {\r\n\t              storedLevel = window.localStorage[storageKey];\r\n\t          } catch (ignore) {}\r\n\t\r\n\t          if (typeof storedLevel === undefinedType) {\r\n\t              try {\r\n\t                  var cookie = window.document.cookie;\r\n\t                  var location = cookie.indexOf(\r\n\t                      encodeURIComponent(storageKey) + \"=\");\r\n\t                  if (location) {\r\n\t                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\r\n\t                  }\r\n\t              } catch (ignore) {}\r\n\t          }\r\n\t\r\n\t          // If the stored level is not valid, treat it as if nothing was stored.\r\n\t          if (self.levels[storedLevel] === undefined) {\r\n\t              storedLevel = undefined;\r\n\t          }\r\n\t\r\n\t          return storedLevel;\r\n\t      }\r\n\t\r\n\t      /*\r\n\t       *\r\n\t       * Public API\r\n\t       *\r\n\t       */\r\n\t\r\n\t      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n\t          \"ERROR\": 4, \"SILENT\": 5};\r\n\t\r\n\t      self.methodFactory = factory || defaultMethodFactory;\r\n\t\r\n\t      self.getLevel = function () {\r\n\t          return currentLevel;\r\n\t      };\r\n\t\r\n\t      self.setLevel = function (level, persist) {\r\n\t          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n\t              level = self.levels[level.toUpperCase()];\r\n\t          }\r\n\t          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n\t              currentLevel = level;\r\n\t              if (persist !== false) {  // defaults to true\r\n\t                  persistLevelIfPossible(level);\r\n\t              }\r\n\t              replaceLoggingMethods.call(self, level, name);\r\n\t              if (typeof console === undefinedType && level < self.levels.SILENT) {\r\n\t                  return \"No console available for logging\";\r\n\t              }\r\n\t          } else {\r\n\t              throw \"log.setLevel() called with invalid level: \" + level;\r\n\t          }\r\n\t      };\r\n\t\r\n\t      self.setDefaultLevel = function (level) {\r\n\t          if (!getPersistedLevel()) {\r\n\t              self.setLevel(level, false);\r\n\t          }\r\n\t      };\r\n\t\r\n\t      self.enableAll = function(persist) {\r\n\t          self.setLevel(self.levels.TRACE, persist);\r\n\t      };\r\n\t\r\n\t      self.disableAll = function(persist) {\r\n\t          self.setLevel(self.levels.SILENT, persist);\r\n\t      };\r\n\t\r\n\t      // Initialize with the right level\r\n\t      var initialLevel = getPersistedLevel();\r\n\t      if (initialLevel == null) {\r\n\t          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\r\n\t      }\r\n\t      self.setLevel(initialLevel, false);\r\n\t    }\r\n\t\r\n\t    /*\r\n\t     *\r\n\t     * Package-level API\r\n\t     *\r\n\t     */\r\n\t\r\n\t    var defaultLogger = new Logger();\r\n\t\r\n\t    var _loggersByName = {};\r\n\t    defaultLogger.getLogger = function getLogger(name) {\r\n\t        if (typeof name !== \"string\" || name === \"\") {\r\n\t          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n\t        }\r\n\t\r\n\t        var logger = _loggersByName[name];\r\n\t        if (!logger) {\r\n\t          logger = _loggersByName[name] = new Logger(\r\n\t            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\r\n\t        }\r\n\t        return logger;\r\n\t    };\r\n\t\r\n\t    // Grab the current global log variable in case of overwrite\r\n\t    var _log = (typeof window !== undefinedType) ? window.log : undefined;\r\n\t    defaultLogger.noConflict = function() {\r\n\t        if (typeof window !== undefinedType &&\r\n\t               window.log === defaultLogger) {\r\n\t            window.log = _log;\r\n\t        }\r\n\t\r\n\t        return defaultLogger;\r\n\t    };\r\n\t\r\n\t    return defaultLogger;\r\n\t}));\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*!\n\t *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.\n\t *\n\t *  Use of this source code is governed by a BSD-style license\n\t *  that can be found in the LICENSE file in the same directory as\n\t *  this source file.\n\t * @ignore\n\t */\n\t\n\t/* More information about these options at jshint.com/docs/options */\n\t\n\t/* jshint browser: true, camelcase: true, curly: true, devel: true,\n\teqeqeq: true, forin: false, globalstrict: true, quotmark: single,\n\tundef: true, unused: strict */\n\t\n\t/* global mozRTCIceCandidate, mozRTCPeerConnection,\n\tmozRTCSessionDescription, webkitRTCPeerConnection */\n\t\n\t/* exported trace */\n\t\n\t'use strict';\n\t\n\tvar RTCPeerConnection = null;\n\tvar getUserMedia = null;\n\tvar attachMediaStream = null;\n\tvar reattachMediaStream = null;\n\tvar webrtcDetectedBrowser = null;\n\tvar webrtcDetectedVersion = null;\n\t\n\tfunction trace(text) {\n\t  // This function is used for logging.\n\t  if (text[text.length - 1] === '\\n') {\n\t    text = text.substring(0, text.length - 1);\n\t  }\n\t  console.log((window.performance.now() / 1000).toFixed(3) + ': ' + text);\n\t}\n\t\n\tfunction maybeFixConfiguration(pcConfig) {\n\t  if (!pcConfig) {\n\t    return;\n\t  }\n\t  for (var i = 0; i < pcConfig.iceServers.length; i++) {\n\t    if (pcConfig.iceServers[i].hasOwnProperty('urls')) {\n\t      pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;\n\t      delete pcConfig.iceServers[i].urls;\n\t    }\n\t  }\n\t}\n\t\n\tif (navigator.mozGetUserMedia) {\n\t  console.log('This appears to be Firefox');\n\t\n\t  webrtcDetectedBrowser = 'firefox';\n\t\n\t  webrtcDetectedVersion =\n\t    parseInt(navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1], 10);\n\t\n\t  // The RTCPeerConnection object.\n\t  RTCPeerConnection = function(pcConfig, pcConstraints) {\n\t    // .urls is not supported in FF yet.\n\t    maybeFixConfiguration(pcConfig);\n\t    return new mozRTCPeerConnection(pcConfig, pcConstraints);\n\t  };\n\t\n\t  // The RTCSessionDescription object.\n\t  window.RTCSessionDescription = mozRTCSessionDescription;\n\t\n\t  // The RTCIceCandidate object.\n\t  window.RTCIceCandidate = mozRTCIceCandidate;\n\t\n\t  // getUserMedia shim (only difference is the prefix).\n\t  // Code from Adam Barth.\n\t  getUserMedia = navigator.mozGetUserMedia.bind(navigator);\n\t  navigator.getUserMedia = getUserMedia;\n\t\n\t  // Creates ICE server from the URL for FF.\n\t  window.createIceServer = function(url, username, password) {\n\t    var iceServer = null;\n\t    var urlParts = url.split(':');\n\t    if (urlParts[0].indexOf('stun') === 0) {\n\t      // Create ICE server with STUN URL.\n\t      iceServer = {\n\t        'url': url\n\t      };\n\t    } else if (urlParts[0].indexOf('turn') === 0) {\n\t      if (webrtcDetectedVersion < 27) {\n\t        // Create iceServer with turn url.\n\t        // Ignore the transport parameter from TURN url for FF version <=27.\n\t        var turnUrlParts = url.split('?');\n\t        // Return null for createIceServer if transport=tcp.\n\t        if (turnUrlParts.length === 1 ||\n\t          turnUrlParts[1].indexOf('transport=udp') === 0) {\n\t          iceServer = {\n\t            'url': turnUrlParts[0],\n\t            'credential': password,\n\t            'username': username\n\t          };\n\t        }\n\t      } else {\n\t        // FF 27 and above supports transport parameters in TURN url,\n\t        // So passing in the full url to create iceServer.\n\t        iceServer = {\n\t          'url': url,\n\t          'credential': password,\n\t          'username': username\n\t        };\n\t      }\n\t    }\n\t    return iceServer;\n\t  };\n\t\n\t  window.createIceServers = function(urls, username, password) {\n\t    var iceServers = [];\n\t    // Use .url for FireFox.\n\t    for (var i = 0; i < urls.length; i++) {\n\t      var iceServer =\n\t        window.createIceServer(urls[i], username, password);\n\t      if (iceServer !== null) {\n\t        iceServers.push(iceServer);\n\t      }\n\t    }\n\t    return iceServers;\n\t  };\n\t\n\t  // Attach a media stream to an element.\n\t  attachMediaStream = function(element, stream) {\n\t    //console.log('Attaching media stream');\n\t    element.mozSrcObject = stream;\n\t    setTimeout(function () {\n\t      element.play();\n\t    }, 100);\n\t  };\n\t\n\t  reattachMediaStream = function(to, from) {\n\t    //console.log('Reattaching media stream');\n\t    to.mozSrcObject = from.mozSrcObject;\n\t  };\n\t\n\t} else if (navigator.webkitGetUserMedia) {\n\t  console.log('This appears to be Chrome');\n\t\n\t  webrtcDetectedBrowser = 'chrome';\n\t  // Temporary fix until crbug/374263 is fixed.\n\t  // Setting Chrome version to 999, if version is unavailable.\n\t  var result = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n\t  if (result !== null) {\n\t    webrtcDetectedVersion = parseInt(result[2], 10);\n\t  } else {\n\t    webrtcDetectedVersion = 999;\n\t  }\n\t\n\t  // Creates iceServer from the url for Chrome M33 and earlier.\n\t  window.createIceServer = function(url, username, password) {\n\t    var iceServer = null;\n\t    var urlParts = url.split(':');\n\t    if (urlParts[0].indexOf('stun') === 0) {\n\t      // Create iceServer with stun url.\n\t      iceServer = {\n\t        'url': url\n\t      };\n\t    } else if (urlParts[0].indexOf('turn') === 0) {\n\t      // Chrome M28 & above uses below TURN format.\n\t      iceServer = {\n\t        'url': url,\n\t        'credential': password,\n\t        'username': username\n\t      };\n\t    }\n\t    return iceServer;\n\t  };\n\t\n\t  // Creates iceServers from the urls for Chrome M34 and above.\n\t  window.createIceServers = function(urls, username, password) {\n\t    var iceServers = [];\n\t    if (webrtcDetectedVersion >= 34) {\n\t      // .urls is supported since Chrome M34.\n\t      iceServers = {\n\t        'urls': urls,\n\t        'credential': password,\n\t        'username': username\n\t      };\n\t    } else {\n\t      for (var i = 0; i < urls.length; i++) {\n\t        var iceServer =\n\t          window.createIceServer(urls[i], username, password);\n\t        if (iceServer !== null) {\n\t          iceServers.push(iceServer);\n\t        }\n\t      }\n\t    }\n\t    return iceServers;\n\t  };\n\t\n\t  // The RTCPeerConnection object.\n\t  RTCPeerConnection = function(pcConfig, pcConstraints) {\n\t    // .urls is supported since Chrome M34.\n\t    if (webrtcDetectedVersion < 34) {\n\t      maybeFixConfiguration(pcConfig);\n\t    }\n\t    return new webkitRTCPeerConnection(pcConfig, pcConstraints);\n\t  };\n\t\n\t  // Get UserMedia (only difference is the prefix).\n\t  // Code from Adam Barth.\n\t  getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n\t  navigator.getUserMedia = getUserMedia;\n\t\n\t  // Attach a media stream to an element.\n\t  attachMediaStream = function(element, stream) {\n\t    if (typeof element.srcObject !== 'undefined') {\n\t      element.srcObject = stream;\n\t    } else if (typeof element.mozSrcObject !== 'undefined') {\n\t      element.mozSrcObject = stream;\n\t    } else if (typeof element.src !== 'undefined') {\n\t      element.src = URL.createObjectURL(stream);\n\t    } else {\n\t      console.log('Error attaching stream to element.');\n\t    }\n\t  };\n\t\n\t  reattachMediaStream = function(to, from) {\n\t    to.src = from.src;\n\t  };\n\t} else {\n\t  console.log('Browser does not appear to be WebRTC-capable');\n\t}\n\t\n\t\n\twindow.RTCPeerConnection = RTCPeerConnection;\n\twindow.getUserMedia = getUserMedia;\n\twindow.attachMediaStream = attachMediaStream;\n\twindow.reattachMediaStream = reattachMediaStream;\n\twindow.webrtcDetectedBrowser = webrtcDetectedBrowser;\n\twindow.webrtcDetectedVersion = webrtcDetectedVersion;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar log = __webpack_require__(2);\n\tvar respokeClass = __webpack_require__(5);\n\t\n\t/**\n\t * Higher order function to wrap a passed in function. The returned function will only execute\n\t * the passed in function the first time it is called, then be a no-op any subsequent tries.\n\t *\n\t * @private\n\t */\n\tvar callOnce = function (func) {\n\t    \"use strict\";\n\t    return (function () {\n\t        var called = false;\n\t        return function () {\n\t            if (!called) {\n\t                func.apply(null, arguments);\n\t                called = true;\n\t            }\n\t        };\n\t    })();\n\t};\n\t\n\t/**\n\t * A generic class for emitting and listening to events. This is used internally by respoke.js\n\t * to provide evented behavior. You can add custom events and inherit your own objects from\n\t * the EventEmitter.\n\t *\n\t * ```\n\t * // Adding a custom event to a respoke.Client instance\n\t * client.listen('my-event', function (evt) { });\n\t * client.fire('my-event', { name: 'my-event', asdf: 'jkl' });\n\t * ```\n\t *\n\t * ```\n\t * // Custom EventEmitter\n\t * var MyCustomEmitter = respoke.EventEmitter();\n\t * var emitterInstance = MyCustomEmitter();\n\t * emitterInstance.fire('hi', { name: 'hi', message: 'hello' });\n\t * emitterInstance.listen('hi', function (evt) { });\n\t * ```\n\t *\n\t * @class respoke.EventEmitter\n\t * @inherits respoke.Class\n\t * @constructor\n\t * @param {object} params\n\t * @param {string} params.instanceId\n\t * @returns {respoke.EventEmitter}\n\t */\n\tvar EventEmitter = module.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var that = respokeClass(params);\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.EventEmitter\n\t     * @name className\n\t     * @type {string}\n\t     * @private\n\t     */\n\t    that.className = 'respoke.EventEmitter';\n\t\n\t    /**\n\t     * @memberof! respoke.EventEmitter\n\t     * @name eventList\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var eventList = {};\n\t\n\t    /**\n\t     * Add a listener that will only be called once to an object.  This method adds the given listener to the given\n\t     * event in the case that the same\n\t     * listener is not already registered to this event and the listener is a function.  The third argument 'isInternal'\n\t     * is used only internally by the library to indicate that this listener is a library-used listener and should not\n\t     * count when we are trying to determine if an event has listeners placed by the developer.\n\t     *\n\t     *     client.once('connect', function (evt) {\n\t     *         console.log(\"This is the first time we connected.\");\n\t     *     });\n\t     *\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.listen\n\t     * @param {string} eventType - A developer-specified string identifying the event.\n\t     * @param {respoke.EventEmitter.eventListener} listener - A function to call when the event is fire.\n\t     * @param {boolean} [isInternal] - A flag to indicate this listener was added by the library. This parameter should\n\t     * not be used by developers who are using the library, only by developers who are working on the library itself.\n\t     */\n\t    that.once = function (eventType, listener, isInternal) {\n\t        var string = listener.toString();\n\t        listener = callOnce(listener);\n\t        listener.toString = function () { return string; };\n\t        listener.once = true;\n\t        that.listen(eventType, listener, isInternal);\n\t    };\n\t\n\t    /**\n\t     * Add a `listener` function to an object.\n\t     *\n\t     * This method adds the `listener` to the event `eventName`.\n\t     *\n\t     * If an identical listener already registered to this event, it will **not** be added.\n\t     *\n\t     * ##### Example of adding an event listener.\n\t     *\n\t     *     client.listen('connect', function (evt) {\n\t     *         console.log(\"We've connected!\", evt);\n\t     *     });\n\t     *\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.listen\n\t     * @param {string} eventType - The name of the event.\n\t     * @param {respoke.EventEmitter.eventListener} listener - A function to call when the event is\n\t     * fired.\n\t     * @arg {boolean} isInternal - Internal use only. A flag to indicate this listener was\n\t     * added by the library. This parameter should not be used by developers who are using\n\t     * the library, only by developers who are working on the library itself.\n\t     */\n\t    that.listen = function (eventType, listener, isInternal) {\n\t        if (listener === undefined) {\n\t            return;\n\t        }\n\t        var invalidEventType = typeof eventType !== 'string' || !eventType;\n\t        var invalidListener = typeof listener !== 'function';\n\t        if (invalidEventType || invalidListener) {\n\t            log.error(\"Invalid request to add event listener to\", eventType, listener);\n\t            return;\n\t        }\n\t\n\t        eventList[eventType] = eventList[eventType] || [];\n\t        listener.isInternal = !!isInternal; // boolify\n\t\n\t        var toString = function (fn) {\n\t            return fn.toString();\n\t        };\n\t        var isNotAlreadyAdded = eventList[eventType].map(toString).indexOf(listener.toString()) === -1;\n\t\n\t        if (isNotAlreadyAdded) {\n\t            eventList[eventType].push(listener);\n\t        } else {\n\t            log.warn(\"Not adding duplicate listener to\", eventType, listener);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Remove a listener from an object. If no eventType is specified, all eventTypes will be\n\t     * cleared. If an eventType is specified but no listener is specified, all listeners will be\n\t     * removed from the specified eventType.  If a listener is also specified, only that listener\n\t     * will be removed.\n\t     *\n\t     *     client.ignore('connect', connectHandler);\n\t     *\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.ignore\n\t     * @param {string} [eventType] - An optional developer-specified string identifying the event.\n\t     * @param {function} [listener] - An optional function to remove from the specified event.\n\t     */\n\t    that.ignore = function (eventType, listener) {\n\t        // Remove all events from this object\n\t        if (eventType === undefined) {\n\t            eventList = {};\n\t            return;\n\t        }\n\t\n\t        // Remove all listeners from this event.\n\t        if (listener === undefined || !eventList[eventType]) {\n\t            eventList[eventType] = [];\n\t            return;\n\t        }\n\t\n\t        // Remove only one listener from this event.\n\t        for (var i = eventList[eventType].length - 1; i >= 0; i -= 1) {\n\t            if (listener === eventList[eventType][i]) {\n\t                eventList[eventType].splice(i, 1);\n\t                return;\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Trigger an event on an object. All listeners for the specified eventType will be called.\n\t     * Listeners will be bound to the object ('this' will refer to the object), and additional\n\t     * arguments to fire() will be passed into each listener.\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.fire\n\t     * @param {string} eventType - A developer-specified string identifying the event to fire.\n\t     * @param {string|number|object|array} evt - Any number of optional parameters to be passed to\n\t     * the listener\n\t     * @private\n\t     */\n\t    that.fire = function (eventType, evt) {\n\t        var args = null;\n\t        var count = 0;\n\t        var toRemove = [];\n\t        var i;\n\t\n\t        evt = evt || {};\n\t        evt.name = eventType;\n\t        evt.target = that;\n\t\n\t        if (!eventType) {\n\t            return;\n\t        }\n\t\n\t        if (!eventList[eventType]) {\n\t            log.debug(\"fired \" + that.className + \"#\" + eventType + \" 0 listeners called with params\", evt);\n\t            return;\n\t        }\n\t\n\t        for (i = 0; i < eventList[eventType].length; i += 1) {\n\t            var listener = eventList[eventType][i];\n\t            if (typeof listener === 'function') {\n\t                setTimeout(listenerBuilder(listener, evt, eventType));\n\t\n\t                count += 1;\n\t                if (listener.once === true) {\n\t                    toRemove.push(i);\n\t                }\n\t            }\n\t        }\n\t\n\t        for (i = (toRemove.length - 1); i >= 0; i -= 1) {\n\t            eventList[eventType].splice(toRemove[i], 1);\n\t        }\n\t\n\t        log.debug(\"fired \" + that.className + \"#\" + eventType + \" \" + count + \" listeners called with params\", evt);\n\t    };\n\t\n\t    function listenerBuilder(listener, evt, eventType) {\n\t        return function () {\n\t            try {\n\t                listener.call(that, evt);\n\t            } catch (e) {\n\t                log.error('Error in ' + that.className + \"#\" + eventType, e.message, e.stack);\n\t            }\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Determine if an object has had any listeners registered for a given event outside the library. This method\n\t     * checks for the isInternal flag on each listener and doesn't count it toward an event being listened to. This\n\t     * method is used in the library to handle situations where an action is needed if an event won't be acted on.\n\t     * For instance, if a call comes in for the logged-in user, but the developer isn't listening to\n\t     * {respoke.Client#call}, we'll need to reject the call immediately.\n\t     *\n\t     *     if (client.hasListeners('call')) {\n\t     *         // already handled!\n\t     *     }\n\t     *\n\t     * @memberof! respoke.EventEmitter\n\t     * @method respoke.EventEmitter.hasListeners\n\t     * @param {string} eventType - The name of the event\n\t     * @returns {boolean} Whether this event has any listeners that are external to this library.\n\t     */\n\t    that.hasListeners = function (eventType) {\n\t        if (eventType === undefined) {\n\t            throw new Error(\"Missing required parameter event type.\");\n\t        }\n\t\n\t        if (!eventList[eventType]) {\n\t            return false;\n\t        }\n\t\n\t        return !eventList[eventType].every(function eachListener(listener) {\n\t            return listener.isInternal;\n\t        });\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.EventEmitter\n\t/**\n\t * @callback respoke.EventEmitter.eventListener\n\t * @param {respoke.Event} evt\n\t */\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\t/**\n\t * Empty base class. Use params.that (if exists) for the base object, but delete it from the instance.\n\t * Copy all params that were passed in onto the base object. Add the class name.\n\t * @class respoke.Class\n\t * @private\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var that = params.that || {};\n\t\n\t    that.className = 'respoke.Class';\n\t    delete params.that;\n\t    delete that.client;\n\t\n\t    Object.keys(params).forEach(function copyParam(name) {\n\t        that[name] = params[name];\n\t    });\n\t\n\t    return that;\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*! Socket.IO.js build:0.9.17, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\n\t\n\tvar io = ( false ? {} : module.exports);\n\t(function() {\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, global) {\n\t\n\t  /**\n\t   * IO namespace.\n\t   *\n\t   * @namespace\n\t   */\n\t\n\t  var io = exports;\n\t\n\t  /**\n\t   * Socket.IO version\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  io.version = '0.9.17';\n\t\n\t  /**\n\t   * Protocol implemented.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  io.protocol = 1;\n\t\n\t  /**\n\t   * Available transports, these will be populated with the available transports\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  io.transports = [];\n\t\n\t  /**\n\t   * Keep track of jsonp callbacks.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.j = [];\n\t\n\t  /**\n\t   * Keep track of our io.Sockets\n\t   *\n\t   * @api private\n\t   */\n\t  io.sockets = {};\n\t\n\t\n\t  /**\n\t   * Manages connections to hosts.\n\t   *\n\t   * @param {String} uri\n\t   * @Param {Boolean} force creation of new socket (defaults to false)\n\t   * @api public\n\t   */\n\t\n\t  io.connect = function (host, details) {\n\t    var uri = io.util.parseUri(host)\n\t      , uuri\n\t      , socket;\n\t\n\t    if (global && global.location) {\n\t      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\n\t      uri.host = uri.host || (global.document\n\t        ? global.document.domain : global.location.hostname);\n\t      uri.port = uri.port || global.location.port;\n\t    }\n\t\n\t    uuri = io.util.uniqueUri(uri);\n\t\n\t    var options = {\n\t        host: uri.host\n\t      , secure: 'https' == uri.protocol\n\t      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\n\t      , query: uri.query || ''\n\t    };\n\t\n\t    io.util.merge(options, details);\n\t\n\t    if (options['force new connection'] || !io.sockets[uuri]) {\n\t      socket = new io.Socket(options);\n\t    }\n\t\n\t    if (!options['force new connection'] && socket) {\n\t      io.sockets[uuri] = socket;\n\t    }\n\t\n\t    socket = socket || io.sockets[uuri];\n\t\n\t    // if path is different from '' or /\n\t    return socket.of(uri.path.length > 1 ? uri.path : '');\n\t  };\n\t\n\t})( true ? module.exports : (this.io = {}), this);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, global) {\n\t\n\t  /**\n\t   * Utilities namespace.\n\t   *\n\t   * @namespace\n\t   */\n\t\n\t  var util = exports.util = {};\n\t\n\t  /**\n\t   * Parses an URI\n\t   *\n\t   * @author Steven Levithan <stevenlevithan.com> (MIT license)\n\t   * @api public\n\t   */\n\t\n\t  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\t  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\n\t               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\n\t               'anchor'];\n\t\n\t  util.parseUri = function (str) {\n\t    var m = re.exec(str || '')\n\t      , uri = {}\n\t      , i = 14;\n\t\n\t    while (i--) {\n\t      uri[parts[i]] = m[i] || '';\n\t    }\n\t\n\t    return uri;\n\t  };\n\t\n\t  /**\n\t   * Produces a unique url that identifies a Socket.IO connection.\n\t   *\n\t   * @param {Object} uri\n\t   * @api public\n\t   */\n\t\n\t  util.uniqueUri = function (uri) {\n\t    var protocol = uri.protocol\n\t      , host = uri.host\n\t      , port = uri.port;\n\t\n\t    if ('document' in global) {\n\t      host = host || document.domain;\n\t      port = port || (protocol == 'https'\n\t        && document.location.protocol !== 'https:' ? 443 : document.location.port);\n\t    } else {\n\t      host = host || 'localhost';\n\t\n\t      if (!port && protocol == 'https') {\n\t        port = 443;\n\t      }\n\t    }\n\t\n\t    return (protocol || 'http') + '://' + host + ':' + (port || 80);\n\t  };\n\t\n\t  /**\n\t   * Mergest 2 query strings in to once unique query string\n\t   *\n\t   * @param {String} base\n\t   * @param {String} addition\n\t   * @api public\n\t   */\n\t\n\t  util.query = function (base, addition) {\n\t    var query = util.chunkQuery(base || '')\n\t      , components = [];\n\t\n\t    util.merge(query, util.chunkQuery(addition || ''));\n\t    for (var part in query) {\n\t      if (query.hasOwnProperty(part)) {\n\t        components.push(part + '=' + query[part]);\n\t      }\n\t    }\n\t\n\t    return components.length ? '?' + components.join('&') : '';\n\t  };\n\t\n\t  /**\n\t   * Transforms a querystring in to an object\n\t   *\n\t   * @param {String} qs\n\t   * @api public\n\t   */\n\t\n\t  util.chunkQuery = function (qs) {\n\t    var query = {}\n\t      , params = qs.split('&')\n\t      , i = 0\n\t      , l = params.length\n\t      , kv;\n\t\n\t    for (; i < l; ++i) {\n\t      kv = params[i].split('=');\n\t      if (kv[0]) {\n\t        query[kv[0]] = kv[1];\n\t      }\n\t    }\n\t\n\t    return query;\n\t  };\n\t\n\t  /**\n\t   * Executes the given function when the page is loaded.\n\t   *\n\t   *     io.util.load(function () { console.log('page loaded'); });\n\t   *\n\t   * @param {Function} fn\n\t   * @api public\n\t   */\n\t\n\t  var pageLoaded = false;\n\t\n\t  util.load = function (fn) {\n\t    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\n\t      return fn();\n\t    }\n\t\n\t    util.on(global, 'load', fn, false);\n\t  };\n\t\n\t  /**\n\t   * Adds an event.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  util.on = function (element, event, fn, capture) {\n\t    if (element.attachEvent) {\n\t      element.attachEvent('on' + event, fn);\n\t    } else if (element.addEventListener) {\n\t      element.addEventListener(event, fn, capture);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\n\t   *\n\t   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\n\t   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\n\t   * @api private\n\t   */\n\t\n\t  util.request = function (xdomain) {\n\t\n\t    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {\n\t      return new XDomainRequest();\n\t    }\n\t\n\t    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\n\t      return new XMLHttpRequest();\n\t    }\n\t\n\t    if (!xdomain) {\n\t      try {\n\t        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');\n\t      } catch(e) { }\n\t    }\n\t\n\t    return null;\n\t  };\n\t\n\t  /**\n\t   * XHR based transport constructor.\n\t   *\n\t   * @constructor\n\t   * @api public\n\t   */\n\t\n\t  /**\n\t   * Change the internal pageLoaded value.\n\t   */\n\t\n\t  if ('undefined' != typeof window) {\n\t    util.load(function () {\n\t      pageLoaded = true;\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Defers a function to ensure a spinner is not displayed by the browser\n\t   *\n\t   * @param {Function} fn\n\t   * @api public\n\t   */\n\t\n\t  util.defer = function (fn) {\n\t    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\n\t      return fn();\n\t    }\n\t\n\t    util.load(function () {\n\t      setTimeout(fn, 100);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Merges two objects.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.merge = function merge (target, additional, deep, lastseen) {\n\t    var seen = lastseen || []\n\t      , depth = typeof deep == 'undefined' ? 2 : deep\n\t      , prop;\n\t\n\t    for (prop in additional) {\n\t      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\n\t        if (typeof target[prop] !== 'object' || !depth) {\n\t          target[prop] = additional[prop];\n\t          seen.push(additional[prop]);\n\t        } else {\n\t          util.merge(target[prop], additional[prop], depth - 1, seen);\n\t        }\n\t      }\n\t    }\n\t\n\t    return target;\n\t  };\n\t\n\t  /**\n\t   * Merges prototypes from objects\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.mixin = function (ctor, ctor2) {\n\t    util.merge(ctor.prototype, ctor2.prototype);\n\t  };\n\t\n\t  /**\n\t   * Shortcut for prototypical and static inheritance.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  util.inherit = function (ctor, ctor2) {\n\t    function f() {};\n\t    f.prototype = ctor2.prototype;\n\t    ctor.prototype = new f;\n\t  };\n\t\n\t  /**\n\t   * Checks if the given object is an Array.\n\t   *\n\t   *     io.util.isArray([]); // true\n\t   *     io.util.isArray({}); // false\n\t   *\n\t   * @param Object obj\n\t   * @api public\n\t   */\n\t\n\t  util.isArray = Array.isArray || function (obj) {\n\t    return Object.prototype.toString.call(obj) === '[object Array]';\n\t  };\n\t\n\t  /**\n\t   * Intersects values of two arrays into a third\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.intersect = function (arr, arr2) {\n\t    var ret = []\n\t      , longest = arr.length > arr2.length ? arr : arr2\n\t      , shortest = arr.length > arr2.length ? arr2 : arr;\n\t\n\t    for (var i = 0, l = shortest.length; i < l; i++) {\n\t      if (~util.indexOf(longest, shortest[i]))\n\t        ret.push(shortest[i]);\n\t    }\n\t\n\t    return ret;\n\t  };\n\t\n\t  /**\n\t   * Array indexOf compatibility.\n\t   *\n\t   * @see bit.ly/a5Dxa2\n\t   * @api public\n\t   */\n\t\n\t  util.indexOf = function (arr, o, i) {\n\t\n\t    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;\n\t         i < j && arr[i] !== o; i++) {}\n\t\n\t    return j <= i ? -1 : i;\n\t  };\n\t\n\t  /**\n\t   * Converts enumerables to array.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.toArray = function (enu) {\n\t    var arr = [];\n\t\n\t    for (var i = 0, l = enu.length; i < l; i++)\n\t      arr.push(enu[i]);\n\t\n\t    return arr;\n\t  };\n\t\n\t  /**\n\t   * UA / engines detection namespace.\n\t   *\n\t   * @namespace\n\t   */\n\t\n\t  util.ua = {};\n\t\n\t  /**\n\t   * Whether the UA supports CORS for XHR.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\n\t    try {\n\t      var a = new XMLHttpRequest();\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t\n\t    return a.withCredentials != undefined;\n\t  })();\n\t\n\t  /**\n\t   * Detect webkit.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.ua.webkit = 'undefined' != typeof navigator\n\t    && /webkit/i.test(navigator.userAgent);\n\t\n\t   /**\n\t   * Detect iPad/iPhone/iPod.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  util.ua.iDevice = 'undefined' != typeof navigator\n\t      && /iPad|iPhone|iPod/i.test(navigator.userAgent);\n\t\n\t})('undefined' != typeof io ? io : module.exports, this);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.EventEmitter = EventEmitter;\n\t\n\t  /**\n\t   * Event emitter constructor.\n\t   *\n\t   * @api public.\n\t   */\n\t\n\t  function EventEmitter () {};\n\t\n\t  /**\n\t   * Adds a listener\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.on = function (name, fn) {\n\t    if (!this.$events) {\n\t      this.$events = {};\n\t    }\n\t\n\t    if (!this.$events[name]) {\n\t      this.$events[name] = fn;\n\t    } else if (io.util.isArray(this.$events[name])) {\n\t      this.$events[name].push(fn);\n\t    } else {\n\t      this.$events[name] = [this.$events[name], fn];\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t  /**\n\t   * Adds a volatile listener.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.once = function (name, fn) {\n\t    var self = this;\n\t\n\t    function on () {\n\t      self.removeListener(name, on);\n\t      fn.apply(this, arguments);\n\t    };\n\t\n\t    on.listener = fn;\n\t    this.on(name, on);\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Removes a listener.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.removeListener = function (name, fn) {\n\t    if (this.$events && this.$events[name]) {\n\t      var list = this.$events[name];\n\t\n\t      if (io.util.isArray(list)) {\n\t        var pos = -1;\n\t\n\t        for (var i = 0, l = list.length; i < l; i++) {\n\t          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n\t            pos = i;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (pos < 0) {\n\t          return this;\n\t        }\n\t\n\t        list.splice(pos, 1);\n\t\n\t        if (!list.length) {\n\t          delete this.$events[name];\n\t        }\n\t      } else if (list === fn || (list.listener && list.listener === fn)) {\n\t        delete this.$events[name];\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Removes all listeners for an event.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.removeAllListeners = function (name) {\n\t    if (name === undefined) {\n\t      this.$events = {};\n\t      return this;\n\t    }\n\t\n\t    if (this.$events && this.$events[name]) {\n\t      this.$events[name] = null;\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Gets all listeners for a certain event.\n\t   *\n\t   * @api publci\n\t   */\n\t\n\t  EventEmitter.prototype.listeners = function (name) {\n\t    if (!this.$events) {\n\t      this.$events = {};\n\t    }\n\t\n\t    if (!this.$events[name]) {\n\t      this.$events[name] = [];\n\t    }\n\t\n\t    if (!io.util.isArray(this.$events[name])) {\n\t      this.$events[name] = [this.$events[name]];\n\t    }\n\t\n\t    return this.$events[name];\n\t  };\n\t\n\t  /**\n\t   * Emits an event.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  EventEmitter.prototype.emit = function (name) {\n\t    if (!this.$events) {\n\t      return false;\n\t    }\n\t\n\t    var handler = this.$events[name];\n\t\n\t    if (!handler) {\n\t      return false;\n\t    }\n\t\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t\n\t    if ('function' == typeof handler) {\n\t      handler.apply(this, args);\n\t    } else if (io.util.isArray(handler)) {\n\t      var listeners = handler.slice();\n\t\n\t      for (var i = 0, l = listeners.length; i < l; i++) {\n\t        listeners[i].apply(this, args);\n\t      }\n\t    } else {\n\t      return false;\n\t    }\n\t\n\t    return true;\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * Based on JSON2 (http://www.JSON.org/js.html).\n\t */\n\t\n\t(function (exports, nativeJSON) {\n\t  \"use strict\";\n\t\n\t  // use native JSON if it's available\n\t  if (nativeJSON && nativeJSON.parse){\n\t    return exports.JSON = {\n\t      parse: nativeJSON.parse\n\t    , stringify: nativeJSON.stringify\n\t    };\n\t  }\n\t\n\t  var JSON = exports.JSON = {};\n\t\n\t  function f(n) {\n\t      // Format integers to have at least two digits.\n\t      return n < 10 ? '0' + n : n;\n\t  }\n\t\n\t  function date(d, key) {\n\t    return isFinite(d.valueOf()) ?\n\t        d.getUTCFullYear()     + '-' +\n\t        f(d.getUTCMonth() + 1) + '-' +\n\t        f(d.getUTCDate())      + 'T' +\n\t        f(d.getUTCHours())     + ':' +\n\t        f(d.getUTCMinutes())   + ':' +\n\t        f(d.getUTCSeconds())   + 'Z' : null;\n\t  };\n\t\n\t  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t      gap,\n\t      indent,\n\t      meta = {    // table of character substitutions\n\t          '\\b': '\\\\b',\n\t          '\\t': '\\\\t',\n\t          '\\n': '\\\\n',\n\t          '\\f': '\\\\f',\n\t          '\\r': '\\\\r',\n\t          '\"' : '\\\\\"',\n\t          '\\\\': '\\\\\\\\'\n\t      },\n\t      rep;\n\t\n\t\n\t  function quote(string) {\n\t\n\t// If the string contains no control characters, no quote characters, and no\n\t// backslash characters, then we can safely slap some quotes around it.\n\t// Otherwise we must also replace the offending characters with safe escape\n\t// sequences.\n\t\n\t      escapable.lastIndex = 0;\n\t      return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n\t          var c = meta[a];\n\t          return typeof c === 'string' ? c :\n\t              '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t      }) + '\"' : '\"' + string + '\"';\n\t  }\n\t\n\t\n\t  function str(key, holder) {\n\t\n\t// Produce a string from holder[key].\n\t\n\t      var i,          // The loop counter.\n\t          k,          // The member key.\n\t          v,          // The member value.\n\t          length,\n\t          mind = gap,\n\t          partial,\n\t          value = holder[key];\n\t\n\t// If the value has a toJSON method, call it to obtain a replacement value.\n\t\n\t      if (value instanceof Date) {\n\t          value = date(key);\n\t      }\n\t\n\t// If we were called with a replacer function, then call the replacer to\n\t// obtain a replacement value.\n\t\n\t      if (typeof rep === 'function') {\n\t          value = rep.call(holder, key, value);\n\t      }\n\t\n\t// What happens next depends on the value's type.\n\t\n\t      switch (typeof value) {\n\t      case 'string':\n\t          return quote(value);\n\t\n\t      case 'number':\n\t\n\t// JSON numbers must be finite. Encode non-finite numbers as null.\n\t\n\t          return isFinite(value) ? String(value) : 'null';\n\t\n\t      case 'boolean':\n\t      case 'null':\n\t\n\t// If the value is a boolean or null, convert it to a string. Note:\n\t// typeof null does not produce 'null'. The case is included here in\n\t// the remote chance that this gets fixed someday.\n\t\n\t          return String(value);\n\t\n\t// If the type is 'object', we might be dealing with an object or an array or\n\t// null.\n\t\n\t      case 'object':\n\t\n\t// Due to a specification blunder in ECMAScript, typeof null is 'object',\n\t// so watch out for that case.\n\t\n\t          if (!value) {\n\t              return 'null';\n\t          }\n\t\n\t// Make an array to hold the partial results of stringifying this object value.\n\t\n\t          gap += indent;\n\t          partial = [];\n\t\n\t// Is the value an array?\n\t\n\t          if (Object.prototype.toString.apply(value) === '[object Array]') {\n\t\n\t// The value is an array. Stringify every element. Use null as a placeholder\n\t// for non-JSON values.\n\t\n\t              length = value.length;\n\t              for (i = 0; i < length; i += 1) {\n\t                  partial[i] = str(i, value) || 'null';\n\t              }\n\t\n\t// Join all of the elements together, separated with commas, and wrap them in\n\t// brackets.\n\t\n\t              v = partial.length === 0 ? '[]' : gap ?\n\t                  '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n\t                  '[' + partial.join(',') + ']';\n\t              gap = mind;\n\t              return v;\n\t          }\n\t\n\t// If the replacer is an array, use it to select the members to be stringified.\n\t\n\t          if (rep && typeof rep === 'object') {\n\t              length = rep.length;\n\t              for (i = 0; i < length; i += 1) {\n\t                  if (typeof rep[i] === 'string') {\n\t                      k = rep[i];\n\t                      v = str(k, value);\n\t                      if (v) {\n\t                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                      }\n\t                  }\n\t              }\n\t          } else {\n\t\n\t// Otherwise, iterate through all of the keys in the object.\n\t\n\t              for (k in value) {\n\t                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n\t                      v = str(k, value);\n\t                      if (v) {\n\t                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                      }\n\t                  }\n\t              }\n\t          }\n\t\n\t// Join all of the member texts together, separated with commas,\n\t// and wrap them in braces.\n\t\n\t          v = partial.length === 0 ? '{}' : gap ?\n\t              '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n\t              '{' + partial.join(',') + '}';\n\t          gap = mind;\n\t          return v;\n\t      }\n\t  }\n\t\n\t// If the JSON object does not yet have a stringify method, give it one.\n\t\n\t  JSON.stringify = function (value, replacer, space) {\n\t\n\t// The stringify method takes a value and an optional replacer, and an optional\n\t// space parameter, and returns a JSON text. The replacer can be a function\n\t// that can replace values, or an array of strings that will select the keys.\n\t// A default replacer method can be provided. Use of the space parameter can\n\t// produce text that is more easily readable.\n\t\n\t      var i;\n\t      gap = '';\n\t      indent = '';\n\t\n\t// If the space parameter is a number, make an indent string containing that\n\t// many spaces.\n\t\n\t      if (typeof space === 'number') {\n\t          for (i = 0; i < space; i += 1) {\n\t              indent += ' ';\n\t          }\n\t\n\t// If the space parameter is a string, it will be used as the indent string.\n\t\n\t      } else if (typeof space === 'string') {\n\t          indent = space;\n\t      }\n\t\n\t// If there is a replacer, it must be a function or an array.\n\t// Otherwise, throw an error.\n\t\n\t      rep = replacer;\n\t      if (replacer && typeof replacer !== 'function' &&\n\t              (typeof replacer !== 'object' ||\n\t              typeof replacer.length !== 'number')) {\n\t          throw new Error('JSON.stringify');\n\t      }\n\t\n\t// Make a fake root object containing our value under the key of ''.\n\t// Return the result of stringifying the value.\n\t\n\t      return str('', {'': value});\n\t  };\n\t\n\t// If the JSON object does not yet have a parse method, give it one.\n\t\n\t  JSON.parse = function (text, reviver) {\n\t  // The parse method takes a text and an optional reviver function, and returns\n\t  // a JavaScript value if the text is a valid JSON text.\n\t\n\t      var j;\n\t\n\t      function walk(holder, key) {\n\t\n\t  // The walk method is used to recursively walk the resulting structure so\n\t  // that modifications can be made.\n\t\n\t          var k, v, value = holder[key];\n\t          if (value && typeof value === 'object') {\n\t              for (k in value) {\n\t                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n\t                      v = walk(value, k);\n\t                      if (v !== undefined) {\n\t                          value[k] = v;\n\t                      } else {\n\t                          delete value[k];\n\t                      }\n\t                  }\n\t              }\n\t          }\n\t          return reviver.call(holder, key, value);\n\t      }\n\t\n\t\n\t  // Parsing happens in four stages. In the first stage, we replace certain\n\t  // Unicode characters with escape sequences. JavaScript handles many characters\n\t  // incorrectly, either silently deleting them, or treating them as line endings.\n\t\n\t      text = String(text);\n\t      cx.lastIndex = 0;\n\t      if (cx.test(text)) {\n\t          text = text.replace(cx, function (a) {\n\t              return '\\\\u' +\n\t                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t          });\n\t      }\n\t\n\t  // In the second stage, we run the text against regular expressions that look\n\t  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n\t  // because they can cause invocation, and '=' because it can cause mutation.\n\t  // But just to be safe, we want to reject all unexpected forms.\n\t\n\t  // We split the second stage into 4 regexp operations in order to work around\n\t  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n\t  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n\t  // replace all simple value tokens with ']' characters. Third, we delete all\n\t  // open brackets that follow a colon or comma or that begin the text. Finally,\n\t  // we look to see that the remaining characters are only whitespace or ']' or\n\t  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\t\n\t      if (/^[\\],:{}\\s]*$/\n\t              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n\t                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n\t                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\t\n\t  // In the third stage we use the eval function to compile the text into a\n\t  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n\t  // in JavaScript: it can begin a block or an object literal. We wrap the text\n\t  // in parens to eliminate the ambiguity.\n\t\n\t          j = eval('(' + text + ')');\n\t\n\t  // In the optional fourth stage, we recursively walk the new structure, passing\n\t  // each name/value pair to a reviver function for possible transformation.\n\t\n\t          return typeof reviver === 'function' ?\n\t              walk({'': j}, '') : j;\n\t      }\n\t\n\t  // If the text is not JSON parseable, then a SyntaxError is thrown.\n\t\n\t      throw new SyntaxError('JSON.parse');\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , typeof JSON !== 'undefined' ? JSON : undefined\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Parser namespace.\n\t   *\n\t   * @namespace\n\t   */\n\t\n\t  var parser = exports.parser = {};\n\t\n\t  /**\n\t   * Packet types.\n\t   */\n\t\n\t  var packets = parser.packets = [\n\t      'disconnect'\n\t    , 'connect'\n\t    , 'heartbeat'\n\t    , 'message'\n\t    , 'json'\n\t    , 'event'\n\t    , 'ack'\n\t    , 'error'\n\t    , 'noop'\n\t  ];\n\t\n\t  /**\n\t   * Errors reasons.\n\t   */\n\t\n\t  var reasons = parser.reasons = [\n\t      'transport not supported'\n\t    , 'client not handshaken'\n\t    , 'unauthorized'\n\t  ];\n\t\n\t  /**\n\t   * Errors advice.\n\t   */\n\t\n\t  var advice = parser.advice = [\n\t      'reconnect'\n\t  ];\n\t\n\t  /**\n\t   * Shortcuts.\n\t   */\n\t\n\t  var JSON = io.JSON\n\t    , indexOf = io.util.indexOf;\n\t\n\t  /**\n\t   * Encodes a packet.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  parser.encodePacket = function (packet) {\n\t    var type = indexOf(packets, packet.type)\n\t      , id = packet.id || ''\n\t      , endpoint = packet.endpoint || ''\n\t      , ack = packet.ack\n\t      , data = null;\n\t\n\t    switch (packet.type) {\n\t      case 'error':\n\t        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\n\t          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\n\t\n\t        if (reason !== '' || adv !== '')\n\t          data = reason + (adv !== '' ? ('+' + adv) : '');\n\t\n\t        break;\n\t\n\t      case 'message':\n\t        if (packet.data !== '')\n\t          data = packet.data;\n\t        break;\n\t\n\t      case 'event':\n\t        var ev = { name: packet.name };\n\t\n\t        if (packet.args && packet.args.length) {\n\t          ev.args = packet.args;\n\t        }\n\t\n\t        data = JSON.stringify(ev);\n\t        break;\n\t\n\t      case 'json':\n\t        data = JSON.stringify(packet.data);\n\t        break;\n\t\n\t      case 'connect':\n\t        if (packet.qs)\n\t          data = packet.qs;\n\t        break;\n\t\n\t      case 'ack':\n\t        data = packet.ackId\n\t          + (packet.args && packet.args.length\n\t              ? '+' + JSON.stringify(packet.args) : '');\n\t        break;\n\t    }\n\t\n\t    // construct packet with required fragments\n\t    var encoded = [\n\t        type\n\t      , id + (ack == 'data' ? '+' : '')\n\t      , endpoint\n\t    ];\n\t\n\t    // data fragment is optional\n\t    if (data !== null && data !== undefined)\n\t      encoded.push(data);\n\t\n\t    return encoded.join(':');\n\t  };\n\t\n\t  /**\n\t   * Encodes multiple messages (payload).\n\t   *\n\t   * @param {Array} messages\n\t   * @api private\n\t   */\n\t\n\t  parser.encodePayload = function (packets) {\n\t    var decoded = '';\n\t\n\t    if (packets.length == 1)\n\t      return packets[0];\n\t\n\t    for (var i = 0, l = packets.length; i < l; i++) {\n\t      var packet = packets[i];\n\t      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\n\t    }\n\t\n\t    return decoded;\n\t  };\n\t\n\t  /**\n\t   * Decodes a packet\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\n\t\n\t  parser.decodePacket = function (data) {\n\t    var pieces = data.match(regexp);\n\t\n\t    if (!pieces) return {};\n\t\n\t    var id = pieces[2] || ''\n\t      , data = pieces[5] || ''\n\t      , packet = {\n\t            type: packets[pieces[1]]\n\t          , endpoint: pieces[4] || ''\n\t        };\n\t\n\t    // whether we need to acknowledge the packet\n\t    if (id) {\n\t      packet.id = id;\n\t      if (pieces[3])\n\t        packet.ack = 'data';\n\t      else\n\t        packet.ack = true;\n\t    }\n\t\n\t    // handle different packet types\n\t    switch (packet.type) {\n\t      case 'error':\n\t        var pieces = data.split('+');\n\t        packet.reason = reasons[pieces[0]] || '';\n\t        packet.advice = advice[pieces[1]] || '';\n\t        break;\n\t\n\t      case 'message':\n\t        packet.data = data || '';\n\t        break;\n\t\n\t      case 'event':\n\t        try {\n\t          var opts = JSON.parse(data);\n\t          packet.name = opts.name;\n\t          packet.args = opts.args;\n\t        } catch (e) { }\n\t\n\t        packet.args = packet.args || [];\n\t        break;\n\t\n\t      case 'json':\n\t        try {\n\t          packet.data = JSON.parse(data);\n\t        } catch (e) { }\n\t        break;\n\t\n\t      case 'connect':\n\t        packet.qs = data || '';\n\t        break;\n\t\n\t      case 'ack':\n\t        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\n\t        if (pieces) {\n\t          packet.ackId = pieces[1];\n\t          packet.args = [];\n\t\n\t          if (pieces[3]) {\n\t            try {\n\t              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\n\t            } catch (e) { }\n\t          }\n\t        }\n\t        break;\n\t\n\t      case 'disconnect':\n\t      case 'heartbeat':\n\t        break;\n\t    };\n\t\n\t    return packet;\n\t  };\n\t\n\t  /**\n\t   * Decodes data payload. Detects multiple messages\n\t   *\n\t   * @return {Array} messages\n\t   * @api public\n\t   */\n\t\n\t  parser.decodePayload = function (data) {\n\t    // IE doesn't like data[i] for unicode chars, charAt works fine\n\t    if (data.charAt(0) == '\\ufffd') {\n\t      var ret = [];\n\t\n\t      for (var i = 1, length = ''; i < data.length; i++) {\n\t        if (data.charAt(i) == '\\ufffd') {\n\t          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\n\t          i += Number(length) + 1;\n\t          length = '';\n\t        } else {\n\t          length += data.charAt(i);\n\t        }\n\t      }\n\t\n\t      return ret;\n\t    } else {\n\t      return [parser.decodePacket(data)];\n\t    }\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.Transport = Transport;\n\t\n\t  /**\n\t   * This is the transport template for all supported transport methods.\n\t   *\n\t   * @constructor\n\t   * @api public\n\t   */\n\t\n\t  function Transport (socket, sessid) {\n\t    this.socket = socket;\n\t    this.sessid = sessid;\n\t  };\n\t\n\t  /**\n\t   * Apply EventEmitter mixin.\n\t   */\n\t\n\t  io.util.mixin(Transport, io.EventEmitter);\n\t\n\t\n\t  /**\n\t   * Indicates whether heartbeats is enabled for this transport\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.heartbeats = function () {\n\t    return true;\n\t  };\n\t\n\t  /**\n\t   * Handles the response from the server. When a new response is received\n\t   * it will automatically update the timeout, decode the message and\n\t   * forwards the response to the onMessage function for further processing.\n\t   *\n\t   * @param {String} data Response from the server.\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onData = function (data) {\n\t    this.clearCloseTimeout();\n\t\n\t    // If the connection in currently open (or in a reopening state) reset the close\n\t    // timeout since we have just received data. This check is necessary so\n\t    // that we don't reset the timeout on an explicitly disconnected connection.\n\t    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\n\t      this.setCloseTimeout();\n\t    }\n\t\n\t    if (data !== '') {\n\t      // todo: we should only do decodePayload for xhr transports\n\t      var msgs = io.parser.decodePayload(data);\n\t\n\t      if (msgs && msgs.length) {\n\t        for (var i = 0, l = msgs.length; i < l; i++) {\n\t          this.onPacket(msgs[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Handles packets.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onPacket = function (packet) {\n\t    this.socket.setHeartbeatTimeout();\n\t\n\t    if (packet.type == 'heartbeat') {\n\t      return this.onHeartbeat();\n\t    }\n\t\n\t    if (packet.type == 'connect' && packet.endpoint == '') {\n\t      this.onConnect();\n\t    }\n\t\n\t    if (packet.type == 'error' && packet.advice == 'reconnect') {\n\t      this.isOpen = false;\n\t    }\n\t\n\t    this.socket.onPacket(packet);\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Sets close timeout\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.setCloseTimeout = function () {\n\t    if (!this.closeTimeout) {\n\t      var self = this;\n\t\n\t      this.closeTimeout = setTimeout(function () {\n\t        self.onDisconnect();\n\t      }, this.socket.closeTimeout);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Called when transport disconnects.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onDisconnect = function () {\n\t    if (this.isOpen) this.close();\n\t    this.clearTimeouts();\n\t    this.socket.onDisconnect();\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Called when transport connects\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onConnect = function () {\n\t    this.socket.onConnect();\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Clears close timeout\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.clearCloseTimeout = function () {\n\t    if (this.closeTimeout) {\n\t      clearTimeout(this.closeTimeout);\n\t      this.closeTimeout = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Clear timeouts\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.clearTimeouts = function () {\n\t    this.clearCloseTimeout();\n\t\n\t    if (this.reopenTimeout) {\n\t      clearTimeout(this.reopenTimeout);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Sends a packet\n\t   *\n\t   * @param {Object} packet object.\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.packet = function (packet) {\n\t    this.send(io.parser.encodePacket(packet));\n\t  };\n\t\n\t  /**\n\t   * Send the received heartbeat message back to server. So the server\n\t   * knows we are still connected.\n\t   *\n\t   * @param {String} heartbeat Heartbeat response from the server.\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onHeartbeat = function (heartbeat) {\n\t    this.packet({ type: 'heartbeat' });\n\t  };\n\t\n\t  /**\n\t   * Called when the transport opens.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onOpen = function () {\n\t    this.isOpen = true;\n\t    this.clearCloseTimeout();\n\t    this.socket.onOpen();\n\t  };\n\t\n\t  /**\n\t   * Notifies the base when the connection with the Socket.IO server\n\t   * has been disconnected.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.onClose = function () {\n\t    var self = this;\n\t\n\t    /* FIXME: reopen delay causing a infinit loop\n\t    this.reopenTimeout = setTimeout(function () {\n\t      self.open();\n\t    }, this.socket.options['reopen delay']);*/\n\t\n\t    this.isOpen = false;\n\t    this.socket.onClose();\n\t    this.onDisconnect();\n\t  };\n\t\n\t  /**\n\t   * Generates a connection url based on the Socket.IO URL Protocol.\n\t   * See <https://github.com/learnboost/socket.io-node/> for more details.\n\t   *\n\t   * @returns {String} Connection url\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.prepareUrl = function () {\n\t    var options = this.socket.options;\n\t\n\t    return this.scheme() + '://'\n\t      + options.host + ':' + options.port + '/'\n\t      + options.resource + '/' + io.protocol\n\t      + '/' + this.name + '/' + this.sessid;\n\t  };\n\t\n\t  /**\n\t   * Checks if the transport is ready to start a connection.\n\t   *\n\t   * @param {Socket} socket The socket instance that needs a transport\n\t   * @param {Function} fn The callback\n\t   * @api private\n\t   */\n\t\n\t  Transport.prototype.ready = function (socket, fn) {\n\t    fn.call(this);\n\t  };\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.Socket = Socket;\n\t\n\t  /**\n\t   * Create a new `Socket.IO client` which can establish a persistent\n\t   * connection with a Socket.IO enabled server.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  function Socket (options) {\n\t    this.options = {\n\t        port: 80\n\t      , secure: false\n\t      , document: 'document' in global ? document : false\n\t      , resource: 'socket.io'\n\t      , transports: io.transports\n\t      , 'connect timeout': 10000\n\t      , 'try multiple transports': true\n\t      , 'reconnect': true\n\t      , 'reconnection delay': 500\n\t      , 'reconnection limit': Infinity\n\t      , 'reopen delay': 3000\n\t      , 'max reconnection attempts': 10\n\t      , 'sync disconnect on unload': false\n\t      , 'auto connect': true\n\t      , 'flash policy port': 10843\n\t      , 'manualFlush': false\n\t    };\n\t\n\t    io.util.merge(this.options, options);\n\t\n\t    this.connected = false;\n\t    this.open = false;\n\t    this.connecting = false;\n\t    this.reconnecting = false;\n\t    this.namespaces = {};\n\t    this.buffer = [];\n\t    this.doBuffer = false;\n\t\n\t    if (this.options['sync disconnect on unload'] &&\n\t        (!this.isXDomain() || io.util.ua.hasCORS)) {\n\t      var self = this;\n\t      io.util.on(global, 'beforeunload', function () {\n\t        self.disconnectSync();\n\t      }, false);\n\t    }\n\t\n\t    if (this.options['auto connect']) {\n\t      this.connect();\n\t    }\n\t};\n\t\n\t  /**\n\t   * Apply EventEmitter mixin.\n\t   */\n\t\n\t  io.util.mixin(Socket, io.EventEmitter);\n\t\n\t  /**\n\t   * Returns a namespace listener/emitter for this socket\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.of = function (name) {\n\t    if (!this.namespaces[name]) {\n\t      this.namespaces[name] = new io.SocketNamespace(this, name);\n\t\n\t      if (name !== '') {\n\t        this.namespaces[name].packet({ type: 'connect' });\n\t      }\n\t    }\n\t\n\t    return this.namespaces[name];\n\t  };\n\t\n\t  /**\n\t   * Emits the given event to the Socket and all namespaces\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.publish = function () {\n\t    this.emit.apply(this, arguments);\n\t\n\t    var nsp;\n\t\n\t    for (var i in this.namespaces) {\n\t      if (this.namespaces.hasOwnProperty(i)) {\n\t        nsp = this.of(i);\n\t        nsp.$emit.apply(nsp, arguments);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Performs the handshake\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  function empty () { };\n\t\n\t  Socket.prototype.handshake = function (fn) {\n\t    var self = this\n\t      , options = this.options;\n\t\n\t    function complete (data) {\n\t      if (data instanceof Error) {\n\t        self.connecting = false;\n\t        self.onError(data.message);\n\t      } else {\n\t        fn.apply(null, data.split(':'));\n\t      }\n\t    };\n\t\n\t    var url = [\n\t          'http' + (options.secure ? 's' : '') + ':/'\n\t        , options.host + ':' + options.port\n\t        , options.resource\n\t        , io.protocol\n\t        , io.util.query(this.options.query, 't=' + +new Date)\n\t      ].join('/');\n\t\n\t    if (this.isXDomain() && !io.util.ua.hasCORS) {\n\t      var insertAt = document.getElementsByTagName('script')[0]\n\t        , script = document.createElement('script');\n\t\n\t      script.src = url + '&jsonp=' + io.j.length;\n\t      insertAt.parentNode.insertBefore(script, insertAt);\n\t\n\t      io.j.push(function (data) {\n\t        complete(data);\n\t        script.parentNode.removeChild(script);\n\t      });\n\t    } else {\n\t      var xhr = io.util.request();\n\t\n\t      xhr.open('GET', url, true);\n\t      if (this.isXDomain()) {\n\t        xhr.withCredentials = true;\n\t      }\n\t      xhr.onreadystatechange = function () {\n\t        if (xhr.readyState == 4) {\n\t          xhr.onreadystatechange = empty;\n\t\n\t          if (xhr.status == 200) {\n\t            complete(xhr.responseText);\n\t          } else if (xhr.status == 403) {\n\t            self.onError(xhr.responseText);\n\t          } else {\n\t            self.connecting = false;            \n\t            !self.reconnecting && self.onError(xhr.responseText);\n\t          }\n\t        }\n\t      };\n\t      xhr.send(null);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Find an available transport based on the options supplied in the constructor.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.getTransport = function (override) {\n\t    var transports = override || this.transports, match;\n\t\n\t    for (var i = 0, transport; transport = transports[i]; i++) {\n\t      if (io.Transport[transport]\n\t        && io.Transport[transport].check(this)\n\t        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {\n\t        return new io.Transport[transport](this, this.sessionid);\n\t      }\n\t    }\n\t\n\t    return null;\n\t  };\n\t\n\t  /**\n\t   * Connects to the server.\n\t   *\n\t   * @param {Function} [fn] Callback.\n\t   * @returns {io.Socket}\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.connect = function (fn) {\n\t    if (this.connecting) {\n\t      return this;\n\t    }\n\t\n\t    var self = this;\n\t    self.connecting = true;\n\t    \n\t    this.handshake(function (sid, heartbeat, close, transports) {\n\t      self.sessionid = sid;\n\t      self.closeTimeout = close * 1000;\n\t      self.heartbeatTimeout = heartbeat * 1000;\n\t      if(!self.transports)\n\t          self.transports = self.origTransports = (transports ? io.util.intersect(\n\t              transports.split(',')\n\t            , self.options.transports\n\t          ) : self.options.transports);\n\t\n\t      self.setHeartbeatTimeout();\n\t\n\t      function connect (transports){\n\t        if (self.transport) self.transport.clearTimeouts();\n\t\n\t        self.transport = self.getTransport(transports);\n\t        if (!self.transport) return self.publish('connect_failed');\n\t\n\t        // once the transport is ready\n\t        self.transport.ready(self, function () {\n\t          self.connecting = true;\n\t          self.publish('connecting', self.transport.name);\n\t          self.transport.open();\n\t\n\t          if (self.options['connect timeout']) {\n\t            self.connectTimeoutTimer = setTimeout(function () {\n\t              if (!self.connected) {\n\t                self.connecting = false;\n\t\n\t                if (self.options['try multiple transports']) {\n\t                  var remaining = self.transports;\n\t\n\t                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=\n\t                         self.transport.name) {}\n\t\n\t                    if (remaining.length){\n\t                      connect(remaining);\n\t                    } else {\n\t                      self.publish('connect_failed');\n\t                    }\n\t                }\n\t              }\n\t            }, self.options['connect timeout']);\n\t          }\n\t        });\n\t      }\n\t\n\t      connect(self.transports);\n\t\n\t      self.once('connect', function (){\n\t        clearTimeout(self.connectTimeoutTimer);\n\t\n\t        fn && typeof fn == 'function' && fn();\n\t      });\n\t    });\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Clears and sets a new heartbeat timeout using the value given by the\n\t   * server during the handshake.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.setHeartbeatTimeout = function () {\n\t    clearTimeout(this.heartbeatTimeoutTimer);\n\t    if(this.transport && !this.transport.heartbeats()) return;\n\t\n\t    var self = this;\n\t    this.heartbeatTimeoutTimer = setTimeout(function () {\n\t      self.transport.onClose();\n\t    }, this.heartbeatTimeout);\n\t  };\n\t\n\t  /**\n\t   * Sends a message.\n\t   *\n\t   * @param {Object} data packet.\n\t   * @returns {io.Socket}\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.packet = function (data) {\n\t    if (this.connected && !this.doBuffer) {\n\t      this.transport.packet(data);\n\t    } else {\n\t      this.buffer.push(data);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Sets buffer state\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.setBuffer = function (v) {\n\t    this.doBuffer = v;\n\t\n\t    if (!v && this.connected && this.buffer.length) {\n\t      if (!this.options['manualFlush']) {\n\t        this.flushBuffer();\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Flushes the buffer data over the wire.\n\t   * To be invoked manually when 'manualFlush' is set to true.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.flushBuffer = function() {\n\t    this.transport.payload(this.buffer);\n\t    this.buffer = [];\n\t  };\n\t  \n\t\n\t  /**\n\t   * Disconnect the established connect.\n\t   *\n\t   * @returns {io.Socket}\n\t   * @api public\n\t   */\n\t\n\t  Socket.prototype.disconnect = function () {\n\t    if (this.connected || this.connecting) {\n\t      if (this.open) {\n\t        this.of('').packet({ type: 'disconnect' });\n\t      }\n\t\n\t      // handle disconnection immediately\n\t      this.onDisconnect('booted');\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Disconnects the socket with a sync XHR.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.disconnectSync = function () {\n\t    // ensure disconnection\n\t    var xhr = io.util.request();\n\t    var uri = [\n\t        'http' + (this.options.secure ? 's' : '') + ':/'\n\t      , this.options.host + ':' + this.options.port\n\t      , this.options.resource\n\t      , io.protocol\n\t      , ''\n\t      , this.sessionid\n\t    ].join('/') + '/?disconnect=1';\n\t\n\t    xhr.open('GET', uri, false);\n\t    xhr.send(null);\n\t\n\t    // handle disconnection immediately\n\t    this.onDisconnect('booted');\n\t  };\n\t\n\t  /**\n\t   * Check if we need to use cross domain enabled transports. Cross domain would\n\t   * be a different port or different domain name.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.isXDomain = function () {\n\t\n\t    var port = global.location.port ||\n\t      ('https:' == global.location.protocol ? 443 : 80);\n\t\n\t    return this.options.host !== global.location.hostname \n\t      || this.options.port != port;\n\t  };\n\t\n\t  /**\n\t   * Called upon handshake.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onConnect = function () {\n\t    if (!this.connected) {\n\t      this.connected = true;\n\t      this.connecting = false;\n\t      if (!this.doBuffer) {\n\t        // make sure to flush the buffer\n\t        this.setBuffer(false);\n\t      }\n\t      this.emit('connect');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Called when the transport opens\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onOpen = function () {\n\t    this.open = true;\n\t  };\n\t\n\t  /**\n\t   * Called when the transport closes.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onClose = function () {\n\t    this.open = false;\n\t    clearTimeout(this.heartbeatTimeoutTimer);\n\t  };\n\t\n\t  /**\n\t   * Called when the transport first opens a connection\n\t   *\n\t   * @param text\n\t   */\n\t\n\t  Socket.prototype.onPacket = function (packet) {\n\t    this.of(packet.endpoint).onPacket(packet);\n\t  };\n\t\n\t  /**\n\t   * Handles an error.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onError = function (err) {\n\t    if (err && err.advice) {\n\t      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\n\t        this.disconnect();\n\t        if (this.options.reconnect) {\n\t          this.reconnect();\n\t        }\n\t      }\n\t    }\n\t\n\t    this.publish('error', err && err.reason ? err.reason : err);\n\t  };\n\t\n\t  /**\n\t   * Called when the transport disconnects.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.onDisconnect = function (reason) {\n\t    var wasConnected = this.connected\n\t      , wasConnecting = this.connecting;\n\t\n\t    this.connected = false;\n\t    this.connecting = false;\n\t    this.open = false;\n\t\n\t    if (wasConnected || wasConnecting) {\n\t      this.transport.close();\n\t      this.transport.clearTimeouts();\n\t      if (wasConnected) {\n\t        this.publish('disconnect', reason);\n\t\n\t        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\n\t          this.reconnect();\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Called upon reconnection.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Socket.prototype.reconnect = function () {\n\t    this.reconnecting = true;\n\t    this.reconnectionAttempts = 0;\n\t    this.reconnectionDelay = this.options['reconnection delay'];\n\t\n\t    var self = this\n\t      , maxAttempts = this.options['max reconnection attempts']\n\t      , tryMultiple = this.options['try multiple transports']\n\t      , limit = this.options['reconnection limit'];\n\t\n\t    function reset () {\n\t      if (self.connected) {\n\t        for (var i in self.namespaces) {\n\t          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\n\t              self.namespaces[i].packet({ type: 'connect' });\n\t          }\n\t        }\n\t        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\n\t      }\n\t\n\t      clearTimeout(self.reconnectionTimer);\n\t\n\t      self.removeListener('connect_failed', maybeReconnect);\n\t      self.removeListener('connect', maybeReconnect);\n\t\n\t      self.reconnecting = false;\n\t\n\t      delete self.reconnectionAttempts;\n\t      delete self.reconnectionDelay;\n\t      delete self.reconnectionTimer;\n\t      delete self.redoTransports;\n\t\n\t      self.options['try multiple transports'] = tryMultiple;\n\t    };\n\t\n\t    function maybeReconnect () {\n\t      if (!self.reconnecting) {\n\t        return;\n\t      }\n\t\n\t      if (self.connected) {\n\t        return reset();\n\t      };\n\t\n\t      if (self.connecting && self.reconnecting) {\n\t        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\n\t      }\n\t\n\t      if (self.reconnectionAttempts++ >= maxAttempts) {\n\t        if (!self.redoTransports) {\n\t          self.on('connect_failed', maybeReconnect);\n\t          self.options['try multiple transports'] = true;\n\t          self.transports = self.origTransports;\n\t          self.transport = self.getTransport();\n\t          self.redoTransports = true;\n\t          self.connect();\n\t        } else {\n\t          self.publish('reconnect_failed');\n\t          reset();\n\t        }\n\t      } else {\n\t        if (self.reconnectionDelay < limit) {\n\t          self.reconnectionDelay *= 2; // exponential back off\n\t        }\n\t\n\t        self.connect();\n\t        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\n\t        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\n\t      }\n\t    };\n\t\n\t    this.options['try multiple transports'] = false;\n\t    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\n\t\n\t    this.on('connect', maybeReconnect);\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.SocketNamespace = SocketNamespace;\n\t\n\t  /**\n\t   * Socket namespace constructor.\n\t   *\n\t   * @constructor\n\t   * @api public\n\t   */\n\t\n\t  function SocketNamespace (socket, name) {\n\t    this.socket = socket;\n\t    this.name = name || '';\n\t    this.flags = {};\n\t    this.json = new Flag(this, 'json');\n\t    this.ackPackets = 0;\n\t    this.acks = {};\n\t  };\n\t\n\t  /**\n\t   * Apply EventEmitter mixin.\n\t   */\n\t\n\t  io.util.mixin(SocketNamespace, io.EventEmitter);\n\t\n\t  /**\n\t   * Copies emit since we override it\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\n\t\n\t  /**\n\t   * Creates a new namespace, by proxying the request to the socket. This\n\t   * allows us to use the synax as we do on the server.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  SocketNamespace.prototype.of = function () {\n\t    return this.socket.of.apply(this.socket, arguments);\n\t  };\n\t\n\t  /**\n\t   * Sends a packet.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  SocketNamespace.prototype.packet = function (packet) {\n\t    packet.endpoint = this.name;\n\t    this.socket.packet(packet);\n\t    this.flags = {};\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Sends a message\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  SocketNamespace.prototype.send = function (data, fn) {\n\t    var packet = {\n\t        type: this.flags.json ? 'json' : 'message'\n\t      , data: data\n\t    };\n\t\n\t    if ('function' == typeof fn) {\n\t      packet.id = ++this.ackPackets;\n\t      packet.ack = true;\n\t      this.acks[packet.id] = fn;\n\t    }\n\t\n\t    return this.packet(packet);\n\t  };\n\t\n\t  /**\n\t   * Emits an event\n\t   *\n\t   * @api public\n\t   */\n\t  \n\t  SocketNamespace.prototype.emit = function (name) {\n\t    var args = Array.prototype.slice.call(arguments, 1)\n\t      , lastArg = args[args.length - 1]\n\t      , packet = {\n\t            type: 'event'\n\t          , name: name\n\t        };\n\t\n\t    if ('function' == typeof lastArg) {\n\t      packet.id = ++this.ackPackets;\n\t      packet.ack = 'data';\n\t      this.acks[packet.id] = lastArg;\n\t      args = args.slice(0, args.length - 1);\n\t    }\n\t\n\t    packet.args = args;\n\t\n\t    return this.packet(packet);\n\t  };\n\t\n\t  /**\n\t   * Disconnects the namespace\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  SocketNamespace.prototype.disconnect = function () {\n\t    if (this.name === '') {\n\t      this.socket.disconnect();\n\t    } else {\n\t      this.packet({ type: 'disconnect' });\n\t      this.$emit('disconnect');\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Handles a packet\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  SocketNamespace.prototype.onPacket = function (packet) {\n\t    var self = this;\n\t\n\t    function ack () {\n\t      self.packet({\n\t          type: 'ack'\n\t        , args: io.util.toArray(arguments)\n\t        , ackId: packet.id\n\t      });\n\t    };\n\t\n\t    switch (packet.type) {\n\t      case 'connect':\n\t        this.$emit('connect');\n\t        break;\n\t\n\t      case 'disconnect':\n\t        if (this.name === '') {\n\t          this.socket.onDisconnect(packet.reason || 'booted');\n\t        } else {\n\t          this.$emit('disconnect', packet.reason);\n\t        }\n\t        break;\n\t\n\t      case 'message':\n\t      case 'json':\n\t        var params = ['message', packet.data];\n\t\n\t        if (packet.ack == 'data') {\n\t          params.push(ack);\n\t        } else if (packet.ack) {\n\t          this.packet({ type: 'ack', ackId: packet.id });\n\t        }\n\t\n\t        this.$emit.apply(this, params);\n\t        break;\n\t\n\t      case 'event':\n\t        var params = [packet.name].concat(packet.args);\n\t\n\t        if (packet.ack == 'data')\n\t          params.push(ack);\n\t\n\t        this.$emit.apply(this, params);\n\t        break;\n\t\n\t      case 'ack':\n\t        if (this.acks[packet.ackId]) {\n\t          this.acks[packet.ackId].apply(this, packet.args);\n\t          delete this.acks[packet.ackId];\n\t        }\n\t        break;\n\t\n\t      case 'error':\n\t        if (packet.advice){\n\t          this.socket.onError(packet);\n\t        } else {\n\t          if (packet.reason == 'unauthorized') {\n\t            this.$emit('connect_failed', packet.reason);\n\t          } else {\n\t            this.$emit('error', packet.reason);\n\t          }\n\t        }\n\t        break;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Flag interface.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  function Flag (nsp, name) {\n\t    this.namespace = nsp;\n\t    this.name = name;\n\t  };\n\t\n\t  /**\n\t   * Send a message\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Flag.prototype.send = function () {\n\t    this.namespace.flags[this.name] = true;\n\t    this.namespace.send.apply(this.namespace, arguments);\n\t  };\n\t\n\t  /**\n\t   * Emit an event\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Flag.prototype.emit = function () {\n\t    this.namespace.flags[this.name] = true;\n\t    this.namespace.emit.apply(this.namespace, arguments);\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.websocket = WS;\n\t\n\t  /**\n\t   * The WebSocket transport uses the HTML5 WebSocket API to establish an\n\t   * persistent connection with the Socket.IO server. This transport will also\n\t   * be inherited by the FlashSocket fallback as it provides a API compatible\n\t   * polyfill for the WebSockets.\n\t   *\n\t   * @constructor\n\t   * @extends {io.Transport}\n\t   * @api public\n\t   */\n\t\n\t  function WS (socket) {\n\t    io.Transport.apply(this, arguments);\n\t  };\n\t\n\t  /**\n\t   * Inherits from Transport.\n\t   */\n\t\n\t  io.util.inherit(WS, io.Transport);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  WS.prototype.name = 'websocket';\n\t\n\t  /**\n\t   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\n\t   * all the appropriate listeners to handle the responses from the server.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  WS.prototype.open = function () {\n\t    var query = io.util.query(this.socket.options.query)\n\t      , self = this\n\t      , Socket\n\t\n\t\n\t    if (!Socket) {\n\t      Socket = global.MozWebSocket || global.WebSocket;\n\t    }\n\t\n\t    this.websocket = new Socket(this.prepareUrl() + query);\n\t\n\t    this.websocket.onopen = function () {\n\t      self.onOpen();\n\t      self.socket.setBuffer(false);\n\t    };\n\t    this.websocket.onmessage = function (ev) {\n\t      self.onData(ev.data);\n\t    };\n\t    this.websocket.onclose = function () {\n\t      self.onClose();\n\t      self.socket.setBuffer(true);\n\t    };\n\t    this.websocket.onerror = function (e) {\n\t      self.onError(e);\n\t    };\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Send a message to the Socket.IO server. The message will automatically be\n\t   * encoded in the correct message format.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  // Do to a bug in the current IDevices browser, we need to wrap the send in a \n\t  // setTimeout, when they resume from sleeping the browser will crash if \n\t  // we don't allow the browser time to detect the socket has been closed\n\t  if (io.util.ua.iDevice) {\n\t    WS.prototype.send = function (data) {\n\t      var self = this;\n\t      setTimeout(function() {\n\t         self.websocket.send(data);\n\t      },0);\n\t      return this;\n\t    };\n\t  } else {\n\t    WS.prototype.send = function (data) {\n\t      this.websocket.send(data);\n\t      return this;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Payload\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  WS.prototype.payload = function (arr) {\n\t    for (var i = 0, l = arr.length; i < l; i++) {\n\t      this.packet(arr[i]);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Disconnect the established `WebSocket` connection.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  WS.prototype.close = function () {\n\t    this.websocket.close();\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Handle the errors that `WebSocket` might be giving when we\n\t   * are attempting to connect or send messages.\n\t   *\n\t   * @param {Error} e The error.\n\t   * @api private\n\t   */\n\t\n\t  WS.prototype.onError = function (e) {\n\t    this.socket.onError(e);\n\t  };\n\t\n\t  /**\n\t   * Returns the appropriate scheme for the URI generation.\n\t   *\n\t   * @api private\n\t   */\n\t  WS.prototype.scheme = function () {\n\t    return this.socket.options.secure ? 'wss' : 'ws';\n\t  };\n\t\n\t  /**\n\t   * Checks if the browser has support for native `WebSockets` and that\n\t   * it's not the polyfill created for the FlashSocket transport.\n\t   *\n\t   * @return {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  WS.check = function () {\n\t    return ('WebSocket' in global && !('__addTask' in WebSocket))\n\t          || 'MozWebSocket' in global;\n\t  };\n\t\n\t  /**\n\t   * Check if the `WebSocket` transport support cross domain communications.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  WS.xdomainCheck = function () {\n\t    return true;\n\t  };\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('websocket');\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.flashsocket = Flashsocket;\n\t\n\t  /**\n\t   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\n\t   * specification. It uses a .swf file to communicate with the server. If you want\n\t   * to serve the .swf file from a other server than where the Socket.IO script is\n\t   * coming from you need to use the insecure version of the .swf. More information\n\t   * about this can be found on the github page.\n\t   *\n\t   * @constructor\n\t   * @extends {io.Transport.websocket}\n\t   * @api public\n\t   */\n\t\n\t  function Flashsocket () {\n\t    io.Transport.websocket.apply(this, arguments);\n\t  };\n\t\n\t  /**\n\t   * Inherits from Transport.\n\t   */\n\t\n\t  io.util.inherit(Flashsocket, io.Transport.websocket);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.prototype.name = 'flashsocket';\n\t\n\t  /**\n\t   * Disconnect the established `FlashSocket` connection. This is done by adding a \n\t   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \n\t   * transport.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.prototype.open = function () {\n\t    var self = this\n\t      , args = arguments;\n\t\n\t    WebSocket.__addTask(function () {\n\t      io.Transport.websocket.prototype.open.apply(self, args);\n\t    });\n\t    return this;\n\t  };\n\t  \n\t  /**\n\t   * Sends a message to the Socket.IO server. This is done by adding a new\n\t   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \n\t   * transport.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.prototype.send = function () {\n\t    var self = this, args = arguments;\n\t    WebSocket.__addTask(function () {\n\t      io.Transport.websocket.prototype.send.apply(self, args);\n\t    });\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Disconnects the established `FlashSocket` connection.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.prototype.close = function () {\n\t    WebSocket.__tasks.length = 0;\n\t    io.Transport.websocket.prototype.close.call(this);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * The WebSocket fall back needs to append the flash container to the body\n\t   * element, so we need to make sure we have access to it. Or defer the call\n\t   * until we are sure there is a body element.\n\t   *\n\t   * @param {Socket} socket The socket instance that needs a transport\n\t   * @param {Function} fn The callback\n\t   * @api private\n\t   */\n\t\n\t  Flashsocket.prototype.ready = function (socket, fn) {\n\t    function init () {\n\t      var options = socket.options\n\t        , port = options['flash policy port']\n\t        , path = [\n\t              'http' + (options.secure ? 's' : '') + ':/'\n\t            , options.host + ':' + options.port\n\t            , options.resource\n\t            , 'static/flashsocket'\n\t            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'\n\t          ];\n\t\n\t      // Only start downloading the swf file when the checked that this browser\n\t      // actually supports it\n\t      if (!Flashsocket.loaded) {\n\t        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\n\t          // Set the correct file based on the XDomain settings\n\t          WEB_SOCKET_SWF_LOCATION = path.join('/');\n\t        }\n\t\n\t        if (port !== 843) {\n\t          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\n\t        }\n\t\n\t        WebSocket.__initialize();\n\t        Flashsocket.loaded = true;\n\t      }\n\t\n\t      fn.call(self);\n\t    }\n\t\n\t    var self = this;\n\t    if (document.body) return init();\n\t\n\t    io.util.load(init);\n\t  };\n\t\n\t  /**\n\t   * Check if the FlashSocket transport is supported as it requires that the Adobe\n\t   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\n\t   * the polyfill is correctly loaded.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.check = function () {\n\t    if (\n\t        typeof WebSocket == 'undefined'\n\t      || !('__initialize' in WebSocket) || !swfobject\n\t    ) return false;\n\t\n\t    return swfobject.getFlashPlayerVersion().major >= 10;\n\t  };\n\t\n\t  /**\n\t   * Check if the FlashSocket transport can be used as cross domain / cross origin \n\t   * transport. Because we can't see which type (secure or insecure) of .swf is used\n\t   * we will just return true.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  Flashsocket.xdomainCheck = function () {\n\t    return true;\n\t  };\n\t\n\t  /**\n\t   * Disable AUTO_INITIALIZATION\n\t   */\n\t\n\t  if (typeof window != 'undefined') {\n\t    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n\t  }\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('flashsocket');\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t/*\tSWFObject v2.2 <http://code.google.com/p/swfobject/> \n\t\tis released under the MIT License <http://www.opensource.org/licenses/mit-license.php> \n\t*/\n\tif ('undefined' != typeof window) {\n\tvar swfobject=function(){var D=\"undefined\",r=\"object\",S=\"Shockwave Flash\",W=\"ShockwaveFlash.ShockwaveFlash\",q=\"application/x-shockwave-flash\",R=\"SWFObjectExprInst\",x=\"onreadystatechange\",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\\/(\\d+(\\.\\d+)?).*$/,\"$1\")):false,X=!+\"\\v1\",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\\s+(\\S+\\s+\\S+$)/,\"$1\");ag[0]=parseInt(ab.replace(/^(.*)\\..*$/,\"$1\"),10);ag[1]=parseInt(ab.replace(/^.*\\.(.*)\\s.*$/,\"$1\"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,\"$1\"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable(\"$version\");if(ab){X=true;ab=ab.split(\" \")[1].split(\",\");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState==\"complete\")||(typeof j.readyState==D&&(j.getElementsByTagName(\"body\")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener(\"DOMContentLoaded\",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState==\"complete\"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll(\"left\")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName(\"body\")[0].appendChild(C(\"span\"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener(\"load\",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener(\"load\",Y,false)}else{if(typeof O.attachEvent!=D){i(O,\"onload\",Y)}else{if(typeof O.onload==\"function\"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName(\"body\")[0];var aa=C(r);aa.setAttribute(\"type\",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable(\"$version\");if(ab){ab=ab.split(\" \")[1].split(\",\");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute(\"width\")||\"0\";ai.height=ae.getAttribute(\"height\")||\"0\";if(ae.getAttribute(\"class\")){ai.styleclass=ae.getAttribute(\"class\")}if(ae.getAttribute(\"align\")){ai.align=ae.getAttribute(\"align\")}var ah={};var X=ae.getElementsByTagName(\"param\");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute(\"name\").toLowerCase()!=\"movie\"){ah[X[ad].getAttribute(\"name\")]=X[ad].getAttribute(\"value\")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName==\"OBJECT\"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F(\"6.0.65\")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName==\"OBJECT\"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width=\"310\"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height=\"137\"}j.title=j.title.slice(0,47)+\" - Flash Player Installation\";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):\"PlugIn\",ac=\"MMredirectURL=\"+O.location.toString().replace(/&/g,\"%26\")+\"&MMplayerType=\"+ad+\"&MMdoctitle=\"+j.title;if(typeof ab.flashvars!=D){ab.flashvars+=\"&\"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C(\"div\");X+=\"SWFObjectNew\";Y.setAttribute(\"id\",X);ae.parentNode.insertBefore(Y,ae);ae.style.display=\"none\";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C(\"div\");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display=\"none\";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C(\"div\");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName==\"PARAM\")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah=\"\";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()==\"data\"){ag.movie=ai[ae]}else{if(ae.toLowerCase()==\"styleclass\"){ah+=' class=\"'+ai[ae]+'\"'}else{if(ae.toLowerCase()!=\"classid\"){ah+=\" \"+ae+'=\"'+ai[ae]+'\"'}}}}}var af=\"\";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name=\"'+ad+'\" value=\"'+ag[ad]+'\" />'}}aa.outerHTML='<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"'+ah+\">\"+af+\"</object>\";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute(\"type\",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()==\"styleclass\"){Z.setAttribute(\"class\",ai[ac])}else{if(ac.toLowerCase()!=\"classid\"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!=\"movie\"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C(\"param\");aa.setAttribute(\"name\",X);aa.setAttribute(\"value\",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName==\"OBJECT\"){if(M.ie&&M.win){X.style.display=\"none\";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]==\"function\"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(\".\");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName(\"head\")[0];if(!aa){return}var X=(ad&&typeof ad==\"string\")?ad:\"screen\";if(ab){n=null;G=null}if(!n||G!=X){var Z=C(\"style\");Z.setAttribute(\"type\",\"text/css\");Z.setAttribute(\"media\",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+\" {\"+Y+\"}\"))}}}function w(Z,X){if(!m){return}var Y=X?\"visible\":\"hidden\";if(J&&c(Z)){c(Z).style.visibility=Y}else{v(\"#\"+Z,\"visibility:\"+Y)}}function L(Y){var Z=/[\\\\\\\"<>\\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent(\"onunload\",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+=\"\";ag+=\"\";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+=\"&\"+ai+\"=\"+Z[ai]}else{am.flashvars=ai+\"=\"+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\\?/.test(Z)){Z=Z.split(\"?\")[1]}if(aa==null){return L(Z)}var Y=Z.split(\"&\");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf(\"=\"))==aa){return L(Y[X].substring((Y[X].indexOf(\"=\")+1)))}}}return\"\"},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display=\"block\"}}if(E){E(B)}}a=false}}}}();\n\t}\n\t// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>\n\t// License: New BSD License\n\t// Reference: http://dev.w3.org/html5/websockets/\n\t// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol\n\t\n\t(function() {\n\t  \n\t  if ('undefined' == typeof window || window.WebSocket) return;\n\t\n\t  var console = window.console;\n\t  if (!console || !console.log || !console.error) {\n\t    console = {log: function(){ }, error: function(){ }};\n\t  }\n\t  \n\t  if (!swfobject.hasFlashPlayerVersion(\"10.0.0\")) {\n\t    console.error(\"Flash Player >= 10.0.0 is required.\");\n\t    return;\n\t  }\n\t  if (location.protocol == \"file:\") {\n\t    console.error(\n\t      \"WARNING: web-socket-js doesn't work in file:///... URL \" +\n\t      \"unless you set Flash Security Settings properly. \" +\n\t      \"Open the page via Web server i.e. http://...\");\n\t  }\n\t\n\t  /**\n\t   * This class represents a faux web socket.\n\t   * @param {string} url\n\t   * @param {array or string} protocols\n\t   * @param {string} proxyHost\n\t   * @param {int} proxyPort\n\t   * @param {string} headers\n\t   */\n\t  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {\n\t    var self = this;\n\t    self.__id = WebSocket.__nextId++;\n\t    WebSocket.__instances[self.__id] = self;\n\t    self.readyState = WebSocket.CONNECTING;\n\t    self.bufferedAmount = 0;\n\t    self.__events = {};\n\t    if (!protocols) {\n\t      protocols = [];\n\t    } else if (typeof protocols == \"string\") {\n\t      protocols = [protocols];\n\t    }\n\t    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.\n\t    // Otherwise, when onopen fires immediately, onopen is called before it is set.\n\t    setTimeout(function() {\n\t      WebSocket.__addTask(function() {\n\t        WebSocket.__flash.create(\n\t            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);\n\t      });\n\t    }, 0);\n\t  };\n\t\n\t  /**\n\t   * Send data to the web socket.\n\t   * @param {string} data  The data to send to the socket.\n\t   * @return {boolean}  True for success, false for failure.\n\t   */\n\t  WebSocket.prototype.send = function(data) {\n\t    if (this.readyState == WebSocket.CONNECTING) {\n\t      throw \"INVALID_STATE_ERR: Web Socket connection has not been established\";\n\t    }\n\t    // We use encodeURIComponent() here, because FABridge doesn't work if\n\t    // the argument includes some characters. We don't use escape() here\n\t    // because of this:\n\t    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions\n\t    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't\n\t    // preserve all Unicode characters either e.g. \"\\uffff\" in Firefox.\n\t    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require\n\t    // additional testing.\n\t    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));\n\t    if (result < 0) { // success\n\t      return true;\n\t    } else {\n\t      this.bufferedAmount += result;\n\t      return false;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Close this web socket gracefully.\n\t   */\n\t  WebSocket.prototype.close = function() {\n\t    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {\n\t      return;\n\t    }\n\t    this.readyState = WebSocket.CLOSING;\n\t    WebSocket.__flash.close(this.__id);\n\t  };\n\t\n\t  /**\n\t   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n\t   *\n\t   * @param {string} type\n\t   * @param {function} listener\n\t   * @param {boolean} useCapture\n\t   * @return void\n\t   */\n\t  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {\n\t    if (!(type in this.__events)) {\n\t      this.__events[type] = [];\n\t    }\n\t    this.__events[type].push(listener);\n\t  };\n\t\n\t  /**\n\t   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n\t   *\n\t   * @param {string} type\n\t   * @param {function} listener\n\t   * @param {boolean} useCapture\n\t   * @return void\n\t   */\n\t  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {\n\t    if (!(type in this.__events)) return;\n\t    var events = this.__events[type];\n\t    for (var i = events.length - 1; i >= 0; --i) {\n\t      if (events[i] === listener) {\n\t        events.splice(i, 1);\n\t        break;\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n\t   *\n\t   * @param {Event} event\n\t   * @return void\n\t   */\n\t  WebSocket.prototype.dispatchEvent = function(event) {\n\t    var events = this.__events[event.type] || [];\n\t    for (var i = 0; i < events.length; ++i) {\n\t      events[i](event);\n\t    }\n\t    var handler = this[\"on\" + event.type];\n\t    if (handler) handler(event);\n\t  };\n\t\n\t  /**\n\t   * Handles an event from Flash.\n\t   * @param {Object} flashEvent\n\t   */\n\t  WebSocket.prototype.__handleEvent = function(flashEvent) {\n\t    if (\"readyState\" in flashEvent) {\n\t      this.readyState = flashEvent.readyState;\n\t    }\n\t    if (\"protocol\" in flashEvent) {\n\t      this.protocol = flashEvent.protocol;\n\t    }\n\t    \n\t    var jsEvent;\n\t    if (flashEvent.type == \"open\" || flashEvent.type == \"error\") {\n\t      jsEvent = this.__createSimpleEvent(flashEvent.type);\n\t    } else if (flashEvent.type == \"close\") {\n\t      // TODO implement jsEvent.wasClean\n\t      jsEvent = this.__createSimpleEvent(\"close\");\n\t    } else if (flashEvent.type == \"message\") {\n\t      var data = decodeURIComponent(flashEvent.message);\n\t      jsEvent = this.__createMessageEvent(\"message\", data);\n\t    } else {\n\t      throw \"unknown event type: \" + flashEvent.type;\n\t    }\n\t    \n\t    this.dispatchEvent(jsEvent);\n\t  };\n\t  \n\t  WebSocket.prototype.__createSimpleEvent = function(type) {\n\t    if (document.createEvent && window.Event) {\n\t      var event = document.createEvent(\"Event\");\n\t      event.initEvent(type, false, false);\n\t      return event;\n\t    } else {\n\t      return {type: type, bubbles: false, cancelable: false};\n\t    }\n\t  };\n\t  \n\t  WebSocket.prototype.__createMessageEvent = function(type, data) {\n\t    if (document.createEvent && window.MessageEvent && !window.opera) {\n\t      var event = document.createEvent(\"MessageEvent\");\n\t      event.initMessageEvent(\"message\", false, false, data, null, null, window, null);\n\t      return event;\n\t    } else {\n\t      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.\n\t      return {type: type, data: data, bubbles: false, cancelable: false};\n\t    }\n\t  };\n\t  \n\t  /**\n\t   * Define the WebSocket readyState enumeration.\n\t   */\n\t  WebSocket.CONNECTING = 0;\n\t  WebSocket.OPEN = 1;\n\t  WebSocket.CLOSING = 2;\n\t  WebSocket.CLOSED = 3;\n\t\n\t  WebSocket.__flash = null;\n\t  WebSocket.__instances = {};\n\t  WebSocket.__tasks = [];\n\t  WebSocket.__nextId = 0;\n\t  \n\t  /**\n\t   * Load a new flash security policy file.\n\t   * @param {string} url\n\t   */\n\t  WebSocket.loadFlashPolicyFile = function(url){\n\t    WebSocket.__addTask(function() {\n\t      WebSocket.__flash.loadManualPolicyFile(url);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.\n\t   */\n\t  WebSocket.__initialize = function() {\n\t    if (WebSocket.__flash) return;\n\t    \n\t    if (WebSocket.__swfLocation) {\n\t      // For backword compatibility.\n\t      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;\n\t    }\n\t    if (!window.WEB_SOCKET_SWF_LOCATION) {\n\t      console.error(\"[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf\");\n\t      return;\n\t    }\n\t    var container = document.createElement(\"div\");\n\t    container.id = \"webSocketContainer\";\n\t    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents\n\t    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).\n\t    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash\n\t    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is\n\t    // the best we can do as far as we know now.\n\t    container.style.position = \"absolute\";\n\t    if (WebSocket.__isFlashLite()) {\n\t      container.style.left = \"0px\";\n\t      container.style.top = \"0px\";\n\t    } else {\n\t      container.style.left = \"-100px\";\n\t      container.style.top = \"-100px\";\n\t    }\n\t    var holder = document.createElement(\"div\");\n\t    holder.id = \"webSocketFlash\";\n\t    container.appendChild(holder);\n\t    document.body.appendChild(container);\n\t    // See this article for hasPriority:\n\t    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\n\t    swfobject.embedSWF(\n\t      WEB_SOCKET_SWF_LOCATION,\n\t      \"webSocketFlash\",\n\t      \"1\" /* width */,\n\t      \"1\" /* height */,\n\t      \"10.0.0\" /* SWF version */,\n\t      null,\n\t      null,\n\t      {hasPriority: true, swliveconnect : true, allowScriptAccess: \"always\"},\n\t      null,\n\t      function(e) {\n\t        if (!e.success) {\n\t          console.error(\"[WebSocket] swfobject.embedSWF failed\");\n\t        }\n\t      });\n\t  };\n\t  \n\t  /**\n\t   * Called by Flash to notify JS that it's fully loaded and ready\n\t   * for communication.\n\t   */\n\t  WebSocket.__onFlashInitialized = function() {\n\t    // We need to set a timeout here to avoid round-trip calls\n\t    // to flash during the initialization process.\n\t    setTimeout(function() {\n\t      WebSocket.__flash = document.getElementById(\"webSocketFlash\");\n\t      WebSocket.__flash.setCallerUrl(location.href);\n\t      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);\n\t      for (var i = 0; i < WebSocket.__tasks.length; ++i) {\n\t        WebSocket.__tasks[i]();\n\t      }\n\t      WebSocket.__tasks = [];\n\t    }, 0);\n\t  };\n\t  \n\t  /**\n\t   * Called by Flash to notify WebSockets events are fired.\n\t   */\n\t  WebSocket.__onFlashEvent = function() {\n\t    setTimeout(function() {\n\t      try {\n\t        // Gets events using receiveEvents() instead of getting it from event object\n\t        // of Flash event. This is to make sure to keep message order.\n\t        // It seems sometimes Flash events don't arrive in the same order as they are sent.\n\t        var events = WebSocket.__flash.receiveEvents();\n\t        for (var i = 0; i < events.length; ++i) {\n\t          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);\n\t        }\n\t      } catch (e) {\n\t        console.error(e);\n\t      }\n\t    }, 0);\n\t    return true;\n\t  };\n\t  \n\t  // Called by Flash.\n\t  WebSocket.__log = function(message) {\n\t    console.log(decodeURIComponent(message));\n\t  };\n\t  \n\t  // Called by Flash.\n\t  WebSocket.__error = function(message) {\n\t    console.error(decodeURIComponent(message));\n\t  };\n\t  \n\t  WebSocket.__addTask = function(task) {\n\t    if (WebSocket.__flash) {\n\t      task();\n\t    } else {\n\t      WebSocket.__tasks.push(task);\n\t    }\n\t  };\n\t  \n\t  /**\n\t   * Test if the browser is running flash lite.\n\t   * @return {boolean} True if flash lite is running, false otherwise.\n\t   */\n\t  WebSocket.__isFlashLite = function() {\n\t    if (!window.navigator || !window.navigator.mimeTypes) {\n\t      return false;\n\t    }\n\t    var mimeType = window.navigator.mimeTypes[\"application/x-shockwave-flash\"];\n\t    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {\n\t      return false;\n\t    }\n\t    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;\n\t  };\n\t  \n\t  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {\n\t    if (window.addEventListener) {\n\t      window.addEventListener(\"load\", function(){\n\t        WebSocket.__initialize();\n\t      }, false);\n\t    } else {\n\t      window.attachEvent(\"onload\", function(){\n\t        WebSocket.__initialize();\n\t      });\n\t    }\n\t  }\n\t  \n\t})();\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  exports.XHR = XHR;\n\t\n\t  /**\n\t   * XHR constructor\n\t   *\n\t   * @costructor\n\t   * @api public\n\t   */\n\t\n\t  function XHR (socket) {\n\t    if (!socket) return;\n\t\n\t    io.Transport.apply(this, arguments);\n\t    this.sendBuffer = [];\n\t  };\n\t\n\t  /**\n\t   * Inherits from Transport.\n\t   */\n\t\n\t  io.util.inherit(XHR, io.Transport);\n\t\n\t  /**\n\t   * Establish a connection\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  XHR.prototype.open = function () {\n\t    this.socket.setBuffer(false);\n\t    this.onOpen();\n\t    this.get();\n\t\n\t    // we need to make sure the request succeeds since we have no indication\n\t    // whether the request opened or not until it succeeded.\n\t    this.setCloseTimeout();\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Check if we need to send data to the Socket.IO server, if we have data in our\n\t   * buffer we encode it and forward it to the `post` method.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  XHR.prototype.payload = function (payload) {\n\t    var msgs = [];\n\t\n\t    for (var i = 0, l = payload.length; i < l; i++) {\n\t      msgs.push(io.parser.encodePacket(payload[i]));\n\t    }\n\t\n\t    this.send(io.parser.encodePayload(msgs));\n\t  };\n\t\n\t  /**\n\t   * Send data to the Socket.IO server.\n\t   *\n\t   * @param data The message\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  XHR.prototype.send = function (data) {\n\t    this.post(data);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Posts a encoded message to the Socket.IO server.\n\t   *\n\t   * @param {String} data A encoded message.\n\t   * @api private\n\t   */\n\t\n\t  function empty () { };\n\t\n\t  XHR.prototype.post = function (data) {\n\t    var self = this;\n\t    this.socket.setBuffer(true);\n\t\n\t    function stateChange () {\n\t      if (this.readyState == 4) {\n\t        this.onreadystatechange = empty;\n\t        self.posting = false;\n\t\n\t        if (this.status == 200){\n\t          self.socket.setBuffer(false);\n\t        } else {\n\t          self.onClose();\n\t        }\n\t      }\n\t    }\n\t\n\t    function onload () {\n\t      this.onload = empty;\n\t      self.socket.setBuffer(false);\n\t    };\n\t\n\t    this.sendXHR = this.request('POST');\n\t\n\t    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\n\t      this.sendXHR.onload = this.sendXHR.onerror = onload;\n\t    } else {\n\t      this.sendXHR.onreadystatechange = stateChange;\n\t    }\n\t\n\t    this.sendXHR.send(data);\n\t  };\n\t\n\t  /**\n\t   * Disconnects the established `XHR` connection.\n\t   *\n\t   * @returns {Transport}\n\t   * @api public\n\t   */\n\t\n\t  XHR.prototype.close = function () {\n\t    this.onClose();\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Generates a configured XHR request\n\t   *\n\t   * @param {String} url The url that needs to be requested.\n\t   * @param {String} method The method the request should use.\n\t   * @returns {XMLHttpRequest}\n\t   * @api private\n\t   */\n\t\n\t  XHR.prototype.request = function (method) {\n\t    var req = io.util.request(this.socket.isXDomain())\n\t      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\n\t\n\t    req.open(method || 'GET', this.prepareUrl() + query, true);\n\t\n\t    if (method == 'POST') {\n\t      try {\n\t        if (req.setRequestHeader) {\n\t          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n\t        } else {\n\t          // XDomainRequest\n\t          req.contentType = 'text/plain';\n\t        }\n\t      } catch (e) {}\n\t    }\n\t\n\t    return req;\n\t  };\n\t\n\t  /**\n\t   * Returns the scheme to use for the transport URLs.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  XHR.prototype.scheme = function () {\n\t    return this.socket.options.secure ? 'https' : 'http';\n\t  };\n\t\n\t  /**\n\t   * Check if the XHR transports are supported\n\t   *\n\t   * @param {Boolean} xdomain Check if we support cross domain requests.\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  XHR.check = function (socket, xdomain) {\n\t    try {\n\t      var request = io.util.request(xdomain),\n\t          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),\n\t          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),\n\t          isXProtocol = (global.location && socketProtocol != global.location.protocol);\n\t      if (request && !(usesXDomReq && isXProtocol)) {\n\t        return true;\n\t      }\n\t    } catch(e) {}\n\t\n\t    return false;\n\t  };\n\t\n\t  /**\n\t   * Check if the XHR transport supports cross domain requests.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  XHR.xdomainCheck = function (socket) {\n\t    return XHR.check(socket, true);\n\t  };\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports.htmlfile = HTMLFile;\n\t\n\t  /**\n\t   * The HTMLFile transport creates a `forever iframe` based transport\n\t   * for Internet Explorer. Regular forever iframe implementations will \n\t   * continuously trigger the browsers buzy indicators. If the forever iframe\n\t   * is created inside a `htmlfile` these indicators will not be trigged.\n\t   *\n\t   * @constructor\n\t   * @extends {io.Transport.XHR}\n\t   * @api public\n\t   */\n\t\n\t  function HTMLFile (socket) {\n\t    io.Transport.XHR.apply(this, arguments);\n\t  };\n\t\n\t  /**\n\t   * Inherits from XHR transport.\n\t   */\n\t\n\t  io.util.inherit(HTMLFile, io.Transport.XHR);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  HTMLFile.prototype.name = 'htmlfile';\n\t\n\t  /**\n\t   * Creates a new Ac...eX `htmlfile` with a forever loading iframe\n\t   * that can be used to listen to messages. Inside the generated\n\t   * `htmlfile` a reference will be made to the HTMLFile transport.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  HTMLFile.prototype.get = function () {\n\t    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\n\t    this.doc.open();\n\t    this.doc.write('<html></html>');\n\t    this.doc.close();\n\t    this.doc.parentWindow.s = this;\n\t\n\t    var iframeC = this.doc.createElement('div');\n\t    iframeC.className = 'socketio';\n\t\n\t    this.doc.body.appendChild(iframeC);\n\t    this.iframe = this.doc.createElement('iframe');\n\t\n\t    iframeC.appendChild(this.iframe);\n\t\n\t    var self = this\n\t      , query = io.util.query(this.socket.options.query, 't='+ +new Date);\n\t\n\t    this.iframe.src = this.prepareUrl() + query;\n\t\n\t    io.util.on(window, 'unload', function () {\n\t      self.destroy();\n\t    });\n\t  };\n\t\n\t  /**\n\t   * The Socket.IO server will write script tags inside the forever\n\t   * iframe, this function will be used as callback for the incoming\n\t   * information.\n\t   *\n\t   * @param {String} data The message\n\t   * @param {document} doc Reference to the context\n\t   * @api private\n\t   */\n\t\n\t  HTMLFile.prototype._ = function (data, doc) {\n\t    // unescape all forward slashes. see GH-1251\n\t    data = data.replace(/\\\\\\//g, '/');\n\t    this.onData(data);\n\t    try {\n\t      var script = doc.getElementsByTagName('script')[0];\n\t      script.parentNode.removeChild(script);\n\t    } catch (e) { }\n\t  };\n\t\n\t  /**\n\t   * Destroy the established connection, iframe and `htmlfile`.\n\t   * And calls the `CollectGarbage` function of Internet Explorer\n\t   * to release the memory.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  HTMLFile.prototype.destroy = function () {\n\t    if (this.iframe){\n\t      try {\n\t        this.iframe.src = 'about:blank';\n\t      } catch(e){}\n\t\n\t      this.doc = null;\n\t      this.iframe.parentNode.removeChild(this.iframe);\n\t      this.iframe = null;\n\t\n\t      CollectGarbage();\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Disconnects the established connection.\n\t   *\n\t   * @returns {Transport} Chaining.\n\t   * @api public\n\t   */\n\t\n\t  HTMLFile.prototype.close = function () {\n\t    this.destroy();\n\t    return io.Transport.XHR.prototype.close.call(this);\n\t  };\n\t\n\t  /**\n\t   * Checks if the browser supports this transport. The browser\n\t   * must have an `Ac...eXObject` implementation.\n\t   *\n\t   * @return {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  HTMLFile.check = function (socket) {\n\t    if (typeof window != \"undefined\" && (['Active'].concat('Object').join('X')) in window){\n\t      try {\n\t        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\n\t        return a && io.Transport.XHR.check(socket);\n\t      } catch(e){}\n\t    }\n\t    return false;\n\t  };\n\t\n\t  /**\n\t   * Check if cross domain requests are supported.\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  HTMLFile.xdomainCheck = function () {\n\t    // we can probably do handling for sub-domains, we should\n\t    // test that it's cross domain but a subdomain here\n\t    return false;\n\t  };\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('htmlfile');\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports['xhr-polling'] = XHRPolling;\n\t\n\t  /**\n\t   * The XHR-polling transport uses long polling XHR requests to create a\n\t   * \"persistent\" connection with the server.\n\t   *\n\t   * @constructor\n\t   * @api public\n\t   */\n\t\n\t  function XHRPolling () {\n\t    io.Transport.XHR.apply(this, arguments);\n\t  };\n\t\n\t  /**\n\t   * Inherits from XHR transport.\n\t   */\n\t\n\t  io.util.inherit(XHRPolling, io.Transport.XHR);\n\t\n\t  /**\n\t   * Merge the properties from XHR transport\n\t   */\n\t\n\t  io.util.merge(XHRPolling, io.Transport.XHR);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  XHRPolling.prototype.name = 'xhr-polling';\n\t\n\t  /**\n\t   * Indicates whether heartbeats is enabled for this transport\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  XHRPolling.prototype.heartbeats = function () {\n\t    return false;\n\t  };\n\t\n\t  /** \n\t   * Establish a connection, for iPhone and Android this will be done once the page\n\t   * is loaded.\n\t   *\n\t   * @returns {Transport} Chaining.\n\t   * @api public\n\t   */\n\t\n\t  XHRPolling.prototype.open = function () {\n\t    var self = this;\n\t\n\t    io.Transport.XHR.prototype.open.call(self);\n\t    return false;\n\t  };\n\t\n\t  /**\n\t   * Starts a XHR request to wait for incoming messages.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  function empty () {};\n\t\n\t  XHRPolling.prototype.get = function () {\n\t    if (!this.isOpen) return;\n\t\n\t    var self = this;\n\t\n\t    function stateChange () {\n\t      if (this.readyState == 4) {\n\t        this.onreadystatechange = empty;\n\t\n\t        if (this.status == 200) {\n\t          self.onData(this.responseText);\n\t          self.get();\n\t        } else {\n\t          self.onClose();\n\t        }\n\t      }\n\t    };\n\t\n\t    function onload () {\n\t      this.onload = empty;\n\t      this.onerror = empty;\n\t      self.retryCounter = 1;\n\t      self.onData(this.responseText);\n\t      self.get();\n\t    };\n\t\n\t    function onerror () {\n\t      self.retryCounter ++;\n\t      if(!self.retryCounter || self.retryCounter > 3) {\n\t        self.onClose();  \n\t      } else {\n\t        self.get();\n\t      }\n\t    };\n\t\n\t    this.xhr = this.request();\n\t\n\t    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\n\t      this.xhr.onload = onload;\n\t      this.xhr.onerror = onerror;\n\t    } else {\n\t      this.xhr.onreadystatechange = stateChange;\n\t    }\n\t\n\t    this.xhr.send(null);\n\t  };\n\t\n\t  /**\n\t   * Handle the unclean close behavior.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  XHRPolling.prototype.onClose = function () {\n\t    io.Transport.XHR.prototype.onClose.call(this);\n\t\n\t    if (this.xhr) {\n\t      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\n\t      try {\n\t        this.xhr.abort();\n\t      } catch(e){}\n\t      this.xhr = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Webkit based browsers show a infinit spinner when you start a XHR request\n\t   * before the browsers onload event is called so we need to defer opening of\n\t   * the transport until the onload event is called. Wrapping the cb in our\n\t   * defer method solve this.\n\t   *\n\t   * @param {Socket} socket The socket instance that needs a transport\n\t   * @param {Function} fn The callback\n\t   * @api private\n\t   */\n\t\n\t  XHRPolling.prototype.ready = function (socket, fn) {\n\t    var self = this;\n\t\n\t    io.util.defer(function () {\n\t      fn.call(self);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('xhr-polling');\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t\n\t/**\n\t * socket.io\n\t * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n\t * MIT Licensed\n\t */\n\t\n\t(function (exports, io, global) {\n\t  /**\n\t   * There is a way to hide the loading indicator in Firefox. If you create and\n\t   * remove a iframe it will stop showing the current loading indicator.\n\t   * Unfortunately we can't feature detect that and UA sniffing is evil.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  var indicator = global.document && \"MozAppearance\" in\n\t    global.document.documentElement.style;\n\t\n\t  /**\n\t   * Expose constructor.\n\t   */\n\t\n\t  exports['jsonp-polling'] = JSONPPolling;\n\t\n\t  /**\n\t   * The JSONP transport creates an persistent connection by dynamically\n\t   * inserting a script tag in the page. This script tag will receive the\n\t   * information of the Socket.IO server. When new information is received\n\t   * it creates a new script tag for the new data stream.\n\t   *\n\t   * @constructor\n\t   * @extends {io.Transport.xhr-polling}\n\t   * @api public\n\t   */\n\t\n\t  function JSONPPolling (socket) {\n\t    io.Transport['xhr-polling'].apply(this, arguments);\n\t\n\t    this.index = io.j.length;\n\t\n\t    var self = this;\n\t\n\t    io.j.push(function (msg) {\n\t      self._(msg);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Inherits from XHR polling transport.\n\t   */\n\t\n\t  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);\n\t\n\t  /**\n\t   * Transport name\n\t   *\n\t   * @api public\n\t   */\n\t\n\t  JSONPPolling.prototype.name = 'jsonp-polling';\n\t\n\t  /**\n\t   * Posts a encoded message to the Socket.IO server using an iframe.\n\t   * The iframe is used because script tags can create POST based requests.\n\t   * The iframe is positioned outside of the view so the user does not\n\t   * notice it's existence.\n\t   *\n\t   * @param {String} data A encoded message.\n\t   * @api private\n\t   */\n\t\n\t  JSONPPolling.prototype.post = function (data) {\n\t    var self = this\n\t      , query = io.util.query(\n\t             this.socket.options.query\n\t          , 't='+ (+new Date) + '&i=' + this.index\n\t        );\n\t\n\t    if (!this.form) {\n\t      var form = document.createElement('form')\n\t        , area = document.createElement('textarea')\n\t        , id = this.iframeId = 'socketio_iframe_' + this.index\n\t        , iframe;\n\t\n\t      form.className = 'socketio';\n\t      form.style.position = 'absolute';\n\t      form.style.top = '0px';\n\t      form.style.left = '0px';\n\t      form.style.display = 'none';\n\t      form.target = id;\n\t      form.method = 'POST';\n\t      form.setAttribute('accept-charset', 'utf-8');\n\t      area.name = 'd';\n\t      form.appendChild(area);\n\t      document.body.appendChild(form);\n\t\n\t      this.form = form;\n\t      this.area = area;\n\t    }\n\t\n\t    this.form.action = this.prepareUrl() + query;\n\t\n\t    function complete () {\n\t      initIframe();\n\t      self.socket.setBuffer(false);\n\t    };\n\t\n\t    function initIframe () {\n\t      if (self.iframe) {\n\t        self.form.removeChild(self.iframe);\n\t      }\n\t\n\t      try {\n\t        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n\t        iframe = document.createElement('<iframe name=\"'+ self.iframeId +'\">');\n\t      } catch (e) {\n\t        iframe = document.createElement('iframe');\n\t        iframe.name = self.iframeId;\n\t      }\n\t\n\t      iframe.id = self.iframeId;\n\t\n\t      self.form.appendChild(iframe);\n\t      self.iframe = iframe;\n\t    };\n\t\n\t    initIframe();\n\t\n\t    // we temporarily stringify until we figure out how to prevent\n\t    // browsers from turning `\\n` into `\\r\\n` in form inputs\n\t    this.area.value = io.JSON.stringify(data);\n\t\n\t    try {\n\t      this.form.submit();\n\t    } catch(e) {}\n\t\n\t    if (this.iframe.attachEvent) {\n\t      iframe.onreadystatechange = function () {\n\t        if (self.iframe.readyState == 'complete') {\n\t          complete();\n\t        }\n\t      };\n\t    } else {\n\t      this.iframe.onload = complete;\n\t    }\n\t\n\t    this.socket.setBuffer(true);\n\t  };\n\t\n\t  /**\n\t   * Creates a new JSONP poll that can be used to listen\n\t   * for messages from the Socket.IO server.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  JSONPPolling.prototype.get = function () {\n\t    var self = this\n\t      , script = document.createElement('script')\n\t      , query = io.util.query(\n\t             this.socket.options.query\n\t          , 't='+ (+new Date) + '&i=' + this.index\n\t        );\n\t\n\t    if (this.script) {\n\t      this.script.parentNode.removeChild(this.script);\n\t      this.script = null;\n\t    }\n\t\n\t    script.async = true;\n\t    script.src = this.prepareUrl() + query;\n\t    script.onerror = function () {\n\t      self.onClose();\n\t    };\n\t\n\t    var insertAt = document.getElementsByTagName('script')[0];\n\t    insertAt.parentNode.insertBefore(script, insertAt);\n\t    this.script = script;\n\t\n\t    if (indicator) {\n\t      setTimeout(function () {\n\t        var iframe = document.createElement('iframe');\n\t        document.body.appendChild(iframe);\n\t        document.body.removeChild(iframe);\n\t      }, 100);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Callback function for the incoming message stream from the Socket.IO server.\n\t   *\n\t   * @param {String} data The message\n\t   * @api private\n\t   */\n\t\n\t  JSONPPolling.prototype._ = function (msg) {\n\t    this.onData(msg);\n\t    if (this.isOpen) {\n\t      this.get();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * The indicator hack only works after onload\n\t   *\n\t   * @param {Socket} socket The socket instance that needs a transport\n\t   * @param {Function} fn The callback\n\t   * @api private\n\t   */\n\t\n\t  JSONPPolling.prototype.ready = function (socket, fn) {\n\t    var self = this;\n\t    if (!indicator) return fn.call(this);\n\t\n\t    io.util.load(function () {\n\t      fn.call(self);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Checks if browser supports this transport.\n\t   *\n\t   * @return {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  JSONPPolling.check = function () {\n\t    return 'document' in global;\n\t  };\n\t\n\t  /**\n\t   * Check if cross domain requests are supported\n\t   *\n\t   * @returns {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  JSONPPolling.xdomainCheck = function () {\n\t    return true;\n\t  };\n\t\n\t  /**\n\t   * Add the transport to your public io.transports array.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  io.transports.push('jsonp-polling');\n\t\n\t})(\n\t    'undefined' != typeof io ? io.Transport : module.exports\n\t  , 'undefined' != typeof io ? io : module.parent.exports\n\t  , this\n\t);\n\t\n\tif (true) {\n\t  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return io; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)(module)))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// vim:ts=4:sts=4:sw=4:\n\t/*!\n\t *\n\t * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n\t * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n\t *\n\t * With parts by Tyler Close\n\t * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n\t * at http://www.opensource.org/licenses/mit-license.html\n\t * Forked at ref_send.js version: 2009-05-11\n\t *\n\t * With parts by Mark Miller\n\t * Copyright (C) 2011 Google Inc.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t */\n\t\n\t(function (definition) {\n\t    \"use strict\";\n\t\n\t    // This file will function properly as a <script> tag, or a module\n\t    // using CommonJS and NodeJS or RequireJS module formats.  In\n\t    // Common/Node/RequireJS, the module exports the Q API and when\n\t    // executed as a simple <script>, it creates a Q global instead.\n\t\n\t    // Montage Require\n\t    if (typeof bootstrap === \"function\") {\n\t        bootstrap(\"promise\", definition);\n\t\n\t    // CommonJS\n\t    } else if (true) {\n\t        module.exports = definition();\n\t\n\t    // RequireJS\n\t    } else if (typeof define === \"function\" && define.amd) {\n\t        define(definition);\n\t\n\t    // SES (Secure EcmaScript)\n\t    } else if (typeof ses !== \"undefined\") {\n\t        if (!ses.ok()) {\n\t            return;\n\t        } else {\n\t            ses.makeQ = definition;\n\t        }\n\t\n\t    // <script>\n\t    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n\t        // Prefer window over self for add-on scripts. Use self for\n\t        // non-windowed contexts.\n\t        var global = typeof window !== \"undefined\" ? window : self;\n\t\n\t        // Get the `window` object, save the previous Q global\n\t        // and initialize Q as a global.\n\t        var previousQ = global.Q;\n\t        global.Q = definition();\n\t\n\t        // Add a noConflict function so Q can be removed from the\n\t        // global namespace.\n\t        global.Q.noConflict = function () {\n\t            global.Q = previousQ;\n\t            return this;\n\t        };\n\t\n\t    } else {\n\t        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n\t    }\n\t\n\t})(function () {\n\t\"use strict\";\n\t\n\tvar hasStacks = false;\n\ttry {\n\t    throw new Error();\n\t} catch (e) {\n\t    hasStacks = !!e.stack;\n\t}\n\t\n\t// All code after this point will be filtered from stack traces reported\n\t// by Q.\n\tvar qStartingLine = captureLine();\n\tvar qFileName;\n\t\n\t// shims\n\t\n\t// used for fallback in \"allResolved\"\n\tvar noop = function () {};\n\t\n\t// Use the fastest possible means to execute a task in a future turn\n\t// of the event loop.\n\tvar nextTick =(function () {\n\t    // linked list of tasks (single, with head node)\n\t    var head = {task: void 0, next: null};\n\t    var tail = head;\n\t    var flushing = false;\n\t    var requestTick = void 0;\n\t    var isNodeJS = false;\n\t    // queue for late tasks, used by unhandled rejection tracking\n\t    var laterQueue = [];\n\t\n\t    function flush() {\n\t        /* jshint loopfunc: true */\n\t        var task, domain;\n\t\n\t        while (head.next) {\n\t            head = head.next;\n\t            task = head.task;\n\t            head.task = void 0;\n\t            domain = head.domain;\n\t\n\t            if (domain) {\n\t                head.domain = void 0;\n\t                domain.enter();\n\t            }\n\t            runSingle(task, domain);\n\t\n\t        }\n\t        while (laterQueue.length) {\n\t            task = laterQueue.pop();\n\t            runSingle(task);\n\t        }\n\t        flushing = false;\n\t    }\n\t    // runs a single function in the async queue\n\t    function runSingle(task, domain) {\n\t        try {\n\t            task();\n\t\n\t        } catch (e) {\n\t            if (isNodeJS) {\n\t                // In node, uncaught exceptions are considered fatal errors.\n\t                // Re-throw them synchronously to interrupt flushing!\n\t\n\t                // Ensure continuation if the uncaught exception is suppressed\n\t                // listening \"uncaughtException\" events (as domains does).\n\t                // Continue in next event to avoid tick recursion.\n\t                if (domain) {\n\t                    domain.exit();\n\t                }\n\t                setTimeout(flush, 0);\n\t                if (domain) {\n\t                    domain.enter();\n\t                }\n\t\n\t                throw e;\n\t\n\t            } else {\n\t                // In browsers, uncaught exceptions are not fatal.\n\t                // Re-throw them asynchronously to avoid slow-downs.\n\t                setTimeout(function () {\n\t                    throw e;\n\t                }, 0);\n\t            }\n\t        }\n\t\n\t        if (domain) {\n\t            domain.exit();\n\t        }\n\t    }\n\t\n\t    nextTick = function (task) {\n\t        tail = tail.next = {\n\t            task: task,\n\t            domain: isNodeJS && process.domain,\n\t            next: null\n\t        };\n\t\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t\n\t    if (typeof process === \"object\" &&\n\t        process.toString() === \"[object process]\" && process.nextTick) {\n\t        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n\t        // To see through fake Node environments:\n\t        // * Mocha test runner - exposes a `process` global without a `nextTick`\n\t        // * Browserify - exposes a `process.nexTick` function that uses\n\t        //   `setTimeout`. In this case `setImmediate` is preferred because\n\t        //    it is faster. Browserify's `process.toString()` yields\n\t        //   \"[object Object]\", while in a real Node environment\n\t        //   `process.nextTick()` yields \"[object process]\".\n\t        isNodeJS = true;\n\t\n\t        requestTick = function () {\n\t            process.nextTick(flush);\n\t        };\n\t\n\t    } else if (typeof setImmediate === \"function\") {\n\t        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n\t        if (typeof window !== \"undefined\") {\n\t            requestTick = setImmediate.bind(window, flush);\n\t        } else {\n\t            requestTick = function () {\n\t                setImmediate(flush);\n\t            };\n\t        }\n\t\n\t    } else if (typeof MessageChannel !== \"undefined\") {\n\t        // modern browsers\n\t        // http://www.nonblocking.io/2011/06/windownexttick.html\n\t        var channel = new MessageChannel();\n\t        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n\t        // working message ports the first time a page loads.\n\t        channel.port1.onmessage = function () {\n\t            requestTick = requestPortTick;\n\t            channel.port1.onmessage = flush;\n\t            flush();\n\t        };\n\t        var requestPortTick = function () {\n\t            // Opera requires us to provide a message payload, regardless of\n\t            // whether we use it.\n\t            channel.port2.postMessage(0);\n\t        };\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t            requestPortTick();\n\t        };\n\t\n\t    } else {\n\t        // old browsers\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t        };\n\t    }\n\t    // runs a task after all other tasks have been run\n\t    // this is useful for unhandled rejection tracking that needs to happen\n\t    // after all `then`d tasks have been run.\n\t    nextTick.runAfter = function (task) {\n\t        laterQueue.push(task);\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t    return nextTick;\n\t})();\n\t\n\t// Attempt to make generics safe in the face of downstream\n\t// modifications.\n\t// There is no situation where this is necessary.\n\t// If you need a security guarantee, these primordials need to be\n\t// deeply frozen anyway, and if you dont need a security guarantee,\n\t// this is just plain paranoid.\n\t// However, this **might** have the nice side-effect of reducing the size of\n\t// the minified code by reducing x.call() to merely x()\n\t// See Mark Millers explanation of what this does.\n\t// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n\tvar call = Function.call;\n\tfunction uncurryThis(f) {\n\t    return function () {\n\t        return call.apply(f, arguments);\n\t    };\n\t}\n\t// This is equivalent, but slower:\n\t// uncurryThis = Function_bind.bind(Function_bind.call);\n\t// http://jsperf.com/uncurrythis\n\t\n\tvar array_slice = uncurryThis(Array.prototype.slice);\n\t\n\tvar array_reduce = uncurryThis(\n\t    Array.prototype.reduce || function (callback, basis) {\n\t        var index = 0,\n\t            length = this.length;\n\t        // concerning the initial value, if one is not provided\n\t        if (arguments.length === 1) {\n\t            // seek to the first value in the array, accounting\n\t            // for the possibility that is is a sparse array\n\t            do {\n\t                if (index in this) {\n\t                    basis = this[index++];\n\t                    break;\n\t                }\n\t                if (++index >= length) {\n\t                    throw new TypeError();\n\t                }\n\t            } while (1);\n\t        }\n\t        // reduce\n\t        for (; index < length; index++) {\n\t            // account for the possibility that the array is sparse\n\t            if (index in this) {\n\t                basis = callback(basis, this[index], index);\n\t            }\n\t        }\n\t        return basis;\n\t    }\n\t);\n\t\n\tvar array_indexOf = uncurryThis(\n\t    Array.prototype.indexOf || function (value) {\n\t        // not a very good shim, but good enough for our one use of it\n\t        for (var i = 0; i < this.length; i++) {\n\t            if (this[i] === value) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t);\n\t\n\tvar array_map = uncurryThis(\n\t    Array.prototype.map || function (callback, thisp) {\n\t        var self = this;\n\t        var collect = [];\n\t        array_reduce(self, function (undefined, value, index) {\n\t            collect.push(callback.call(thisp, value, index, self));\n\t        }, void 0);\n\t        return collect;\n\t    }\n\t);\n\t\n\tvar object_create = Object.create || function (prototype) {\n\t    function Type() { }\n\t    Type.prototype = prototype;\n\t    return new Type();\n\t};\n\t\n\tvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\t\n\tvar object_keys = Object.keys || function (object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t        if (object_hasOwnProperty(object, key)) {\n\t            keys.push(key);\n\t        }\n\t    }\n\t    return keys;\n\t};\n\t\n\tvar object_toString = uncurryThis(Object.prototype.toString);\n\t\n\tfunction isObject(value) {\n\t    return value === Object(value);\n\t}\n\t\n\t// generator related shims\n\t\n\t// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n\tfunction isStopIteration(exception) {\n\t    return (\n\t        object_toString(exception) === \"[object StopIteration]\" ||\n\t        exception instanceof QReturnValue\n\t    );\n\t}\n\t\n\t// FIXME: Remove this helper and Q.return once ES6 generators are in\n\t// SpiderMonkey.\n\tvar QReturnValue;\n\tif (typeof ReturnValue !== \"undefined\") {\n\t    QReturnValue = ReturnValue;\n\t} else {\n\t    QReturnValue = function (value) {\n\t        this.value = value;\n\t    };\n\t}\n\t\n\t// long stack traces\n\t\n\tvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\t\n\tfunction makeStackTraceLong(error, promise) {\n\t    // If possible, transform the error stack trace by removing Node and Q\n\t    // cruft, then concatenating with the stack trace of `promise`. See #57.\n\t    if (hasStacks &&\n\t        promise.stack &&\n\t        typeof error === \"object\" &&\n\t        error !== null &&\n\t        error.stack &&\n\t        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n\t    ) {\n\t        var stacks = [];\n\t        for (var p = promise; !!p; p = p.source) {\n\t            if (p.stack) {\n\t                stacks.unshift(p.stack);\n\t            }\n\t        }\n\t        stacks.unshift(error.stack);\n\t\n\t        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n\t        error.stack = filterStackString(concatedStacks);\n\t    }\n\t}\n\t\n\tfunction filterStackString(stackString) {\n\t    var lines = stackString.split(\"\\n\");\n\t    var desiredLines = [];\n\t    for (var i = 0; i < lines.length; ++i) {\n\t        var line = lines[i];\n\t\n\t        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n\t            desiredLines.push(line);\n\t        }\n\t    }\n\t    return desiredLines.join(\"\\n\");\n\t}\n\t\n\tfunction isNodeFrame(stackLine) {\n\t    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n\t           stackLine.indexOf(\"(node.js:\") !== -1;\n\t}\n\t\n\tfunction getFileNameAndLineNumber(stackLine) {\n\t    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n\t    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n\t    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n\t    if (attempt1) {\n\t        return [attempt1[1], Number(attempt1[2])];\n\t    }\n\t\n\t    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n\t    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n\t    if (attempt2) {\n\t        return [attempt2[1], Number(attempt2[2])];\n\t    }\n\t\n\t    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n\t    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n\t    if (attempt3) {\n\t        return [attempt3[1], Number(attempt3[2])];\n\t    }\n\t}\n\t\n\tfunction isInternalFrame(stackLine) {\n\t    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\t\n\t    if (!fileNameAndLineNumber) {\n\t        return false;\n\t    }\n\t\n\t    var fileName = fileNameAndLineNumber[0];\n\t    var lineNumber = fileNameAndLineNumber[1];\n\t\n\t    return fileName === qFileName &&\n\t        lineNumber >= qStartingLine &&\n\t        lineNumber <= qEndingLine;\n\t}\n\t\n\t// discover own file name and line number range for filtering stack\n\t// traces\n\tfunction captureLine() {\n\t    if (!hasStacks) {\n\t        return;\n\t    }\n\t\n\t    try {\n\t        throw new Error();\n\t    } catch (e) {\n\t        var lines = e.stack.split(\"\\n\");\n\t        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n\t        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n\t        if (!fileNameAndLineNumber) {\n\t            return;\n\t        }\n\t\n\t        qFileName = fileNameAndLineNumber[0];\n\t        return fileNameAndLineNumber[1];\n\t    }\n\t}\n\t\n\tfunction deprecate(callback, name, alternative) {\n\t    return function () {\n\t        if (typeof console !== \"undefined\" &&\n\t            typeof console.warn === \"function\") {\n\t            console.warn(name + \" is deprecated, use \" + alternative +\n\t                         \" instead.\", new Error(\"\").stack);\n\t        }\n\t        return callback.apply(callback, arguments);\n\t    };\n\t}\n\t\n\t// end of shims\n\t// beginning of real work\n\t\n\t/**\n\t * Constructs a promise for an immediate reference, passes promises through, or\n\t * coerces promises from different systems.\n\t * @param value immediate reference or promise\n\t */\n\tfunction Q(value) {\n\t    // If the object is already a Promise, return it directly.  This enables\n\t    // the resolve function to both be used to created references from objects,\n\t    // but to tolerably coerce non-promises to promises.\n\t    if (value instanceof Promise) {\n\t        return value;\n\t    }\n\t\n\t    // assimilate thenables\n\t    if (isPromiseAlike(value)) {\n\t        return coerce(value);\n\t    } else {\n\t        return fulfill(value);\n\t    }\n\t}\n\tQ.resolve = Q;\n\t\n\t/**\n\t * Performs a task in a future turn of the event loop.\n\t * @param {Function} task\n\t */\n\tQ.nextTick = nextTick;\n\t\n\t/**\n\t * Controls whether or not long stack traces will be on\n\t */\n\tQ.longStackSupport = false;\n\t\n\t// enable long stacks if Q_DEBUG is set\n\tif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n\t    Q.longStackSupport = true;\n\t}\n\t\n\t/**\n\t * Constructs a {promise, resolve, reject} object.\n\t *\n\t * `resolve` is a callback to invoke with a more resolved value for the\n\t * promise. To fulfill the promise, invoke `resolve` with any value that is\n\t * not a thenable. To reject the promise, invoke `resolve` with a rejected\n\t * thenable, or invoke `reject` with the reason directly. To resolve the\n\t * promise to another thenable, thus putting it in the same state, invoke\n\t * `resolve` with that other thenable.\n\t */\n\tQ.defer = defer;\n\tfunction defer() {\n\t    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n\t    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n\t    // element of the messages array is itself an array of complete arguments to\n\t    // forward to the resolved promise.  We coerce the resolution value to a\n\t    // promise using the `resolve` function because it handles both fully\n\t    // non-thenable values and other thenables gracefully.\n\t    var messages = [], progressListeners = [], resolvedPromise;\n\t\n\t    var deferred = object_create(defer.prototype);\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, operands) {\n\t        var args = array_slice(arguments);\n\t        if (messages) {\n\t            messages.push(args);\n\t            if (op === \"when\" && operands[1]) { // progress operand\n\t                progressListeners.push(operands[1]);\n\t            }\n\t        } else {\n\t            Q.nextTick(function () {\n\t                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n\t            });\n\t        }\n\t    };\n\t\n\t    // XXX deprecated\n\t    promise.valueOf = function () {\n\t        if (messages) {\n\t            return promise;\n\t        }\n\t        var nearerValue = nearer(resolvedPromise);\n\t        if (isPromise(nearerValue)) {\n\t            resolvedPromise = nearerValue; // shorten chain\n\t        }\n\t        return nearerValue;\n\t    };\n\t\n\t    promise.inspect = function () {\n\t        if (!resolvedPromise) {\n\t            return { state: \"pending\" };\n\t        }\n\t        return resolvedPromise.inspect();\n\t    };\n\t\n\t    if (Q.longStackSupport && hasStacks) {\n\t        try {\n\t            throw new Error();\n\t        } catch (e) {\n\t            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n\t            // accessor around; that causes memory leaks as per GH-111. Just\n\t            // reify the stack trace as a string ASAP.\n\t            //\n\t            // At the same time, cut off the first line; it's always just\n\t            // \"[object Promise]\\n\", as per the `toString`.\n\t            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n\t        }\n\t    }\n\t\n\t    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n\t    // consolidating them into `become`, since otherwise we'd create new\n\t    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\t\n\t    function become(newPromise) {\n\t        resolvedPromise = newPromise;\n\t        promise.source = newPromise;\n\t\n\t        array_reduce(messages, function (undefined, message) {\n\t            Q.nextTick(function () {\n\t                newPromise.promiseDispatch.apply(newPromise, message);\n\t            });\n\t        }, void 0);\n\t\n\t        messages = void 0;\n\t        progressListeners = void 0;\n\t    }\n\t\n\t    deferred.promise = promise;\n\t    deferred.resolve = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(Q(value));\n\t    };\n\t\n\t    deferred.fulfill = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(fulfill(value));\n\t    };\n\t    deferred.reject = function (reason) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(reject(reason));\n\t    };\n\t    deferred.notify = function (progress) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        array_reduce(progressListeners, function (undefined, progressListener) {\n\t            Q.nextTick(function () {\n\t                progressListener(progress);\n\t            });\n\t        }, void 0);\n\t    };\n\t\n\t    return deferred;\n\t}\n\t\n\t/**\n\t * Creates a Node-style callback that will resolve or reject the deferred\n\t * promise.\n\t * @returns a nodeback\n\t */\n\tdefer.prototype.makeNodeResolver = function () {\n\t    var self = this;\n\t    return function (error, value) {\n\t        if (error) {\n\t            self.reject(error);\n\t        } else if (arguments.length > 2) {\n\t            self.resolve(array_slice(arguments, 1));\n\t        } else {\n\t            self.resolve(value);\n\t        }\n\t    };\n\t};\n\t\n\t/**\n\t * @param resolver {Function} a function that returns nothing and accepts\n\t * the resolve, reject, and notify functions for a deferred.\n\t * @returns a promise that may be resolved with the given resolve and reject\n\t * functions, or rejected by a thrown exception in resolver\n\t */\n\tQ.Promise = promise; // ES6\n\tQ.promise = promise;\n\tfunction promise(resolver) {\n\t    if (typeof resolver !== \"function\") {\n\t        throw new TypeError(\"resolver must be a function.\");\n\t    }\n\t    var deferred = defer();\n\t    try {\n\t        resolver(deferred.resolve, deferred.reject, deferred.notify);\n\t    } catch (reason) {\n\t        deferred.reject(reason);\n\t    }\n\t    return deferred.promise;\n\t}\n\t\n\tpromise.race = race; // ES6\n\tpromise.all = all; // ES6\n\tpromise.reject = reject; // ES6\n\tpromise.resolve = Q; // ES6\n\t\n\t// XXX experimental.  This method is a way to denote that a local value is\n\t// serializable and should be immediately dispatched to a remote upon request,\n\t// instead of passing a reference.\n\tQ.passByCopy = function (object) {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return object;\n\t};\n\t\n\tPromise.prototype.passByCopy = function () {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return this;\n\t};\n\t\n\t/**\n\t * If two promises eventually fulfill to the same value, promises that value,\n\t * but otherwise rejects.\n\t * @param x {Any*}\n\t * @param y {Any*}\n\t * @returns {Any*} a promise for x and y if they are the same, but a rejection\n\t * otherwise.\n\t *\n\t */\n\tQ.join = function (x, y) {\n\t    return Q(x).join(y);\n\t};\n\t\n\tPromise.prototype.join = function (that) {\n\t    return Q([this, that]).spread(function (x, y) {\n\t        if (x === y) {\n\t            // TODO: \"===\" should be Object.is or equiv\n\t            return x;\n\t        } else {\n\t            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n\t        }\n\t    });\n\t};\n\t\n\t/**\n\t * Returns a promise for the first of an array of promises to become settled.\n\t * @param answers {Array[Any*]} promises to race\n\t * @returns {Any*} the first promise to be settled\n\t */\n\tQ.race = race;\n\tfunction race(answerPs) {\n\t    return promise(function (resolve, reject) {\n\t        // Switch to this once we can assume at least ES5\n\t        // answerPs.forEach(function (answerP) {\n\t        //     Q(answerP).then(resolve, reject);\n\t        // });\n\t        // Use this in the meantime\n\t        for (var i = 0, len = answerPs.length; i < len; i++) {\n\t            Q(answerPs[i]).then(resolve, reject);\n\t        }\n\t    });\n\t}\n\t\n\tPromise.prototype.race = function () {\n\t    return this.then(Q.race);\n\t};\n\t\n\t/**\n\t * Constructs a Promise with a promise descriptor object and optional fallback\n\t * function.  The descriptor contains methods like when(rejected), get(name),\n\t * set(name, value), post(name, args), and delete(name), which all\n\t * return either a value, a promise for a value, or a rejection.  The fallback\n\t * accepts the operation name, a resolver, and any further arguments that would\n\t * have been forwarded to the appropriate method above had a method been\n\t * provided with the proper name.  The API makes no guarantees about the nature\n\t * of the returned object, apart from that it is usable whereever promises are\n\t * bought and sold.\n\t */\n\tQ.makePromise = Promise;\n\tfunction Promise(descriptor, fallback, inspect) {\n\t    if (fallback === void 0) {\n\t        fallback = function (op) {\n\t            return reject(new Error(\n\t                \"Promise does not support operation: \" + op\n\t            ));\n\t        };\n\t    }\n\t    if (inspect === void 0) {\n\t        inspect = function () {\n\t            return {state: \"unknown\"};\n\t        };\n\t    }\n\t\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, args) {\n\t        var result;\n\t        try {\n\t            if (descriptor[op]) {\n\t                result = descriptor[op].apply(promise, args);\n\t            } else {\n\t                result = fallback.call(promise, op, args);\n\t            }\n\t        } catch (exception) {\n\t            result = reject(exception);\n\t        }\n\t        if (resolve) {\n\t            resolve(result);\n\t        }\n\t    };\n\t\n\t    promise.inspect = inspect;\n\t\n\t    // XXX deprecated `valueOf` and `exception` support\n\t    if (inspect) {\n\t        var inspected = inspect();\n\t        if (inspected.state === \"rejected\") {\n\t            promise.exception = inspected.reason;\n\t        }\n\t\n\t        promise.valueOf = function () {\n\t            var inspected = inspect();\n\t            if (inspected.state === \"pending\" ||\n\t                inspected.state === \"rejected\") {\n\t                return promise;\n\t            }\n\t            return inspected.value;\n\t        };\n\t    }\n\t\n\t    return promise;\n\t}\n\t\n\tPromise.prototype.toString = function () {\n\t    return \"[object Promise]\";\n\t};\n\t\n\tPromise.prototype.then = function (fulfilled, rejected, progressed) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    var done = false;   // ensure the untrusted promise makes at most a\n\t                        // single call to one of the callbacks\n\t\n\t    function _fulfilled(value) {\n\t        try {\n\t            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n\t        } catch (exception) {\n\t            return reject(exception);\n\t        }\n\t    }\n\t\n\t    function _rejected(exception) {\n\t        if (typeof rejected === \"function\") {\n\t            makeStackTraceLong(exception, self);\n\t            try {\n\t                return rejected(exception);\n\t            } catch (newException) {\n\t                return reject(newException);\n\t            }\n\t        }\n\t        return reject(exception);\n\t    }\n\t\n\t    function _progressed(value) {\n\t        return typeof progressed === \"function\" ? progressed(value) : value;\n\t    }\n\t\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(function (value) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_fulfilled(value));\n\t        }, \"when\", [function (exception) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_rejected(exception));\n\t        }]);\n\t    });\n\t\n\t    // Progress propagator need to be attached in the current tick.\n\t    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n\t        var newValue;\n\t        var threw = false;\n\t        try {\n\t            newValue = _progressed(value);\n\t        } catch (e) {\n\t            threw = true;\n\t            if (Q.onerror) {\n\t                Q.onerror(e);\n\t            } else {\n\t                throw e;\n\t            }\n\t        }\n\t\n\t        if (!threw) {\n\t            deferred.notify(newValue);\n\t        }\n\t    }]);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\tQ.tap = function (promise, callback) {\n\t    return Q(promise).tap(callback);\n\t};\n\t\n\t/**\n\t * Works almost like \"finally\", but not called for rejections.\n\t * Original resolution value is passed through callback unaffected.\n\t * Callback may return a promise that will be awaited for.\n\t * @param {Function} callback\n\t * @returns {Q.Promise}\n\t * @example\n\t * doSomething()\n\t *   .then(...)\n\t *   .tap(console.log)\n\t *   .then(...);\n\t */\n\tPromise.prototype.tap = function (callback) {\n\t    callback = Q(callback);\n\t\n\t    return this.then(function (value) {\n\t        return callback.fcall(value).thenResolve(value);\n\t    });\n\t};\n\t\n\t/**\n\t * Registers an observer on a promise.\n\t *\n\t * Guarantees:\n\t *\n\t * 1. that fulfilled and rejected will be called only once.\n\t * 2. that either the fulfilled callback or the rejected callback will be\n\t *    called, but not both.\n\t * 3. that fulfilled and rejected will not be called in this turn.\n\t *\n\t * @param value      promise or immediate reference to observe\n\t * @param fulfilled  function to be called with the fulfilled value\n\t * @param rejected   function to be called with the rejection exception\n\t * @param progressed function to be called on any progress notifications\n\t * @return promise for the return value from the invoked callback\n\t */\n\tQ.when = when;\n\tfunction when(value, fulfilled, rejected, progressed) {\n\t    return Q(value).then(fulfilled, rejected, progressed);\n\t}\n\t\n\tPromise.prototype.thenResolve = function (value) {\n\t    return this.then(function () { return value; });\n\t};\n\t\n\tQ.thenResolve = function (promise, value) {\n\t    return Q(promise).thenResolve(value);\n\t};\n\t\n\tPromise.prototype.thenReject = function (reason) {\n\t    return this.then(function () { throw reason; });\n\t};\n\t\n\tQ.thenReject = function (promise, reason) {\n\t    return Q(promise).thenReject(reason);\n\t};\n\t\n\t/**\n\t * If an object is not a promise, it is as \"near\" as possible.\n\t * If a promise is rejected, it is as \"near\" as possible too.\n\t * If its a fulfilled promise, the fulfillment value is nearer.\n\t * If its a deferred promise and the deferred has been resolved, the\n\t * resolution is \"nearer\".\n\t * @param object\n\t * @returns most resolved (nearest) form of the object\n\t */\n\t\n\t// XXX should we re-do this?\n\tQ.nearer = nearer;\n\tfunction nearer(value) {\n\t    if (isPromise(value)) {\n\t        var inspected = value.inspect();\n\t        if (inspected.state === \"fulfilled\") {\n\t            return inspected.value;\n\t        }\n\t    }\n\t    return value;\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a promise.\n\t * Otherwise it is a fulfilled value.\n\t */\n\tQ.isPromise = isPromise;\n\tfunction isPromise(object) {\n\t    return object instanceof Promise;\n\t}\n\t\n\tQ.isPromiseAlike = isPromiseAlike;\n\tfunction isPromiseAlike(object) {\n\t    return isObject(object) && typeof object.then === \"function\";\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a pending promise, meaning not\n\t * fulfilled or rejected.\n\t */\n\tQ.isPending = isPending;\n\tfunction isPending(object) {\n\t    return isPromise(object) && object.inspect().state === \"pending\";\n\t}\n\t\n\tPromise.prototype.isPending = function () {\n\t    return this.inspect().state === \"pending\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a value or fulfilled\n\t * promise.\n\t */\n\tQ.isFulfilled = isFulfilled;\n\tfunction isFulfilled(object) {\n\t    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n\t}\n\t\n\tPromise.prototype.isFulfilled = function () {\n\t    return this.inspect().state === \"fulfilled\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a rejected promise.\n\t */\n\tQ.isRejected = isRejected;\n\tfunction isRejected(object) {\n\t    return isPromise(object) && object.inspect().state === \"rejected\";\n\t}\n\t\n\tPromise.prototype.isRejected = function () {\n\t    return this.inspect().state === \"rejected\";\n\t};\n\t\n\t//// BEGIN UNHANDLED REJECTION TRACKING\n\t\n\t// This promise library consumes exceptions thrown in handlers so they can be\n\t// handled by a subsequent promise.  The exceptions get added to this array when\n\t// they are created, and removed when they are handled.  Note that in ES6 or\n\t// shimmed environments, this would naturally be a `Set`.\n\tvar unhandledReasons = [];\n\tvar unhandledRejections = [];\n\tvar reportedUnhandledRejections = [];\n\tvar trackUnhandledRejections = true;\n\t\n\tfunction resetUnhandledRejections() {\n\t    unhandledReasons.length = 0;\n\t    unhandledRejections.length = 0;\n\t\n\t    if (!trackUnhandledRejections) {\n\t        trackUnhandledRejections = true;\n\t    }\n\t}\n\t\n\tfunction trackRejection(promise, reason) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n\t        Q.nextTick.runAfter(function () {\n\t            if (array_indexOf(unhandledRejections, promise) !== -1) {\n\t                process.emit(\"unhandledRejection\", reason, promise);\n\t                reportedUnhandledRejections.push(promise);\n\t            }\n\t        });\n\t    }\n\t\n\t    unhandledRejections.push(promise);\n\t    if (reason && typeof reason.stack !== \"undefined\") {\n\t        unhandledReasons.push(reason.stack);\n\t    } else {\n\t        unhandledReasons.push(\"(no stack) \" + reason);\n\t    }\n\t}\n\t\n\tfunction untrackRejection(promise) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t\n\t    var at = array_indexOf(unhandledRejections, promise);\n\t    if (at !== -1) {\n\t        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n\t            Q.nextTick.runAfter(function () {\n\t                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n\t                if (atReport !== -1) {\n\t                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n\t                    reportedUnhandledRejections.splice(atReport, 1);\n\t                }\n\t            });\n\t        }\n\t        unhandledRejections.splice(at, 1);\n\t        unhandledReasons.splice(at, 1);\n\t    }\n\t}\n\t\n\tQ.resetUnhandledRejections = resetUnhandledRejections;\n\t\n\tQ.getUnhandledReasons = function () {\n\t    // Make a copy so that consumers can't interfere with our internal state.\n\t    return unhandledReasons.slice();\n\t};\n\t\n\tQ.stopUnhandledRejectionTracking = function () {\n\t    resetUnhandledRejections();\n\t    trackUnhandledRejections = false;\n\t};\n\t\n\tresetUnhandledRejections();\n\t\n\t//// END UNHANDLED REJECTION TRACKING\n\t\n\t/**\n\t * Constructs a rejected promise.\n\t * @param reason value describing the failure\n\t */\n\tQ.reject = reject;\n\tfunction reject(reason) {\n\t    var rejection = Promise({\n\t        \"when\": function (rejected) {\n\t            // note that the error has been handled\n\t            if (rejected) {\n\t                untrackRejection(this);\n\t            }\n\t            return rejected ? rejected(reason) : this;\n\t        }\n\t    }, function fallback() {\n\t        return this;\n\t    }, function inspect() {\n\t        return { state: \"rejected\", reason: reason };\n\t    });\n\t\n\t    // Note that the reason has not been handled.\n\t    trackRejection(rejection, reason);\n\t\n\t    return rejection;\n\t}\n\t\n\t/**\n\t * Constructs a fulfilled promise for an immediate reference.\n\t * @param value immediate reference\n\t */\n\tQ.fulfill = fulfill;\n\tfunction fulfill(value) {\n\t    return Promise({\n\t        \"when\": function () {\n\t            return value;\n\t        },\n\t        \"get\": function (name) {\n\t            return value[name];\n\t        },\n\t        \"set\": function (name, rhs) {\n\t            value[name] = rhs;\n\t        },\n\t        \"delete\": function (name) {\n\t            delete value[name];\n\t        },\n\t        \"post\": function (name, args) {\n\t            // Mark Miller proposes that post with no name should apply a\n\t            // promised function.\n\t            if (name === null || name === void 0) {\n\t                return value.apply(void 0, args);\n\t            } else {\n\t                return value[name].apply(value, args);\n\t            }\n\t        },\n\t        \"apply\": function (thisp, args) {\n\t            return value.apply(thisp, args);\n\t        },\n\t        \"keys\": function () {\n\t            return object_keys(value);\n\t        }\n\t    }, void 0, function inspect() {\n\t        return { state: \"fulfilled\", value: value };\n\t    });\n\t}\n\t\n\t/**\n\t * Converts thenables to Q promises.\n\t * @param promise thenable promise\n\t * @returns a Q promise\n\t */\n\tfunction coerce(promise) {\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        try {\n\t            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n\t        } catch (exception) {\n\t            deferred.reject(exception);\n\t        }\n\t    });\n\t    return deferred.promise;\n\t}\n\t\n\t/**\n\t * Annotates an object such that it will never be\n\t * transferred away from this process over any promise\n\t * communication channel.\n\t * @param object\n\t * @returns promise a wrapping of that object that\n\t * additionally responds to the \"isDef\" message\n\t * without a rejection.\n\t */\n\tQ.master = master;\n\tfunction master(object) {\n\t    return Promise({\n\t        \"isDef\": function () {}\n\t    }, function fallback(op, args) {\n\t        return dispatch(object, op, args);\n\t    }, function () {\n\t        return Q(object).inspect();\n\t    });\n\t}\n\t\n\t/**\n\t * Spreads the values of a promised array of arguments into the\n\t * fulfillment callback.\n\t * @param fulfilled callback that receives variadic arguments from the\n\t * promised array\n\t * @param rejected callback that receives the exception if the promise\n\t * is rejected.\n\t * @returns a promise for the return value or thrown exception of\n\t * either callback.\n\t */\n\tQ.spread = spread;\n\tfunction spread(value, fulfilled, rejected) {\n\t    return Q(value).spread(fulfilled, rejected);\n\t}\n\t\n\tPromise.prototype.spread = function (fulfilled, rejected) {\n\t    return this.all().then(function (array) {\n\t        return fulfilled.apply(void 0, array);\n\t    }, rejected);\n\t};\n\t\n\t/**\n\t * The async function is a decorator for generator functions, turning\n\t * them into asynchronous generators.  Although generators are only part\n\t * of the newest ECMAScript 6 drafts, this code does not cause syntax\n\t * errors in older engines.  This code should continue to work and will\n\t * in fact improve over time as the language improves.\n\t *\n\t * ES6 generators are currently part of V8 version 3.19 with the\n\t * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n\t * for longer, but under an older Python-inspired form.  This function\n\t * works on both kinds of generators.\n\t *\n\t * Decorates a generator function such that:\n\t *  - it may yield promises\n\t *  - execution will continue when that promise is fulfilled\n\t *  - the value of the yield expression will be the fulfilled value\n\t *  - it returns a promise for the return value (when the generator\n\t *    stops iterating)\n\t *  - the decorated function returns a promise for the return value\n\t *    of the generator or the first rejected promise among those\n\t *    yielded.\n\t *  - if an error is thrown in the generator, it propagates through\n\t *    every following yield until it is caught, or until it escapes\n\t *    the generator function altogether, and is translated into a\n\t *    rejection for the promise returned by the decorated generator.\n\t */\n\tQ.async = async;\n\tfunction async(makeGenerator) {\n\t    return function () {\n\t        // when verb is \"send\", arg is a value\n\t        // when verb is \"throw\", arg is an exception\n\t        function continuer(verb, arg) {\n\t            var result;\n\t\n\t            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n\t            // engine that has a deployed base of browsers that support generators.\n\t            // However, SM's generators use the Python-inspired semantics of\n\t            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n\t            // like to make it possible to use generators in deployed browsers, so\n\t            // we also support Python-style generators.  At some point we can remove\n\t            // this block.\n\t\n\t            if (typeof StopIteration === \"undefined\") {\n\t                // ES6 Generators\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    return reject(exception);\n\t                }\n\t                if (result.done) {\n\t                    return Q(result.value);\n\t                } else {\n\t                    return when(result.value, callback, errback);\n\t                }\n\t            } else {\n\t                // SpiderMonkey Generators\n\t                // FIXME: Remove this case when SM does ES6 generators.\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    if (isStopIteration(exception)) {\n\t                        return Q(exception.value);\n\t                    } else {\n\t                        return reject(exception);\n\t                    }\n\t                }\n\t                return when(result, callback, errback);\n\t            }\n\t        }\n\t        var generator = makeGenerator.apply(this, arguments);\n\t        var callback = continuer.bind(continuer, \"next\");\n\t        var errback = continuer.bind(continuer, \"throw\");\n\t        return callback();\n\t    };\n\t}\n\t\n\t/**\n\t * The spawn function is a small wrapper around async that immediately\n\t * calls the generator and also ends the promise chain, so that any\n\t * unhandled errors are thrown instead of forwarded to the error\n\t * handler. This is useful because it's extremely common to run\n\t * generators at the top-level to work with libraries.\n\t */\n\tQ.spawn = spawn;\n\tfunction spawn(makeGenerator) {\n\t    Q.done(Q.async(makeGenerator)());\n\t}\n\t\n\t// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n\t/**\n\t * Throws a ReturnValue exception to stop an asynchronous generator.\n\t *\n\t * This interface is a stop-gap measure to support generator return\n\t * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n\t * generators like Chromium 29, just use \"return\" in your generator\n\t * functions.\n\t *\n\t * @param value the return value for the surrounding generator\n\t * @throws ReturnValue exception with the value.\n\t * @example\n\t * // ES6 style\n\t * Q.async(function* () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      return foo + bar;\n\t * })\n\t * // Older SpiderMonkey style\n\t * Q.async(function () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      Q.return(foo + bar);\n\t * })\n\t */\n\tQ[\"return\"] = _return;\n\tfunction _return(value) {\n\t    throw new QReturnValue(value);\n\t}\n\t\n\t/**\n\t * The promised function decorator ensures that any promise arguments\n\t * are settled and passed as values (`this` is also settled and passed\n\t * as a value).  It will also ensure that the result of a function is\n\t * always a promise.\n\t *\n\t * @example\n\t * var add = Q.promised(function (a, b) {\n\t *     return a + b;\n\t * });\n\t * add(Q(a), Q(B));\n\t *\n\t * @param {function} callback The function to decorate\n\t * @returns {function} a function that has been decorated.\n\t */\n\tQ.promised = promised;\n\tfunction promised(callback) {\n\t    return function () {\n\t        return spread([this, all(arguments)], function (self, args) {\n\t            return callback.apply(self, args);\n\t        });\n\t    };\n\t}\n\t\n\t/**\n\t * sends a message to a value in a future turn\n\t * @param object* the recipient\n\t * @param op the name of the message operation, e.g., \"when\",\n\t * @param args further arguments to be forwarded to the operation\n\t * @returns result {Promise} a promise for the result of the operation\n\t */\n\tQ.dispatch = dispatch;\n\tfunction dispatch(object, op, args) {\n\t    return Q(object).dispatch(op, args);\n\t}\n\t\n\tPromise.prototype.dispatch = function (op, args) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(deferred.resolve, op, args);\n\t    });\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Gets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to get\n\t * @return promise for the property value\n\t */\n\tQ.get = function (object, key) {\n\t    return Q(object).dispatch(\"get\", [key]);\n\t};\n\t\n\tPromise.prototype.get = function (key) {\n\t    return this.dispatch(\"get\", [key]);\n\t};\n\t\n\t/**\n\t * Sets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for object object\n\t * @param name      name of property to set\n\t * @param value     new value of property\n\t * @return promise for the return value\n\t */\n\tQ.set = function (object, key, value) {\n\t    return Q(object).dispatch(\"set\", [key, value]);\n\t};\n\t\n\tPromise.prototype.set = function (key, value) {\n\t    return this.dispatch(\"set\", [key, value]);\n\t};\n\t\n\t/**\n\t * Deletes a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to delete\n\t * @return promise for the return value\n\t */\n\tQ.del = // XXX legacy\n\tQ[\"delete\"] = function (object, key) {\n\t    return Q(object).dispatch(\"delete\", [key]);\n\t};\n\t\n\tPromise.prototype.del = // XXX legacy\n\tPromise.prototype[\"delete\"] = function (key) {\n\t    return this.dispatch(\"delete\", [key]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param value     a value to post, typically an array of\n\t *                  invocation arguments for promises that\n\t *                  are ultimately backed with `resolve` values,\n\t *                  as opposed to those backed with URLs\n\t *                  wherein the posted value can be any\n\t *                  JSON serializable object.\n\t * @return promise for the return value\n\t */\n\t// bound locally because it is used by other methods\n\tQ.mapply = // XXX As proposed by \"Redsandro\"\n\tQ.post = function (object, name, args) {\n\t    return Q(object).dispatch(\"post\", [name, args]);\n\t};\n\t\n\tPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.post = function (name, args) {\n\t    return this.dispatch(\"post\", [name, args]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param ...args   array of invocation arguments\n\t * @return promise for the return value\n\t */\n\tQ.send = // XXX Mark Miller's proposed parlance\n\tQ.mcall = // XXX As proposed by \"Redsandro\"\n\tQ.invoke = function (object, name /*...args*/) {\n\t    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n\t};\n\t\n\tPromise.prototype.send = // XXX Mark Miller's proposed parlance\n\tPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.invoke = function (name /*...args*/) {\n\t    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n\t};\n\t\n\t/**\n\t * Applies the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param args      array of application arguments\n\t */\n\tQ.fapply = function (object, args) {\n\t    return Q(object).dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\tPromise.prototype.fapply = function (args) {\n\t    return this.dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\t/**\n\t * Calls the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ[\"try\"] =\n\tQ.fcall = function (object /* ...args*/) {\n\t    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n\t};\n\t\n\tPromise.prototype.fcall = function (/*...args*/) {\n\t    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n\t};\n\t\n\t/**\n\t * Binds the promised function, transforming return values into a fulfilled\n\t * promise and thrown errors into a rejected one.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ.fbind = function (object /*...args*/) {\n\t    var promise = Q(object);\n\t    var args = array_slice(arguments, 1);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\tPromise.prototype.fbind = function (/*...args*/) {\n\t    var promise = this;\n\t    var args = array_slice(arguments);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\t\n\t/**\n\t * Requests the names of the owned properties of a promised\n\t * object in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @return promise for the keys of the eventually settled object\n\t */\n\tQ.keys = function (object) {\n\t    return Q(object).dispatch(\"keys\", []);\n\t};\n\t\n\tPromise.prototype.keys = function () {\n\t    return this.dispatch(\"keys\", []);\n\t};\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array.  If any of\n\t * the promises gets rejected, the whole array is rejected immediately.\n\t * @param {Array*} an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns a promise for an array of the corresponding values\n\t */\n\t// By Mark Miller\n\t// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n\tQ.all = all;\n\tfunction all(promises) {\n\t    return when(promises, function (promises) {\n\t        var pendingCount = 0;\n\t        var deferred = defer();\n\t        array_reduce(promises, function (undefined, promise, index) {\n\t            var snapshot;\n\t            if (\n\t                isPromise(promise) &&\n\t                (snapshot = promise.inspect()).state === \"fulfilled\"\n\t            ) {\n\t                promises[index] = snapshot.value;\n\t            } else {\n\t                ++pendingCount;\n\t                when(\n\t                    promise,\n\t                    function (value) {\n\t                        promises[index] = value;\n\t                        if (--pendingCount === 0) {\n\t                            deferred.resolve(promises);\n\t                        }\n\t                    },\n\t                    deferred.reject,\n\t                    function (progress) {\n\t                        deferred.notify({ index: index, value: progress });\n\t                    }\n\t                );\n\t            }\n\t        }, void 0);\n\t        if (pendingCount === 0) {\n\t            deferred.resolve(promises);\n\t        }\n\t        return deferred.promise;\n\t    });\n\t}\n\t\n\tPromise.prototype.all = function () {\n\t    return all(this);\n\t};\n\t\n\t/**\n\t * Returns the first resolved promise of an array. Prior rejected promises are\n\t * ignored.  Rejects only if all promises are rejected.\n\t * @param {Array*} an array containing values or promises for values\n\t * @returns a promise fulfilled with the value of the first resolved promise,\n\t * or a rejected promise if all promises are rejected.\n\t */\n\tQ.any = any;\n\t\n\tfunction any(promises) {\n\t    if (promises.length === 0) {\n\t        return Q.resolve();\n\t    }\n\t\n\t    var deferred = Q.defer();\n\t    var pendingCount = 0;\n\t    array_reduce(promises, function (prev, current, index) {\n\t        var promise = promises[index];\n\t\n\t        pendingCount++;\n\t\n\t        when(promise, onFulfilled, onRejected, onProgress);\n\t        function onFulfilled(result) {\n\t            deferred.resolve(result);\n\t        }\n\t        function onRejected() {\n\t            pendingCount--;\n\t            if (pendingCount === 0) {\n\t                deferred.reject(new Error(\n\t                    \"Can't get fulfillment value from any promise, all \" +\n\t                    \"promises were rejected.\"\n\t                ));\n\t            }\n\t        }\n\t        function onProgress(progress) {\n\t            deferred.notify({\n\t                index: index,\n\t                value: progress\n\t            });\n\t        }\n\t    }, undefined);\n\t\n\t    return deferred.promise;\n\t}\n\t\n\tPromise.prototype.any = function () {\n\t    return any(this);\n\t};\n\t\n\t/**\n\t * Waits for all promises to be settled, either fulfilled or\n\t * rejected.  This is distinct from `all` since that would stop\n\t * waiting at the first rejection.  The promise returned by\n\t * `allResolved` will never be rejected.\n\t * @param promises a promise for an array (or an array) of promises\n\t * (or values)\n\t * @return a promise for an array of promises\n\t */\n\tQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n\tfunction allResolved(promises) {\n\t    return when(promises, function (promises) {\n\t        promises = array_map(promises, Q);\n\t        return when(all(array_map(promises, function (promise) {\n\t            return when(promise, noop, noop);\n\t        })), function () {\n\t            return promises;\n\t        });\n\t    });\n\t}\n\t\n\tPromise.prototype.allResolved = function () {\n\t    return allResolved(this);\n\t};\n\t\n\t/**\n\t * @see Promise#allSettled\n\t */\n\tQ.allSettled = allSettled;\n\tfunction allSettled(promises) {\n\t    return Q(promises).allSettled();\n\t}\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array of their states (as\n\t * returned by `inspect`) when they have all settled.\n\t * @param {Array[Any*]} values an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns {Array[State]} an array of states for the respective values.\n\t */\n\tPromise.prototype.allSettled = function () {\n\t    return this.then(function (promises) {\n\t        return all(array_map(promises, function (promise) {\n\t            promise = Q(promise);\n\t            function regardless() {\n\t                return promise.inspect();\n\t            }\n\t            return promise.then(regardless, regardless);\n\t        }));\n\t    });\n\t};\n\t\n\t/**\n\t * Captures the failure of a promise, giving an oportunity to recover\n\t * with a callback.  If the given promise is fulfilled, the returned\n\t * promise is fulfilled.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to fulfill the returned promise if the\n\t * given promise is rejected\n\t * @returns a promise for the return value of the callback\n\t */\n\tQ.fail = // XXX legacy\n\tQ[\"catch\"] = function (object, rejected) {\n\t    return Q(object).then(void 0, rejected);\n\t};\n\t\n\tPromise.prototype.fail = // XXX legacy\n\tPromise.prototype[\"catch\"] = function (rejected) {\n\t    return this.then(void 0, rejected);\n\t};\n\t\n\t/**\n\t * Attaches a listener that can respond to progress notifications from a\n\t * promise's originating deferred. This listener receives the exact arguments\n\t * passed to ``deferred.notify``.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to receive any progress notifications\n\t * @returns the given promise, unchanged\n\t */\n\tQ.progress = progress;\n\tfunction progress(object, progressed) {\n\t    return Q(object).then(void 0, void 0, progressed);\n\t}\n\t\n\tPromise.prototype.progress = function (progressed) {\n\t    return this.then(void 0, void 0, progressed);\n\t};\n\t\n\t/**\n\t * Provides an opportunity to observe the settling of a promise,\n\t * regardless of whether the promise is fulfilled or rejected.  Forwards\n\t * the resolution to the returned promise when the callback is done.\n\t * The callback can return a promise to defer completion.\n\t * @param {Any*} promise\n\t * @param {Function} callback to observe the resolution of the given\n\t * promise, takes no arguments.\n\t * @returns a promise for the resolution of the given promise when\n\t * ``fin`` is done.\n\t */\n\tQ.fin = // XXX legacy\n\tQ[\"finally\"] = function (object, callback) {\n\t    return Q(object)[\"finally\"](callback);\n\t};\n\t\n\tPromise.prototype.fin = // XXX legacy\n\tPromise.prototype[\"finally\"] = function (callback) {\n\t    callback = Q(callback);\n\t    return this.then(function (value) {\n\t        return callback.fcall().then(function () {\n\t            return value;\n\t        });\n\t    }, function (reason) {\n\t        // TODO attempt to recycle the rejection with \"this\".\n\t        return callback.fcall().then(function () {\n\t            throw reason;\n\t        });\n\t    });\n\t};\n\t\n\t/**\n\t * Terminates a chain of promises, forcing rejections to be\n\t * thrown as exceptions.\n\t * @param {Any*} promise at the end of a chain of promises\n\t * @returns nothing\n\t */\n\tQ.done = function (object, fulfilled, rejected, progress) {\n\t    return Q(object).done(fulfilled, rejected, progress);\n\t};\n\t\n\tPromise.prototype.done = function (fulfilled, rejected, progress) {\n\t    var onUnhandledError = function (error) {\n\t        // forward to a future turn so that ``when``\n\t        // does not catch it and turn it into a rejection.\n\t        Q.nextTick(function () {\n\t            makeStackTraceLong(error, promise);\n\t            if (Q.onerror) {\n\t                Q.onerror(error);\n\t            } else {\n\t                throw error;\n\t            }\n\t        });\n\t    };\n\t\n\t    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n\t    var promise = fulfilled || rejected || progress ?\n\t        this.then(fulfilled, rejected, progress) :\n\t        this;\n\t\n\t    if (typeof process === \"object\" && process && process.domain) {\n\t        onUnhandledError = process.domain.bind(onUnhandledError);\n\t    }\n\t\n\t    promise.then(void 0, onUnhandledError);\n\t};\n\t\n\t/**\n\t * Causes a promise to be rejected if it does not get fulfilled before\n\t * some milliseconds time out.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds timeout\n\t * @param {Any*} custom error message or Error object (optional)\n\t * @returns a promise for the resolution of the given promise if it is\n\t * fulfilled before the timeout, otherwise rejected.\n\t */\n\tQ.timeout = function (object, ms, error) {\n\t    return Q(object).timeout(ms, error);\n\t};\n\t\n\tPromise.prototype.timeout = function (ms, error) {\n\t    var deferred = defer();\n\t    var timeoutId = setTimeout(function () {\n\t        if (!error || \"string\" === typeof error) {\n\t            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n\t            error.code = \"ETIMEDOUT\";\n\t        }\n\t        deferred.reject(error);\n\t    }, ms);\n\t\n\t    this.then(function (value) {\n\t        clearTimeout(timeoutId);\n\t        deferred.resolve(value);\n\t    }, function (exception) {\n\t        clearTimeout(timeoutId);\n\t        deferred.reject(exception);\n\t    }, deferred.notify);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Returns a promise for the given value (or promised value), some\n\t * milliseconds after it resolved. Passes rejections immediately.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds\n\t * @returns a promise for the resolution of the given promise after milliseconds\n\t * time has elapsed since the resolution of the given promise.\n\t * If the given promise rejects, that is passed immediately.\n\t */\n\tQ.delay = function (object, timeout) {\n\t    if (timeout === void 0) {\n\t        timeout = object;\n\t        object = void 0;\n\t    }\n\t    return Q(object).delay(timeout);\n\t};\n\t\n\tPromise.prototype.delay = function (timeout) {\n\t    return this.then(function (value) {\n\t        var deferred = defer();\n\t        setTimeout(function () {\n\t            deferred.resolve(value);\n\t        }, timeout);\n\t        return deferred.promise;\n\t    });\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided as an array, and returns a promise.\n\t *\n\t *      Q.nfapply(FS.readFile, [__filename])\n\t *      .then(function (content) {\n\t *      })\n\t *\n\t */\n\tQ.nfapply = function (callback, args) {\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfapply = function (args) {\n\t    var deferred = defer();\n\t    var nodeArgs = array_slice(args);\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided individually, and returns a promise.\n\t * @example\n\t * Q.nfcall(FS.readFile, __filename)\n\t * .then(function (content) {\n\t * })\n\t *\n\t */\n\tQ.nfcall = function (callback /*...args*/) {\n\t    var args = array_slice(arguments, 1);\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfcall = function (/*...args*/) {\n\t    var nodeArgs = array_slice(arguments);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Wraps a NodeJS continuation passing function and returns an equivalent\n\t * version that returns a promise.\n\t * @example\n\t * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n\t * .then(console.log)\n\t * .done()\n\t */\n\tQ.nfbind =\n\tQ.denodeify = function (callback /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 1);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nfbind =\n\tPromise.prototype.denodeify = function (/*...args*/) {\n\t    var args = array_slice(arguments);\n\t    args.unshift(this);\n\t    return Q.denodeify.apply(void 0, args);\n\t};\n\t\n\tQ.nbind = function (callback, thisp /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 2);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        function bound() {\n\t            return callback.apply(thisp, arguments);\n\t        }\n\t        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nbind = function (/*thisp, ...args*/) {\n\t    var args = array_slice(arguments, 0);\n\t    args.unshift(this);\n\t    return Q.nbind.apply(void 0, args);\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback with a given array of arguments, plus a provided callback.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param {Array} args arguments to pass to the method; the callback\n\t * will be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nmapply = // XXX As proposed by \"Redsandro\"\n\tQ.npost = function (object, name, args) {\n\t    return Q(object).npost(name, args);\n\t};\n\t\n\tPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.npost = function (name, args) {\n\t    var nodeArgs = array_slice(args || []);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback, forwarding the given variadic arguments, plus a provided\n\t * callback argument.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param ...args arguments to pass to the method; the callback will\n\t * be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tQ.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tQ.ninvoke = function (object, name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 2);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\tPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tPromise.prototype.ninvoke = function (name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 1);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * If a function would like to support both Node continuation-passing-style and\n\t * promise-returning-style, it can end its internal promise chain with\n\t * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n\t * elects to use a nodeback, the result will be sent there.  If they do not\n\t * pass a nodeback, they will receive the result promise.\n\t * @param object a result (or a promise for a result)\n\t * @param {Function} nodeback a Node.js-style callback\n\t * @returns either the promise or nothing\n\t */\n\tQ.nodeify = nodeify;\n\tfunction nodeify(object, nodeback) {\n\t    return Q(object).nodeify(nodeback);\n\t}\n\t\n\tPromise.prototype.nodeify = function (nodeback) {\n\t    if (nodeback) {\n\t        this.then(function (value) {\n\t            Q.nextTick(function () {\n\t                nodeback(null, value);\n\t            });\n\t        }, function (error) {\n\t            Q.nextTick(function () {\n\t                nodeback(error);\n\t            });\n\t        });\n\t    } else {\n\t        return this;\n\t    }\n\t};\n\t\n\tQ.noConflict = function() {\n\t    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n\t};\n\t\n\t// All code before this point will be filtered from stack traces.\n\tvar qEndingLine = captureLine();\n\t\n\treturn Q;\n\t\n\t});\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(8);\n\tvar respoke = __webpack_require__(1);\n\tvar log = respoke.log;\n\t\n\t/**\n\t * `respoke.Client` is the top-level interface to the API. Interacting with Respoke should be done using\n\t * a `respoke.Client` instance.\n\t *\n\t * There are two ways to get a client:\n\t *\n\t *      var client = respoke.createClient(clientParams);\n\t *      // . . . set stuff up, then . . .\n\t *      client.connect(connectParams);\n\t *\n\t * or\n\t *\n\t *      // creates client and connects to Respoke all at once\n\t *      var client = respoke.connect(allParams);\n\t *\n\t * A client does the following things:\n\t *\n\t * 1. authentication with the Respoke API\n\t * 1. receives server-side app-specific information\n\t * 1. tracks connections and presence\n\t * 1. provides methods to get and interact with tracked entities (like groups and endpoints)\n\t * 1. stores default settings for calls and direct connections\n\t * 1. automatically reconnects to the API when network activity is lost*\n\t *\n\t * *If `developmentMode` is set to true. If not using `developmentMode`, disable automatic\n\t * reconnect by sending `reconnect: false` and listening to the Client's disconnect event\n\t * to fetch a new brokered auth token, then call `client.connect()` with the new token.\n\t *\n\t * @class respoke.Client\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n\t * respoke.connect, respoke.createClient, or to client.connect.\n\t * @param {string} [params.token] - The endpoint's authentication token.\n\t * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t * endpoint. This is only used when `developmentMode` is set to `true`.\n\t * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n\t * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t * operation and will limit the services you will be able to use.\n\t * @param {string|number|object|Array} [params.presence=unavailable] The initial presence to set once connected.\n\t * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n\t * when a disconnect occurs.\n\t * @proprety {number} [connectTimeoutMillis=10000] - Number of milliseconds before considering the connect operation timed out.\n\t * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n\t * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is received\n\t * from anywhere on the system.\n\t * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n\t * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n\t * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect.\n\t * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client's user receives a call.\n\t * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this client's user\n\t * receives a request for a direct connection.\n\t * @returns {respoke.Client}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId || respoke.makeGUID();\n\t    params.instanceId = instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    respoke.instances[instanceId] = that;\n\t    delete that.instanceId;\n\t    that.connectTries = 0;\n\t    /**\n\t     * A name to identify this class\n\t     * @memberof! respoke.Client\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Client';\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name host\n\t     * @type {string}\n\t     * @private\n\t     */\n\t    var host = window.location.hostname;\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name port\n\t     * @type {number}\n\t     * @private\n\t     */\n\t    var port = window.location.port;\n\t\n\t    /**\n\t     * A container for baseURL, token, and appId so they won't be accidentally viewable in any JavaScript debugger.\n\t     * @memberof! respoke.Client\n\t     * @name clientSettings\n\t     * @type {object}\n\t     * @private\n\t     * @property {string} [baseURL] - the URL of the cloud infrastructure's REST API.\n\t     * @property {string} [token] - The endpoint's authentication token.\n\t     * @property {string} [appId] - The id of your Respoke app.\n\t     * @property {string} [endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @property {boolean} [developmentMode=false] - Indication to obtain an authentication token from the service.\n\t     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t     * operation and will limit the services you will be able to use.\n\t     * @property {boolean} [reconnect=false] - Whether or not to automatically reconnect to the Respoke service\n\t     * when a disconnect occurs.\n\t     * @proprety {number} [connectTimeoutMillis=10000] - Number of milliseconds before considering the connect\n\t     * timed out.\n\t     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n\t     * @property {respoke.Client.onClientMessage} [onMessage] - Callback for when any message is received\n\t     * from anywhere on the system.\n\t     * @property {respoke.Client.onConnect} [onConnect] - Callback for Client connect.\n\t     * @property {respoke.Client.onDisconnect} [onDisconnect] - Callback for Client disconnect.\n\t     * @property {respoke.Client.onReconnect} [onReconnect] - Callback for Client reconnect. Not Implemented.\n\t     * @property {respoke.Client.onCall} [onCall] - Callback for when this client receives a call.\n\t     * @property {respoke.Client.onDirectConnection} [onDirectConnection] - Callback for when this client\n\t     * receives a request for a direct connection.\n\t     * @property {boolean} enableCallDebugReport=true - Upon finishing a call, should the client send debugging\n\t     * information to the API? Defaults to `true`.\n\t     */\n\t    var clientSettings = that.clientSettings = {};\n\t\n\t    delete that.appId;\n\t    delete that.baseURL;\n\t    delete that.developmentMode;\n\t    delete that.token;\n\t    delete that.resolveEndpointPresence;\n\t\n\t    /**\n\t     * Internal list of known groups.\n\t     * @memberof! respoke.Client\n\t     * @name groups\n\t     * @type {Array<respoke.Group>}\n\t     * @private\n\t     */\n\t    var groups = [];\n\t    /**\n\t     * Internal list of known endpoints.\n\t     * @memberof! respoke.Client\n\t     * @name endpoints\n\t     * @type {Array<respoke.Endpoint>}\n\t     * @private\n\t     */\n\t    var endpoints = [];\n\t    /**\n\t     * Array of calls in progress, made accessible for informational purposes only.\n\t     * **Never modify this array directly.**\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @name calls\n\t     * @type {array}\n\t     */\n\t    that.calls = [];\n\t    log.debug(\"Client ID is \", instanceId);\n\t\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name signalingChannel\n\t     * @type {respoke.SignalingChannel}\n\t     * @private\n\t     */\n\t    that.signalingChannel = respoke.SignalingChannel({\n\t        instanceId: instanceId,\n\t        clientSettings: clientSettings\n\t    });\n\t\n\t    /**\n\t     * Represents the presence status. Typically a string, but other types are supported.\n\t     * Defaults to `'unavailable'`.\n\t     *\n\t     * **Do not modify this directly** - it won't update presence with Respoke. Use `setPresence()`.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @name presence\n\t     * @type {string|number|object|Array}\n\t     */\n\t    that.presence = params.presence || 'unavailable';\n\t\n\t    /**\n\t     * Deprecated: use endpoint.presence instead.\n\t     *\n\t     * Return the presence.\n\t     * @memberof! respoke.Client\n\t     * @deprecated\n\t     * @name presence\n\t     * @type {string|number|object|Array}\n\t     */\n\t    that.getPresence = function () {\n\t        return that.presence;\n\t    };\n\t\n\t    /**\n\t     * Save parameters of the constructor or client.connect() onto the clientSettings object\n\t     * @memberof! respoke.Client\n\t     * @method respoke.saveParameters\n\t     * @param {object} params\n\t     * @param {respoke.Client.connectSuccessHandler} [params.onSuccess] - Success handler for this invocation\n\t     * of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n\t     * respoke.connect, respoke.createClient, or to client.connect.\n\t     * @param {string} [params.token] - The endpoint's authentication token.\n\t     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n\t     * @param {respoke.client.resolveEndpointPresence} [params.resolveEndpointPresence] An optional function for\n\t     * resolving presence for an endpoint.  An endpoint can have multiple Connections this function will be used\n\t     * to decide which Connection's presence gets precedence for the Endpoint.\n\t     * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n\t     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t     * operation and will limit the services you will be able to use.\n\t     * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n\t     * when a disconnect occurs.\n\t     * @proprety {number} [paramsconnectTimeoutMillis=10000] - Number of milliseconds before considering the connect\n\t     * timed out.\n\t     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves\n\t     * a group.\n\t     * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is\n\t     * received from anywhere on the system.\n\t     * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n\t     * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n\t     * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n\t     * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client receives a call.\n\t     * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this\n\t     * client receives a request for a direct connection.\n\t     * @private\n\t     */\n\t    function saveParameters(params) {\n\t        Object.keys(params).forEach(function eachParam(key) {\n\t            if (['onSuccess', 'onError', 'reconnect', 'presence'].indexOf(key) === -1 && params[key] !== undefined) {\n\t                clientSettings[key] = params[key];\n\t            }\n\t        });\n\t\n\t        clientSettings.developmentMode = !!clientSettings.developmentMode;\n\t        clientSettings.enableCallDebugReport = typeof clientSettings.enableCallDebugReport === 'boolean' ?\n\t            clientSettings.enableCallDebugReport : true;\n\t\n\t        if (typeof clientSettings.connectTimeoutMillis !== 'number') {\n\t            clientSettings.connectTimeoutMillis = 10000;\n\t        }\n\t\n\t        if (typeof params.reconnect !== 'boolean') {\n\t            clientSettings.reconnect = typeof clientSettings.developmentMode === 'boolean' ?\n\t                clientSettings.developmentMode : false;\n\t        } else {\n\t            clientSettings.reconnect = !!params.reconnect;\n\t        }\n\t    }\n\t    saveParameters(params);\n\t\n\t    /**\n\t     * Connect to the Respoke infrastructure and authenticate using `params.token`.\n\t     *\n\t     * After `connect`, the app auth session token is stored so it can be used in API requests.\n\t     *\n\t     * This method attaches quite a few event listeners for things like group joining and connection status changes.\n\t     *\n\t     * #### Usage\n\t     *\n\t     *      client.connect({\n\t     *          appId: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\",\n\t     *          token: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\", // if not developmentMode\n\t     *          developmentMode: false || true,\n\t     *          // if developmentMode, otherwise your server will set endpointId\n\t     *          endpointId: \"daveops\"\n\t     *      });\n\t     *      client.listen(\"connect\", function () { } );\n\t     *\n\t     *\n\t     * If no `params.token` is given and `developmentMode` is set to true, it will attempt to obtain a token\n\t     * automatically. You must set an `endpointId`.\n\t     *\n\t     *\n\t     * #### App auth session token expiration\n\t     *\n\t     * If `params.reconnect` is set to true (which it is by default for `developmentMode`), the `client`\n\t     * will attempt to keep reconnecting each time the app auth session expires.\n\t     *\n\t     * If not using `developmentMode`, automatic reconnect will be disabled. You will need to\n\t     * listen to the Client's `disconnect` event to fetch a new brokered auth token and call\n\t     * `client.connect()` with the new token.\n\t     *\n\t     *      client.listen('disconnect', function () {\n\t     *\n\t     *          // example method you implemented to get a new token from your server\n\t     *          myServer.getNewRespokeAccessToken(function (newToken) {\n\t     *              // reconnect with respoke.Client\n\t     *              client.connect({ token: newToken });\n\t     *          });\n\t     *\n\t     *      });\n\t     *\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.connect\n\t     * @param {object} params\n\t     * @param {respoke.Client.connectSuccessHandler} [params.onSuccess] - Success handler for this invocation\n\t     * of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n\t     * respoke.connect, respoke.createClient, or to client.connect.\n\t     * @param {string} [params.token] - The endpoint's authentication token.\n\t     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n\t     * @param {respoke.client.resolveEndpointPresence} [params.resolveEndpointPresence] An optional function for\n\t     * resolving presence for an endpoint.  An endpoint can have multiple Connections this function will be used\n\t     * to decide which Connection's presence gets precedence for the Endpoint.\n\t     * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n\t     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n\t     * operation and will limit the services you will be able to use.\n\t     * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n\t     * when a disconnect occurs.\n\t     * @proprety {number} [connectTimeoutMillis=10000] - Number of milliseconds before considering the connect\n\t     * timed out.\n\t     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n\t     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves\n\t     * a group.\n\t     * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is\n\t     * received from anywhere on the system.\n\t     * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n\t     * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n\t     * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n\t     * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client receives a call.\n\t     * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this\n\t     * client receives a request for a direct connection.\n\t     * @returns {Promise|undefined}\n\t     * @fires respoke.Client#connect\n\t     */\n\t    that.connect = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        params = params || {};\n\t        log.debug('Client.connect');\n\t        that.connectTries += 1;\n\t\n\t        saveParameters(params);\n\t        that.presence = params.presence || that.presence;\n\t        that.endpointId = clientSettings.endpointId;\n\t        promise = actuallyConnect(params);\n\t        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        promise.then(function successHandler() {\n\t            /**\n\t             * This event is fired the first time the library connects to the cloud infrastructure.\n\t             * @event respoke.Client#connect\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.fire('connect');\n\t        });\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * This function contains the meat of the connection, the portions which can be repeated again on reconnect.\n\t     *\n\t     * When `reconnect` is true, this function will be added in an event listener to the Client#disconnect event.\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.actuallyConnect\n\t     * @private\n\t     * @param {object} params\n\t     * @param {connectSuccessHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    function actuallyConnect(params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t\n\t        if (!clientSettings.token &&\n\t                (!clientSettings.appId || !clientSettings.endpointId || clientSettings.developmentMode !== true)) {\n\t            deferred.reject(new Error(\"Must pass either endpointID & appId & developmentMode=true, or a token, \" +\n\t                \"to client.connect().\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        that.signalingChannel.open({\n\t            actuallyConnect: actuallyConnect,\n\t            endpointId: that.endpointId,\n\t            token: clientSettings.token\n\t        }).then(function successHandler() {\n\t            return that.signalingChannel.authenticate();\n\t        }).done(function successHandler() {\n\t            // set initial presence for the connection\n\t            if (that.presence) {\n\t                that.setPresence({presence: that.presence});\n\t            }\n\t\n\t            /*\n\t             * These rely on the EventEmitter checking for duplicate event listeners in order for these\n\t             * not to be duplicated on reconnect.\n\t             */\n\t\n\t            /**\n\t             * This event provides notification for when an incoming call is being received.  If the user wishes\n\t             * to allow the call, `evt.call.answer()`.\n\t             * @event respoke.Client#call\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Call} call\n\t             * @property {respoke.Endpoint} endpoint\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.listen('call', clientSettings.onCall);\n\t            /**\n\t             * This event is fired when the local end of the directConnection is available. It still will not be\n\t             * ready to send and receive messages until the 'open' event fires.\n\t             * @event respoke.Client#direct-connection\n\t             * @type {respoke.Event}\n\t             * @property {respoke.DirectConnection} directConnection\n\t             * @property {respoke.Endpoint} endpoint\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.listen('direct-connection', clientSettings.onDirectConnection);\n\t            that.listen('join', clientSettings.onJoin);\n\t            /**\n\t             * This event is fired every time the client leaves a group.\n\t             * @event respoke.Client#leave\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Group} group\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.listen('leave', clientSettings.onLeave);\n\t            /**\n\t             * A generic message handler when a message was received by the client.\n\t             *\n\t             * @event respoke.Client#message\n\t             * @type {respoke.Event}\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Endpoint} endpoint - If the message was private, this is the Endpoint who sent it.\n\t             * @property {respoke.Group} group - If the message was to a group, this is the group.\n\t             * @property {respoke.TextMessage} message - The generic message object.\n\t             * @property {string} message.connectionId\n\t             * @property {string} message.endpointId\n\t             * @property {string} message.message - Message body text.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.listen('message', clientSettings.onMessage);\n\t            that.listen('connect', clientSettings.onConnect);\n\t            /**\n\t             * Client has disconnected from Respoke.\n\t             *\n\t             * @event respoke.Client#disconnect\n\t             * @type {respoke.Event}\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.listen('disconnect', clientSettings.onDisconnect);\n\t            that.listen('disconnect', function () {\n\t                that.calls.forEach(function (call) {\n\t                    call.hangup({signal: false});\n\t                });\n\t            }, true);\n\t            /**\n\t             * Client has reconnected to Respoke.\n\t             *\n\t             * @event respoke.Client#reconnect\n\t             * @type {respoke.Event}\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.listen('reconnect', clientSettings.onReconnect);\n\t\n\t            log.info('logged in as ' + that.endpointId, that);\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t            if (err.message && err.message.match(/Connection limit exceeded/)) {\n\t                log.error(\n\t                    'You have reached the connection limit on the account associated with this appId. ' +\n\t                    'Please upgrade your account from the developer portal at https://portal.respoke.io ' +\n\t                    'if you need more concurrent connections.', err);\n\t            } else {\n\t                log.error(err.message, err.stack);\n\t            }\n\t        });\n\t\n\t        return deferred.promise;\n\t    }\n\t\n\t    /**\n\t     * Disconnect from the Respoke infrastructure, leave all groups, invalidate the token, and disconnect the websocket.\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.disconnect\n\t     * @returns {Promise|undefined}\n\t     * @param {object} params\n\t     * @param {disconnectSuccessHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @fires respoke.Client#disconnect\n\t     */\n\t    that.disconnect = function (params) {\n\t        // TODO: also call this on socket disconnect\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            deferred.reject(e);\n\t            return retVal;\n\t        }\n\t\n\t        var leaveGroups = groups.map(function eachGroup(group) {\n\t            if (group.isJoined()) {\n\t                return group.leave();\n\t            }\n\t        });\n\t\n\t        Q.all(leaveGroups).fin(function successHandler() {\n\t            return that.signalingChannel.close();\n\t        }).fin(function finallyHandler() {\n\t            that.presence = 'unavailable';\n\t            endpoints = [];\n\t            groups = [];\n\t            /**\n\t             * This event is fired when the library has disconnected from the cloud infrastructure.\n\t             * @event respoke.Client#disconnect\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.fire('disconnect');\n\t            deferred.resolve();\n\t        }).done();\n\t\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Set the presence for this client.\n\t     *\n\t     * The value of presence can be a string, number, object, or array - in any format -\n\t     * depending on the needs of your application. The only requirement is that\n\t     * `JSON.stringify()` must work (no circular references).\n\t     *\n\t     *      var myPresence = 'At lunch'\n\t     *                      || 4\n\t     *                      || { status: 'Away', message: 'At lunch' }\n\t     *                      || ['Away', 'At lunch'];\n\t     *\n\t     *      client.setPresence({\n\t     *          presence: myPresence,\n\t     *          onSuccess: function (evt) {\n\t     *              // successfully updated my presence\n\t     *          }\n\t     *      });\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     *\n\t     * ### Resolving presence\n\t     *\n\t     * When not using a custom endpoint presence resolver\n\t     * (see `respoke.createClient({ resolveEndpointPresence: <Function> })`)\n\t     * these are the supported presence values. Values not below will be put at the end of the\n\t     * list when resolving an endpoint's presence across the presence of its connections.\n\t     *\n\t     * ```\n\t     * ['chat', 'available', 'away', 'dnd', 'xa', 'unavailable']\n\t     * ```\n\t     *\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.setPresence\n\t     * @param {object} params\n\t     * @param {string|number|object|array} params.presence\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @return {Promise|undefined}\n\t     */\n\t    that.setPresence = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        params = params || {};\n\t        params.presence = params.presence || 'available';\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        }\n\t\n\t        log.info('sending my presence update ' + params.presence);\n\t\n\t        promise = that.signalingChannel.sendPresence({\n\t            presence: params.presence\n\t        }).then(function successHandler(p) {\n\t            that.presence = params.presence;\n\t\n\t            /**\n\t             * This event indicates that the presence for this endpoint has been updated.\n\t             * @event respoke.Client#presence\n\t             * @type {respoke.Event}\n\t             * @property {string|number|object|Array} presence\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            that.fire('presence', {\n\t                presence: that.presence\n\t            });\n\t        });\n\t        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Get the Call with the endpoint specified.\n\t     *\n\t     *     // hang up on chad\n\t     *     var call = client.getCall({\n\t     *         endpointId: 'chad'\n\t     *     });\n\t     *\n\t     *     if (call) {\n\t     *         call.hangup()\n\t     *     }\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getCall\n\t     * @param {object} params\n\t     * @param {string} [params.id] - Call ID.\n\t     * @param {string} [params.endpointId] - Endpoint ID. Warning: If you pass only the endpointId, this method\n\t     * will just return the first call that matches. If you are placing multiple calls to the same endpoint,\n\t     * pass in the call ID, too.\n\t     * @arg {boolean} [params.create] - whether or not to create a new call if the specified endpointId isn't found\n\t     * @arg {string} [params.fromType] - fromType from the signal, tells us if this is a SIP or DID call.\n\t     * @arg {string} [params.target] - target from the signal, tells us if this is a screenshare or conference call.\n\t     * @arg {*} [params.metadata] - Metadata to be attached to the call if created, accessible by the callee.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.getCall = function (params) {\n\t        var call = null;\n\t        var methods = {\n\t            screenshare: \"startScreenShare\",\n\t            did: \"startPhoneCall\",\n\t            web: \"startCall\",\n\t            sip: \"startSIPCall\",\n\t            conference: \"joinConference\"\n\t        };\n\t        var callParams = {};\n\t        params.fromType = params.type || \"web\";\n\t        var switchType = params.type;\n\t\n\t        that.calls.every(function findCall(one) {\n\t            if (params.id && one.id === params.id) {\n\t                call = one;\n\t                return false;\n\t            }\n\t\n\t            if (!params.id && params.endpointId && one.remoteEndpoint.id === params.endpointId) {\n\t                call = one;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t\n\t        if (call || params.create !== true) {\n\t            return call;\n\t        }\n\t\n\t        callParams.id = params.id;\n\t        callParams.caller = false;\n\t        callParams.fromType = \"web\";\n\t        callParams.callerId = params.callerId;\n\t        callParams.target = params.target;\n\t        callParams.metadata = params.metadata;\n\t\n\t        if (params.target === \"conference\") {\n\t            callParams.id = params.conferenceId;\n\t            switchType = params.target;\n\t        } else if (params.target === \"screenshare\") {\n\t            switchType = params.target;\n\t        }\n\t\n\t        switch (switchType) {\n\t            case \"screenshare\":\n\t            case \"web\":\n\t                callParams.toType = \"web\"; // overwrite \"screenshare\"\n\t                callParams.endpointId = params.endpointId;\n\t                break;\n\t            case \"did\":\n\t                callParams.number = params.endpointId;\n\t                callParams.toType = \"did\";\n\t                break;\n\t            case \"sip\":\n\t                callParams.uri = params.endpointId;\n\t                callParams.toType = \"sip\";\n\t                break;\n\t        }\n\t\n\t        try {\n\t            call = that[methods[params.type]](callParams);\n\t        } catch (e) {\n\t            log.error(\"Couldn't create Call.\", e.message, e.stack);\n\t        }\n\t        return call;\n\t    };\n\t\n\t    /**\n\t     * Add the call to internal record-keeping.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.addCall\n\t     * @param {object} evt\n\t     * @param {respoke.Call} evt.call\n\t     * @private\n\t     */\n\t    function addCall(evt) {\n\t        log.debug('addCall');\n\t        if (!evt.call) {\n\t            throw new Error(\"Can't add call without a call parameter.\");\n\t        }\n\t        if (that.calls.indexOf(evt.call) === -1) {\n\t            that.calls.push(evt.call);\n\t        }\n\t\n\t        evt.call.listen('hangup', function () {\n\t            removeCall({ call: evt.call });\n\t        }, true);\n\t    }\n\t\n\t    /**\n\t     * Remove the call or direct connection from internal record-keeping.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.removeCall\n\t     * @param {object} evt\n\t     * @param {respoke.Call} evt.call\n\t     * @private\n\t     */\n\t    function removeCall(evt) {\n\t        var match = 0;\n\t        if (!evt.call) {\n\t            throw new Error(\"Can't remove call without a call parameter.\");\n\t        }\n\t\n\t        // Loop backward since we're modifying the array in place.\n\t        for (var i = that.calls.length - 1; i >= 0; i -= 1) {\n\t            if (that.calls[i].id === evt.call.id) {\n\t                that.calls.splice(i, 1);\n\t                match += 1;\n\t            }\n\t        }\n\t\n\t        if (match !== 1) {\n\t            log.warn(\"Something went wrong.\", match, \"calls were removed!\");\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Convenience method for setting presence to `\"available\"`.\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.setOnline\n\t     * @param {object} params\n\t     * @param {string|number|object|Array} [params.presence=available] - The presence to set.\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.setOnline = function (params) {\n\t        var promise;\n\t\n\t        params = params || {};\n\t        params.presence = params.presence || 'available';\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        }\n\t\n\t        return that.setPresence(params);\n\t    };\n\t\n\t    /**\n\t     * Convenience method for setting presence to `\"unavailable\"`.\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.setOffline\n\t     * @param {object} params\n\t     * @param {string|number|object|Array} [params.presence=unavailable] - The presence to set.\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.setOffline = function (params) {\n\t        var promise;\n\t\n\t        params = params || {};\n\t        params.presence = params.presence || 'unavailable';\n\t\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        }\n\t\n\t        return that.setPresence(params);\n\t    };\n\t\n\t    /**\n\t     * Send a message to an endpoint.\n\t     *\n\t     *     client.sendMessage({\n\t     *         endpointId: 'dan',\n\t     *         message: \"Jolly good.\"\n\t     *     });\n\t     *\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.sendMessage\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The endpoint id of the recipient.\n\t     * @param {string} [params.connectionId] - The optional connection id of the receipient. If not set, message will be\n\t     * broadcast to all connections for this endpoint.\n\t     * @param {string} params.message - a string message.\n\t     * @param {sendHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        var endpoint;\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            promise = Q.reject(e);\n\t            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t            return retVal;\n\t        }\n\t        endpoint = that.getEndpoint({\n\t            skipPresence: true,\n\t            id: params.endpointId\n\t        });\n\t        delete params.endpointId;\n\t        return endpoint.sendMessage(params);\n\t    };\n\t\n\t    /**\n\t     * Experimental. Create a new conference call with the specified id.\n\t     *\n\t     *     client.joinConference({\n\t     *         id: \"javascript-meetup\",\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof respoke.Client\n\t     * @method respoke.Client.joinConference\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} params.id - The id that should be used to create the conference call or the ID\n\t     * of the call to join.\n\t     * @param {string|boolean} params.audio - Whether participant should send and receive audio. Boolean `true`\n\t     * indicates send and receive. Boolean `false` indicates neither send nor receive. Strings `send` and `receive`\n\t     * indicate send only and receive only respectively.\n\t     * @param {string|boolean} params.video - Whether participant should send and receive audio. Boolean `true`\n\t     * indicates send and receive. Boolean `false` indicates neither send nor receive. Strings `send` and `receive`\n\t     * indicate send only and receive only respectively.\n\t     * @param {boolean} params.mixAudio - Whether Respoke should mix all the audio streams together to save bandwidth\n\t     * for this one participant.\n\t     * @param {Array<RTCConstraints>} [params.constraints]\n\t     * @arg {respoke.Conference.onJoin} [params.onJoin] - Callback for when a participant joins the conference.\n\t     * @arg {respoke.Conference.onLeave} [params.onLeave] - Callback for when a participant leaves the conference.\n\t     * @arg {respoke.Conference.onMessage} [params.onMessage] - Callback for when a message is sent to the conference.\n\t     * @param {respoke.Conference.onMute} [params.onMute] - Callback for when local or remote media is muted or unmuted.\n\t     * @arg {respoke.Conference.onTopic} [params.onTopic] - Callback for the conference topic changes.\n\t     * @arg {respoke.Conference.onPresenter} [params.onPresenter] - Callback for when the presenter changes.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n\t     * and the remote party has received the video.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the conference call, accessible by the callee.\n\t     * @returns {respoke.Conference}\n\t     */\n\t    that.joinConference = function (params) {\n\t        var conference;\n\t        var recipient;\n\t\n\t        that.verifyConnected();\n\t\n\t        params = params || {};\n\t        params.open = !!params.open;\n\t\n\t        if (!params.id) {\n\t            params.id = respoke.makeGUID();\n\t        }\n\t\n\t        recipient = {id: params.id};\n\t\n\t        if (params.open) {\n\t            params.key = undefined;\n\t        } else if (!params.key) {\n\t            params.key = respoke.makeGUID();\n\t        }\n\t\n\t        params.instanceId = instanceId;\n\t        params.target = \"conference\";\n\t        params.constraints = respoke.convertConstraints(params.constraints, [{\n\t            video: false,\n\t            audio: true,\n\t            mandatory: {},\n\t            optional: []\n\t        }]);\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = params.target;\n\t            signalParams.id = params.id;\n\t            signalParams.key = params.key;\n\t            signalParams.open = params.open;\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = \"conference\";\n\t            signalParams.metadata = params.metadata;\n\t\n\t            that.signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'answer';\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = recipient;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalParams.toType = \"conference\";\n\t            that.signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = params.target;\n\t            signalParams.connectionId = signalParams.call.connectionId;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = \"conference\";\n\t            that.signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalModify = function (signalParams) {\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = recipient;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalParams.toType = \"conference\";\n\t            that.signalingChannel.sendModify(signalParams).done();\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = recipient;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalParams.toType = \"conference\";\n\t            return that.signalingChannel.sendCandidate(signalParams);\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = recipient;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalParams.toType = \"conference\";\n\t            that.signalingChannel.sendHangup(signalParams).done();\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            log.debug(\"Sending debug report\", signalParams.report);\n\t            that.signalingChannel.sendReport(signalParams).done();\n\t        };\n\t\n\t        params.signalingChannel = that.signalingChannel;\n\t        conference = respoke.Conference(params);\n\t        addCall({ call: conference.call });\n\t        return conference;\n\t    };\n\t\n\t    /**\n\t     * Create a new screen sharing call. Screenshares are inherently unidirectional video only. This may change\n\t     * in the future when Chrome adds the ability to obtain screen video and microphone audio at the same time. For\n\t     * now, if you also need audio, place a second audio only call.\n\t     *\n\t     * The endpoint who calls `client.startScreenShare` will be the one whose screen is shared. If you'd like to\n\t     * implement this as a screenshare request in which the endpoint who starts the call is the watcher and\n\t     * not the sharer, it is recommened that you use `endpoint.sendMessage` to send a control message to the user\n\t     * whose screenshare is being requested so that user's app can call `client.startScreenShare`.\n\t     *\n\t     * NOTE: At this time, screen sharing only works with Chrome, and Chrome requires a Chrome extension to\n\t     * access screen sharing features. Please see instructions at https://github.com/respoke/respoke-chrome-extension.\n\t     * Support for additional browsers will be added in the future.\n\t     *\n\t     *     client.startScreenShare({\n\t     *         endpointId: 'tian',\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startScreenShare\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The id of the endpoint that should be called.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n\t     * and the remote party has received the video.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {string} [params.source] - Pass in what type of mediaSource you want. If omitted, you'll have access\n\t     * to both the screen and windows. In firefox, you'll have access to the screen only.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the screenShare, accessible by the callee.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startScreenShare = function (params) {\n\t        that.verifyConnected();\n\t        var endpoint = that.getEndpoint({\n\t            skipPresence: true,\n\t            id: params.endpointId\n\t        });\n\t        delete params.endpointId;\n\t        return endpoint.startScreenShare(params);\n\t    };\n\t\n\t    /**\n\t     * Place an audio and/or video call to an endpoint.\n\t     *\n\t     *     // defaults to video when no constraints are supplied\n\t     *     client.startCall({\n\t     *         endpointId: 'erin',\n\t     *         onConnect: function (evt) { },\n\t     *         onLocalMedia: function (evt) { }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startCall\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The id of the endpoint that should be called.\n\t     * @param {Array<RTCConstraints>} [params.constraints]\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have\n\t     * local video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have\n\t     * remote video attached to it.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the call, accessible by the callee.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startCall = function (params) {\n\t        that.verifyConnected();\n\t        var endpoint = that.getEndpoint({\n\t            skipPresence: true,\n\t            id: params.endpointId\n\t        });\n\t        delete params.endpointId;\n\t        return endpoint.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Place an audio only call to an endpoint.\n\t     *\n\t     *     client.startAudioCall({\n\t     *         endpointId: 'erin',\n\t     *         onConnect: function (evt) { },\n\t     *         onLocalMedia: function (evt) { }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startAudioCall\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The id of the endpoint that should be called.\n\t     * @param {string} [params.connectionId]\n\t     * @param {Array<RTCConstraints>} [params.constraints]\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n\t     * video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n\t     * video attached to it.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the audio call, accessible by the callee.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startAudioCall = function (params) {\n\t        that.verifyConnected();\n\t        var endpoint = that.getEndpoint({\n\t            skipPresence: true,\n\t            id: params.endpointId\n\t        });\n\t        delete params.endpointId;\n\t        return endpoint.startAudioCall(params);\n\t    };\n\t\n\t    /**\n\t     * Place a video call to an endpoint.\n\t     *\n\t     *     client.startVideoCall({\n\t     *         endpointId: 'erin',\n\t     *         onConnect: function (evt) { },\n\t     *         onLocalMedia: function (evt) { }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startVideoCall\n\t     * @param {object} params\n\t     * @param {string} params.endpointId - The id of the endpoint that should be called.\n\t     * @param {Array<RTCConstraints>} [params.constraints]\n\t     * @param {string} [params.connectionId]\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n\t     * video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n\t     * video attached to it.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the video call, accessible by the callee.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startVideoCall = function (params) {\n\t        that.verifyConnected();\n\t        var endpoint = that.getEndpoint({\n\t            skipPresence: true,\n\t            id: params.endpointId\n\t        });\n\t        delete params.endpointId;\n\t        return endpoint.startVideoCall(params);\n\t    };\n\t\n\t    /**\n\t     * Place an audio call with a phone number.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startPhoneCall\n\t     * @param {object} params\n\t     * @param {string} params.number - The phone number that should be called.\n\t     * @param {string} params.callerId - The phone number to use as the caller ID for this phone call. This must\n\t     * be a phone number listed in your Respoke account, associated with your app, and allowed by the role\n\t     * that this client is authenticated with. If the role contains a list of numbers and the token does not contain\n\t     * callerId, this field must be used to set caller ID selected from the list of numbers or no caller ID will be set.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the phone call, accessible by the callee.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startPhoneCall = function (params) {\n\t        var call;\n\t        var recipient = {};\n\t        params = params || {};\n\t        params.constraints = [{\n\t            video: false,\n\t            audio: true,\n\t            mandatory: {},\n\t            optional: []\n\t        }];\n\t\n\t        that.verifyConnected();\n\t\n\t        if (!params.number) {\n\t            throw new Error(\"Can't start a phone call without a number.\");\n\t        }\n\t\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        recipient.id = params.number;\n\t\n\t        params.instanceId = instanceId;\n\t        params.remoteEndpoint = recipient;\n\t\n\t        params.toType = params.toType || 'did';\n\t        params.fromType = params.fromType || 'web';\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalParams.metadata = params.metadata;\n\t\n\t            // using hasOwnProperty here because callerId could be explicitly set to null or empty string\n\t            if (params.hasOwnProperty('callerId')) {\n\t                signalParams.callerId = {number: params.callerId};\n\t            }\n\t            that.signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'answer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            that.signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            that.signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send connected.\", err.message, err.stack);\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalModify = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            that.signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send modify.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            return that.signalingChannel.sendCandidate(signalParams);\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            that.signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            log.debug(\"Sending debug report\", signalParams.report);\n\t            that.signalingChannel.sendReport(signalParams);\n\t        };\n\t\n\t        params.signalingChannel = that.signalingChannel;\n\t        call = respoke.Call(params);\n\t        addCall({ call: call });\n\t        return call;\n\t    };\n\t\n\t    /**\n\t     * Place an audio call to a SIP URI.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.startSIPCall\n\t     * @param {object} params\n\t     * @param {string} [params.uri] - The fully qualified SIP URI to call.\n\t     * @param {string} [params.trunk] - The SIP trunk to call. This is not necessary if `uri` is set. If `uri` is not\n\t     * set, both `trunk` and `user` are required, and `trunk` must be the ID of a Respoke SIP trunk. `user` is a\n\t     * SIP username or extension.\n\t     * @param {string} [params.user] - The SIP user to call. This is not necessary if `uri` is set. If `uri` is not\n\t     * set, both `trunk` and `user` are required, and `trunk` must be the ID of a Respoke SIP trunk. `user` is a\n\t     * SIP username or extension.\n\t     * @param {object} [params.callerId] - Caller ID information for this call.\n\t     * @param {string} [params.callerId.name] - Caller ID name.\n\t     * @param {string} [params.callerId.number] - Caller ID number, extension, or SIP username.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n\t     * with the local audio and/or video attached.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n\t     * with the remote audio and/or video attached.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n\t     * up.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the SIP call, accessible by the callee.\n\t     * @return {respoke.Call}\n\t     */\n\t    that.startSIPCall = function (params) {\n\t        var call;\n\t        var recipient = {};\n\t        params = params || {};\n\t        params.constraints = [{\n\t            video: false,\n\t            audio: true,\n\t            mandatory: {},\n\t            optional: []\n\t        }];\n\t\n\t        that.verifyConnected();\n\t\n\t        if (!params.uri && !(params.trunk && params.user)) {\n\t            throw new Error(\"Can't start a phone call without a SIP URI or a SIP trunk and user.\");\n\t        }\n\t\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        params.uri = params.uri || (params.trunk + \"/\" + params.user);\n\t        recipient.id = params.uri;\n\t\n\t        params.instanceId = instanceId;\n\t        params.remoteEndpoint = recipient;\n\t\n\t        params.toType = params.toType || 'sip';\n\t        params.fromType = params.fromType || 'web';\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            signalParams.metadata = params.metadata;\n\t\n\t            // using hasOwnProperty here because callerId could be explicitly set to null or empty string\n\t            if (params.hasOwnProperty('callerId')) {\n\t                signalParams.callerId = params.callerId;\n\t            }\n\t            that.signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'answer';\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            that.signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            that.signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send connected.\", err.message, err.stack);\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalModify = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            that.signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send modify.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            return that.signalingChannel.sendCandidate(signalParams);\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = 'call';\n\t            signalParams.recipient = recipient;\n\t            signalParams.toType = params.toType;\n\t            signalParams.fromType = params.fromType;\n\t            that.signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n\t                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n\t            });\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            log.debug(\"Sending debug report\", signalParams.report);\n\t            that.signalingChannel.sendReport(signalParams);\n\t        };\n\t\n\t        params.signalingChannel = that.signalingChannel;\n\t        call = respoke.Call(params);\n\t        addCall({ call: call });\n\t        return call;\n\t    };\n\t\n\t    /**\n\t     * Assert that we are connected to the backend infrastructure.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.verifyConnected\n\t     * @throws {Error}\n\t     * @private\n\t     */\n\t    that.verifyConnected = function () {\n\t        if (!that.signalingChannel.isConnected()) {\n\t            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Check whether this client is connected to the Respoke API.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.isConnected\n\t     * @returns boolean\n\t     */\n\t    that.isConnected = function () {\n\t        return that.signalingChannel.isConnected();\n\t    };\n\t\n\t    /**\n\t     * Join a group and begin keeping track of it. If this method is called multiple times synchronously, it will\n\t     * batch requests and only make one API call to Respoke.\n\t     *\n\t     * You can leave the group by calling `group.leave()`;\n\t     *\n\t     * ##### Joining and leaving a group\n\t     *\n\t     *      var group;\n\t     *\n\t     *      client.join({\n\t     *          id: \"book-club\",\n\t     *          onSuccess: function (evt) {\n\t     *              console.log('I joined', evt.group.id);\n\t     *              // \"I joined book-club\"\n\t     *              group = evt.group;\n\t     *              group.sendMessage({\n\t     *                  message: 'sup'\n\t     *              });\n\t     *          }\n\t     *      });\n\t     *\n\t     *      // . . .\n\t     *      // Some time later, leave the group.\n\t     *      // . . .\n\t     *      group.leave({\n\t     *          onSuccess: function (evt) {\n\t     *              console.log('I left', evt.group.id);\n\t     *              // \"I left book-club\"\n\t     *          }\n\t     *      });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.join\n\t     * @param {object} params\n\t     * @param {string} params.id - The name of the group.\n\t     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {respoke.Group.onMessage} [params.onMessage] - Message handler for messages from this group only.\n\t     * @param {respoke.Group.onJoin} [params.onJoin] - Join event listener for endpoints who join this group only.\n\t     * @param {respoke.Group.onLeave} [params.onLeave] - Leave event listener for endpoints who leave\n\t     * this group only.\n\t     * @returns {Promise<respoke.Group>|undefined} The instance of the respoke.Group which the client joined.\n\t     * @fires respoke.Client#join\n\t     */\n\t    that.join = function (params) {\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t        try {\n\t            that.verifyConnected();\n\t        } catch (e) {\n\t            deferred.reject(e);\n\t            return retVal;\n\t        }\n\t\n\t        if (!params.id) {\n\t            deferred.reject(new Error(\"Can't join a group with no group id.\"));\n\t            return retVal;\n\t        }\n\t\n\t        log.trace('requested to join group', params.id);\n\t\n\t        that.signalingChannel.joinGroup({\n\t            groupList: [params.id]\n\t        }).done(function successHandler() {\n\t            var group;\n\t            params.signalingChannel = that.signalingChannel;\n\t            params.instanceId = instanceId;\n\t\n\t            group = that.getGroup({id: params.id});\n\t\n\t            if (!group) {\n\t                group = respoke.Group(params);\n\t                that.addGroup(group);\n\t            }\n\t\n\t            group.listen('join', params.onJoin);\n\t            group.listen('leave', params.onLeave);\n\t            group.listen('message', params.onMessage);\n\t\n\t            group.addMember({\n\t                connection: that.getConnection({\n\t                    endpointId: that.endpointId,\n\t                    connectionId: that.connectionId\n\t                })\n\t            });\n\t\n\t            /**\n\t             * This event is fired every time the client joins a group. If the client leaves\n\t             * a group, this event will be fired again on the next time the client joins the group.\n\t             * @event respoke.Client#join\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Group} group\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.fire('join', {\n\t                group: group\n\t            });\n\t            deferred.resolve(group);\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Add a Group. This is called when we join a group and need to begin keeping track of it.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.addGroup\n\t     * @param {respoke.Group}\n\t     * @private\n\t     */\n\t    that.addGroup = function (newGroup) {\n\t        if (!newGroup || newGroup.className !== 'respoke.Group') {\n\t            throw new Error(\"Can't add group to internal tracking without a group.\");\n\t        }\n\t\n\t        newGroup.listen('leave', function leaveHandler(evt) {\n\t            var endpointThatLeft = evt.connection.getEndpoint();\n\t\n\t            if (!endpointThatLeft.hasListeners('presence') && endpointThatLeft.groupConnectionCount === 0) {\n\t                // No one is listening, and it's not in any more groups.\n\t                endpoints.every(function eachEndpoint(ept, index) {\n\t                    if (ept.id === endpointThatLeft.id) {\n\t                        endpoints.splice(index, 1);\n\t                        return false;\n\t                    }\n\t                    return true;\n\t                });\n\t            }\n\t        }, true);\n\t\n\t        groups.push(newGroup);\n\t    };\n\t\n\t    /**\n\t     * Get a list of all the groups the client is currently a member of.\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getGroups\n\t     * @returns {Array<respoke.Group>} All of the groups the library is aware of.\n\t     */\n\t    that.getGroups = function () {\n\t        return groups;\n\t    };\n\t\n\t    /**\n\t     * Find a group by id and return it.\n\t     *\n\t     *     var group = client.getGroup({\n\t     *         id: \"resistance\"\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getGroup\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     * @param {respoke.Group.onJoin} [params.onJoin] - Receive notification that an endpoint has joined this group.\n\t     * @param {respoke.Group.onLeave} [params.onLeave] - Receive notification that an endpoint has left this group.\n\t     * @param {respoke.Group.onMessage} [params.onMessage] - Receive notification that a message has been\n\t     * received to a group.\n\t     * @returns {respoke.Group|undefined} The group whose ID was specified.\n\t     */\n\t    that.getGroup = function (params) {\n\t        var group;\n\t        if (!params || !params.id) {\n\t            throw new Error(\"Can't get a group without group id.\");\n\t        }\n\t\n\t        groups.every(function eachGroup(grp) {\n\t            if (grp.id === params.id) {\n\t                group = grp;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t\n\t        if (group) {\n\t            group.listen('join', params.onJoin);\n\t            group.listen('leave', params.onLeave);\n\t            group.listen('message', params.onMessage);\n\t        }\n\t\n\t        return group;\n\t    };\n\t\n\t    /**\n\t     * Find an endpoint by id and return the `respoke.Endpoint` object.\n\t     *\n\t     * If it is not already cached locally, will be added to the local cache of tracked endpoints,\n\t     * its presence will be determined, and will be available in `client.getEndpoints()`.\n\t     *\n\t     *     var endpoint = client.getEndpoint({\n\t     *         id: \"dlee\"\n\t     *     });\n\t     *\n\t     * @ignore If the endpoint is not found in the local cache of endpoint objects (see `client.getEndpoints()`),\n\t     * it will be created. This is useful, for example, in the case of dynamic endpoints where groups are\n\t     * not in use. Override dynamic endpoint creation by setting `params.skipCreate = true`.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getEndpoint\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     * @param {respoke.Endpoint.onMessage} [params.onMessage] - Handle messages sent to the logged-in user\n\t     * from this one Endpoint.\n\t     * @param {respoke.Endpoint.onPresence} [params.onPresence] - Handle presence notifications from this one\n\t     * Endpoint.\n\t     * @arg {boolean} [params.skipCreate] - Skip the creation step and return undefined if we don't yet\n\t     * @arg {boolean} [params.skipPresence] - Skip registering for this endpoint's presence.\n\t     * @returns {respoke.Endpoint} The endpoint whose ID was specified.\n\t     */\n\t    that.getEndpoint = function (params) {\n\t        var endpoint;\n\t        if (!params || !params.id) {\n\t            throw new Error(\"Can't get an endpoint without endpoint id.\");\n\t        }\n\t\n\t        endpoints.every(function eachEndpoint(ept) {\n\t            if (ept.id === params.id) {\n\t                endpoint = ept;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t\n\t        if (!endpoint && params && !params.skipCreate) {\n\t            params.instanceId = instanceId;\n\t            params.signalingChannel = that.signalingChannel;\n\t            params.resolveEndpointPresence = clientSettings.resolveEndpointPresence;\n\t            params.addCall = addCall;\n\t\n\t            endpoint = respoke.Endpoint(params);\n\t            endpoints.push(endpoint);\n\t        }\n\t\n\t        if (!endpoint) {\n\t            return;\n\t        }\n\t\n\t        if (params.skipPresence !== true) {\n\t            that.signalingChannel.registerPresence({\n\t                endpointList: [endpoint.id]\n\t            }).done(null, function (err) {\n\t                log.error(\"Couldn't register for presence on\", endpoint.id, err.message);\n\t            });\n\t        }\n\t        endpoint.listen('presence', params.onPresence);\n\t        endpoint.listen('message', params.onMessage);\n\t\n\t        return endpoint;\n\t    };\n\t\n\t    /**\n\t     * Find a Connection by id and return it.\n\t     *\n\t     *     var connection = client.getConnection({\n\t     *         id: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\"\n\t     *     });\n\t     *\n\t     * @ignore In most cases, if we don't find it we will create it. This is useful\n\t     * in the case of dynamic endpoints where groups are not in use. Set skipCreate=true\n\t     * to return undefined if the Connection is not already known.\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getConnection\n\t     * @param {object} params\n\t     * @param {string} params.connectionId\n\t     * @param {string} [params.endpointId] - An endpointId to use in the creation of this connection.\n\t     * @param {respoke.Endpoint.onMessage} [params.onMessage] - Handle messages sent to the logged-in user\n\t     * from this one Connection.\n\t     * @param {respoke.Endpoint.onPresence} [params.onPresence] - Handle presence notifications from this one\n\t     * Connection.\n\t     * @returns {respoke.Connection} The connection whose ID was specified.\n\t     */\n\t    that.getConnection = function (params) {\n\t        var connection;\n\t        var endpoint;\n\t        var endpointsToSearch = endpoints;\n\t\n\t        params = params || {};\n\t        if (!params.connectionId) {\n\t            throw new Error(\"Can't get a connection without connection id.\");\n\t        }\n\t        if (!params.endpointId && !params.skipCreate) {\n\t            throw new Error(\"Can't create a connection without endpoint id.\");\n\t        }\n\t\n\t        if (params.endpointId) {\n\t            endpoint = that.getEndpoint({\n\t                id: params.endpointId,\n\t                skipPresence: true,\n\t                skipCreate: params.skipCreate\n\t            });\n\t\n\t            endpointsToSearch = [];\n\t            if (endpoint) {\n\t                endpointsToSearch = [endpoint];\n\t            }\n\t        }\n\t\n\t        endpointsToSearch.every(function eachEndpoint(ept) {\n\t            connection = ept.getConnection(params);\n\t            return !connection;\n\t        });\n\t\n\t        if (!connection && !params.skipCreate) {\n\t            params.instanceId = instanceId;\n\t            connection = respoke.Connection(params);\n\t            endpoint.connections.push(connection);\n\t        }\n\t\n\t        return connection;\n\t    };\n\t\n\t    /**\n\t     * Get the list of **all endpoints** that the library has knowledge of.\n\t     * These are `respoke.Endpoint` objects, not just the endpointIds.\n\t     *\n\t     * The library gains knowledge of an endpoint in two ways:\n\t     * 1. when an endpoint joins a group that the user (currently logged-in endpoint) is a member of (if group presence is enabled)\n\t     * 2. when an endpoint that the user (currently logged-in endpoint) is watching*\n\t     *\n\t     * *If an endpoint that the library does not know about sends a message to the client, you\n\t     * can immediately call the `client.getEndpoint()` method on the sender of the message to enable\n\t     * watching of the sender's endpoint.\n\t     *\n\t     *      client.on('message', function (data) {\n\t     *          if (data.endpoint) {\n\t     *              // start tracking this endpoint.\n\t     *              client.getEndpoint({ id: data.endpoint.id });\n\t     *          }\n\t     *      });\n\t     *\n\t     *\n\t     * @memberof! respoke.Client\n\t     * @method respoke.Client.getEndpoints\n\t     * @returns {Array<respoke.Endpoint>}\n\t     */\n\t    that.getEndpoints = function () {\n\t        return endpoints;\n\t    };\n\t\n\t    /**\n\t     * Get conference participants by conference id.\n\t     *\n\t     * ```\n\t     * client.getConferenceParticipants({ id: 'mygroup' }).done(function (participants) {\n\t     *     var ids = participants.map(function (p) { return p.endpointId; });\n\t     *     console.log(ids); // ['person1', 'person2']\n\t     * });\n\t     * ```\n\t     * @memberof respoke.Client\n\t     * @method respoke.Client.getConferenceParticipants\n\t     * @private\n\t     * @param object {params}\n\t     * @param string {params.id}\n\t     * @returns {Promise}\n\t     */\n\t    that.getConferenceParticipants = that.signalingChannel.getConferenceParticipants;\n\t\n\t    return that;\n\t}; // End respoke.Client\n\t\n\t/**\n\t * Handle sending successfully.\n\t * @callback respoke.Client.successHandler\n\t */\n\t/**\n\t * Handle joining a group successfully. This callback is called only once when Client.join() is called.\n\t * @callback respoke.Client.joinHandler\n\t * @param {respoke.Group} group\n\t */\n\t/**\n\t * Receive notification that the client has joined a group. This callback is called everytime\n\t * respoke.Client#join is fired.\n\t * @callback respoke.Client.onJoin\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Group} evt.group\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * Receive notification that the client has left a group. This callback is called everytime\n\t * respoke.Client#leave is fired.\n\t * @callback respoke.Client.onLeave\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Group} evt.group\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * Receive notification that a message has been received. This callback is called every time\n\t * respoke.Client#message is fired.\n\t * @callback respoke.Client.onClientMessage\n\t * @param {respoke.Event} evt\n\t * @param {respoke.TextMessage} evt.message\n\t * @param {respoke.Group} [evt.group] - If the message is to a group we already know about,\n\t * this will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\n\t * the group. From that point forward, Group#message will fire when a message is received as well. If\n\t * group is undefined instead of null, the message is not a group message at all.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Client} evt.target\n\t */\n\t/**\n\t * Receive notification that the client is receiving a call from a remote party. This callback is called every\n\t * time respoke.Client#call is fired.\n\t * @callback respoke.Client.onCall\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Call} evt.call\n\t * @param {respoke.Endpoint} evt.endpoint\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * Receive notification that the client is receiving a request for a direct connection from a remote party.\n\t * This callback is called every time respoke.Client#direct-connection is fired.\n\t * @callback respoke.Client.onDirectConnection\n\t * @param {respoke.Event} evt\n\t * @param {respoke.DirectConnection} evt.directConnection\n\t * @param {respoke.Endpoint} evt.endpoint\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * Receive notification Respoke has successfully connected to the cloud. This callback is called every time\n\t * respoke.Client#connect is fired.\n\t * @callback respoke.Client.onConnect\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Client} evt.target\n\t */\n\t/**\n\t * Receive notification Respoke has successfully disconnected from the cloud. This callback is called every time\n\t * respoke.Client#disconnect is fired.\n\t * @callback respoke.Client.onDisconnect\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Client} evt.target\n\t */\n\t/**\n\t * Receive notification Respoke has successfully reconnected to the cloud. This callback is called every time\n\t * respoke.Client#reconnect is fired.\n\t * @callback respoke.Client.onReconnect\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Client} evt.target\n\t */\n\t/**\n\t * Handle disconnection to the cloud successfully.\n\t * @callback respoke.Client.disconnectSuccessHandler\n\t */\n\t/**\n\t * Handle an error that resulted from a method call.\n\t * @callback respoke.Client.errorHandler\n\t * @params {Error} err\n\t */\n\t/**\n\t * Handle connection to the cloud successfully.\n\t * @callback respoke.Client.connectSuccessHandler\n\t */\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * A `respoke.Connection` always belongs to an Endpoint.\n\t *\n\t * There is a distinction between Endpoint and Connection because an Endpoint can be authenticated\n\t * from multiple devices, browsers, or browser tabs. Each of these separate authentications is a Connection.\n\t * A Client can choose to interact with connections of the same endpoint in different ways.\n\t *\n\t * @constructor\n\t * @class respoke.Connection\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.id\n\t * @returns {respoke.Connection}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Connection\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name client\n\t     * @type {respoke.Client}\n\t     * @private\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t\n\t    /**\n\t     * The connection id.\n\t     * @memberof! respoke.Connection\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = that.id || that.connectionId;\n\t    if (!that.id) {\n\t        throw new Error(\"Can't make a connection without an id.\");\n\t    }\n\t    delete that.instanceId;\n\t    delete that.connectionId;\n\t\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.Connection\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Connection';\n\t\n\t    /**\n\t     * Represents the presence status. Typically a string, but other types are supported.\n\t     * Defaults to `'unavailable'`.\n\t     *\n\t     * **Do not modify this directly** - it won't update presence with Respoke. Presence must be updated\n\t     * by the remote endpoint.\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @name presence\n\t     * @type {string|number|object|Array}\n\t     */\n\t    that.presence = 'unavailable';\n\t\n\t    /**\n\t     * Deprecated: use endpoint.presence instead.\n\t     *\n\t     * Return the presence.\n\t     * @memberof! respoke.Connection\n\t     * @deprecated\n\t     * @name presence\n\t     * @type {string|number|object|Array}\n\t     */\n\t    that.getPresence = function () {\n\t        return that.presence;\n\t    };\n\t\n\t    /**\n\t     * Send a message to this connection of an endpoint. If the endpoint has multiple connections,\n\t     * it will only receive the message at this connection.\n\t     *\n\t     *     connection.sendMessage({\n\t     *         message: \"PJ, put that PBR down!\"\n\t     *     });\n\t     *\n\t     * **Using callbacks** will disable promises.\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.sendMessage\n\t     * @param {object} params\n\t     * @param {string} params.message\n\t     * @param {boolean} [params.ccSelf=false] Copy this client's own endpoint on this message so that they arrive\n\t     * at other devices it might be logged into elsewhere.\n\t     * @param {boolean} [params.push=false] Whether or not the message should be considered for push notifications to\n\t     * mobile devices.\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation\n\t     * of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        params = params || {};\n\t        params.connectionId = that.id;\n\t        params.ccSelf = (typeof params.ccSelf === \"boolean\" ? params.ccSelf : false);\n\t        return that.getEndpoint().sendMessage(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new screen sharing call. Screenshares are inherently unidirectional video only. This may change\n\t     * in the future when Chrome adds the ability to obtain screen video and microphone audio at the same time. For\n\t     * now, if you also need audio, place a second audio only call.\n\t     *\n\t     * The endpoint who calls `connection.startScreenShare` will be the one whose screen is shared. If you'd like to\n\t     * implement this as a screenshare request in which the endpoint who starts the call is the watcher and\n\t     * not the sharer, it is recommened that you use `endpoint.sendMessage` to send a control message to the user\n\t     * whose screenshare is being requested so that user's app can call `connection.startScreenShare`.\n\t     *\n\t     * NOTE: At this time, screen sharing only works with Chrome, and Chrome requires a Chrome extension to\n\t     * access screen sharing features. Please see instructions at https://github.com/respoke/respoke-chrome-extension.\n\t     * Support for additional browsers will be added in the future.\n\t     *\n\t     *     connection.startScreenShare({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startScreenShare\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n\t     * and the remote party has received the video.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startScreenShare = function (params) {\n\t        client.verifyConnected();\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().startScreenShare(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new Call for a voice and/or video call this particular connection, only. The Call cannot be answered\n\t     * by another connection of this Endpoint.\n\t     *\n\t     *     connection.startCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {RTCConstraints} [params.constraints]\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n\t     * video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n\t     * video attached to it.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startCall = function (params) {\n\t        params = params || {};\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new audio-only call.\n\t     *\n\t     *     connection.startAudioCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startAudioCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startAudioCall = function (params) {\n\t        client.verifyConnected();\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().startAudioCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new call with audio and video.\n\t     *\n\t     *     connection.startVideoCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startVideoCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has\n\t     * been hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startVideoCall = function (params) {\n\t        client.verifyConnected();\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().startVideoCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new DirectConnection with this particular connection, only. The DirectConnection cannot be answered\n\t     * by another connection of this Endpoint.  This method creates a new Call as well, attaching this\n\t     * DirectConnection to it for the purposes of creating a peer-to-peer link for sending data such as messages to\n\t     * the other endpoint. Information sent through a DirectConnection is not handled by the cloud infrastructure.\n\t     *\n\t     *     connection.startDirectConnection({\n\t     *         onOpen: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.startDirectConnection\n\t     * @param {object} params\n\t     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess] - Success handler for this\n\t     * invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {respoke.DirectConnection.onStart} [params.onStart] - A callback for when setup of the direct\n\t     * connection begins. The direct connection will not be open yet.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - A callback for receiving notification of when\n\t     * the DirectConnection is open and ready to be used.\n\t     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n\t     * connection.\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - A callback for receiving notification of\n\t     * when the DirectConnection is closed and the two Endpoints are disconnected.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - A callback for receiving messages sent\n\t     * through the DirectConnection.\n\t     * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the\n\t     * request for a direct connection and setup begins.\n\t     * @returns {respoke.DirectConnection} The DirectConnection which can be used to send data and messages\n\t     * directly to the other endpoint.\n\t     */\n\t    that.startDirectConnection = function (params) {\n\t        var retVal;\n\t        var deferred;\n\t        params = params || {};\n\t\n\t        try {\n\t            client.verifyConnected();\n\t        } catch (err) {\n\t            deferred = respoke.Q.defer();\n\t            retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        params.connectionId = that.id;\n\t        return that.getEndpoint().startDirectConnection(params);\n\t    };\n\t\n\t    /**\n\t     * Get the Endpoint that this Connection belongs to.\n\t     * @memberof! respoke.Connection\n\t     * @method respoke.Connection.getEndpoint\n\t     * @returns {respoke.Endpoint}\n\t     */\n\t    that.getEndpoint = function () {\n\t        return client.getEndpoint({\n\t            id: that.endpointId,\n\t            skipPresence: true\n\t        });\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.Connection\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(8);\n\tvar respoke = __webpack_require__(1);\n\tvar log = respoke.log;\n\t\n\t/**\n\t * `respoke.Endpoint`s are users of a Respoke app.\n\t * An Endpoint can be a person in a browser or device, or an app using Respoke APIs from a server.\n\t * A Client can interact with endpoints through messages, audio or video calls, or direct connections.\n\t * An Endpoint may be authenticated from multiple devices to the same app (each of which is\n\t * represented by a Connection).\n\t *\n\t * ```\n\t * var jim = client.getEndpoint({ id: 'jim' });\n\t * ```\n\t *\n\t * @constructor\n\t * @class respoke.Endpoint\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.id\n\t * @param {string} params.instanceId\n\t * @param {respoke.client.resolvePresence} [params.resolvePresence] An optional function for resolving presence\n\t * for an endpoint.\n\t * @returns {respoke.Endpoint}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Endpoint\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name client\n\t     * @type {respoke.Client}\n\t     * @private\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name signalingChannel\n\t     * @type {respoke.SignalingChannel}\n\t     * @private\n\t     */\n\t    var signalingChannel = params.signalingChannel;\n\t    /**\n\t     * The number this endpoint's connections that are joined to groups. So if\n\t     * an endpoint has 3 connections in the same group, the\n\t     * `groupConnectionCount` for that endpoint would be 3.\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @name groupConnectionCount\n\t     * @type {number}\n\t     */\n\t    that.groupConnectionCount = 0;\n\t\n\t    var addCall = params.addCall;\n\t\n\t    delete that.signalingChannel;\n\t    delete that.instanceId;\n\t    delete that.connectionId;\n\t    delete that.addCall;\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.Endpoint\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Endpoint';\n\t    /**\n\t     * A direct connection to this endpoint. This can be used to send direct messages.\n\t     * @memberof! respoke.Endpoint\n\t     * @name directConnection\n\t     * @type {respoke.DirectConnection}\n\t     */\n\t    that.directConnection = null;\n\t\n\t    /**\n\t     * Array of connections for this endpoint.\n\t     * @memberof! respoke.Endpoint\n\t     * @name connections\n\t     * @type {Array<respoke.Connection>}\n\t     */\n\t    that.connections = [];\n\t    client.listen('disconnect', function disconnectHandler() {\n\t        that.connections = [];\n\t    }, true);\n\t\n\t    var resolveEndpointPresence = params.resolveEndpointPresence;\n\t    delete that.resolveEndpointPresence;\n\t\n\t    /**\n\t     * Represents the presence status. Typically a string, but other types are supported.\n\t     * Defaults to `'unavailable'`.\n\t     *\n\t     * **Do not modify this directly** - it won't update presence with Respoke. Presence must be updated\n\t     * by the remote endpoint.\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @name presence\n\t     * @type {string|number|object|Array}\n\t     */\n\t    that.presence = 'unavailable';\n\t\n\t    /**\n\t     * Deprecated: use endpoint.presence instead.\n\t     *\n\t     * Return the presence.\n\t     * @memberof! respoke.Endpoint\n\t     * @deprecated\n\t     * @name presence\n\t     * @type {string|number|object|Array}\n\t     */\n\t    that.getPresence = function () {\n\t        return that.presence;\n\t    };\n\t\n\t    /**\n\t     * Internally set the presence on the object for this session upon receipt of a presence notification from\n\t     * the backend. Respoke developers shouldn't use this.\n\t     *\n\t     * While technically available on an Endpoint or Connection, this will not trigger\n\t     * any API changes. The changes will only be reflected locally.\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.setPresence\n\t     * @param {object} params\n\t     * @param {string|number|object|Array} [params.presence=available]\n\t     * @param {string} params.connectionId\n\t     * @fires respoke.Endpoint#presence\n\t     * @private\n\t     */\n\t    that.setPresence = function (params) {\n\t        var connection;\n\t        params = params || {};\n\t        params.presence = params.presence || 'available';\n\t        params.connectionId = params.connectionId || that.connectionId;\n\t\n\t        if (!params.connectionId) {\n\t            throw new Error(\"Can't set Endpoint presence without a connectionId.\");\n\t        }\n\t\n\t        connection = that.getConnection({connectionId: params.connectionId}) || client.getConnection({\n\t            connectionId: params.connectionId,\n\t            skipCreate: false,\n\t            endpointId: that.id\n\t        });\n\t\n\t        connection.presence = params.presence;\n\t        that.resolvePresence();\n\t\n\t        /**\n\t         * This event indicates that the presence for this endpoint has been updated.\n\t         * @event respoke.Endpoint#presence\n\t         * @type {respoke.Event}\n\t         * @property {string|number|object|Array} presence\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Endpoint} target\n\t         */\n\t        that.fire('presence', {\n\t            presence: that.presence\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Send a message to the endpoint through the infrastructure.\n\t     *\n\t     * ```\n\t     * endpoint.sendMessage({\n\t     *     message: \"wassuuuuup\"\n\t     * });\n\t     * ```\n\t     *\n\t     * **Using callbacks** will disable promises.\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.sendMessage\n\t     * @param {object} params\n\t     * @param {string} params.message\n\t     * @param {string} [params.connectionId]\n\t     * @param {boolean} [params.ccSelf=true] Copy this client's own endpoint on this message so that they arrive\n\t     * at other devices it might be logged into elsewhere.\n\t     * @param {boolean} [params.push=false] Whether or not to consider the message for push notifications to mobile\n\t     * devices.\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of this\n\t     * method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this method\n\t     * only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        var promise;\n\t        var retVal;\n\t        params = params || {};\n\t        params.ccSelf = (typeof params.ccSelf === \"boolean\" ? params.ccSelf : true);\n\t\n\t        promise = signalingChannel.sendMessage({\n\t            ccSelf: params.ccSelf,\n\t            connectionId: params.connectionId,\n\t            message: params.message,\n\t            push: !!params.push,\n\t            recipient: that\n\t        });\n\t\n\t        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Create a new audio-only call.\n\t     *\n\t     *     endpoint.startAudioCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startAudioCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the audio call, accessible by the callee.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startAudioCall = function (params) {\n\t        params = params || {};\n\t\n\t        params.constraints = respoke.convertConstraints(params.constraints, [{\n\t            video: false,\n\t            audio: true,\n\t            optional: [],\n\t            mandatory: {}\n\t        }]);\n\t\n\t        return that.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new call with audio and video.\n\t     *\n\t     *     endpoint.startVideoCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startVideoCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the video call, accessible by the callee.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startVideoCall = function (params) {\n\t        params = params || {};\n\t\n\t        params.constraints = respoke.convertConstraints(params.constraints, [{\n\t            video: true,\n\t            audio: true,\n\t            optional: [],\n\t            mandatory: {}\n\t        }]);\n\t\n\t        return that.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * The endpoint who calls `endpoint.startScreenShare` will be the one whose screen is shared. If you'd like to\n\t     * implement this as a screenshare request in which the endpoint who starts the call is the watcher and\n\t     * not the sharer, it is recommended that you use `endpoint.sendMessage` to send a control message to the user\n\t     * whose screenshare is being requested so that user's app can call `endpoint.startScreenShare`.\n\t     *\n\t     * By default, the call will be one-way screen share only, with the recipient sending nothing. To turn it into\n\t     * a bidirectional call with the recipient sending video and both parties sending audio, set `params.sendOnly`\n\t     * to false.\n\t     *\n\t     * NOTE: At this time, screen sharing only works with Chrome and Firefox, and both require browser extensions to\n\t     * access screen sharing features. Please see instructions at https://github.com/respoke/respoke-chrome-extension\n\t     * and https://github.com/respoke/respoke-firefox-screen-sharing-extension.\n\t     *\n\t     *     endpoint.startScreenShare({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startScreenShare\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n\t     * and the remote party has received the video.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {Array<RTCConstraints>} [params.constraints] - Additional media to add to the call.\n\t     * @param {RTCConstraints} [params.screenConstraints] - Overrides for the screen media.\n\t     * @param {boolean} [params.sendOnly=true] - Whether the call should be unidirectional.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {string} [params.source] - Pass in what type of mediaSource you want. If omitted, you'll have access\n\t     * to both the screen and windows. In firefox, you'll have access to the screen only.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the screenShare, accessible by the callee.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startScreenShare = function (params) {\n\t        params = params || {};\n\t        var hasAudio;\n\t        var addAudio;\n\t        params.target = 'screenshare';\n\t\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        // true and undefined -> true\n\t        // receiveOnly will be set in call.js by respoke.sdpHasSendOnly\n\t        params.sendOnly = (params.caller && (params.sendOnly || (params.sendOnly === undefined)));\n\t        addAudio = (!params.sendOnly && (!params.screenConstraints ||\n\t            (params.screenConstraints && params.screenConstraints.audio)));\n\t\n\t        if (params.caller) {\n\t            params.constraints = respoke.convertConstraints(params.constraints);\n\t            params.constraints.push(respoke.getScreenShareConstraints({\n\t                constraints: params.screenConstraints\n\t            }));\n\t            delete params.screenConstraints;\n\t\n\t            params.constraints.forEach(function (con) {\n\t                if (con.audio) {\n\t                    hasAudio = true;\n\t                }\n\t            });\n\t\n\t            /* If they didn't override screensharing constraints and no constraints so far have included audio,\n\t             * add audio to the call. If they overrode the default screensharing constraints, we'll assume they\n\t             * know what they are doing and didn't want audio.\n\t             */\n\t            if (addAudio && !hasAudio) {\n\t                params.constraints.push({\n\t                    audio: true,\n\t                    video: false\n\t                });\n\t            }\n\t        }\n\t\n\t        return that.startCall(params);\n\t    };\n\t\n\t    /**\n\t     * Create a new call.\n\t     *\n\t     *     endpoint.startCall({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startCall\n\t     * @param {object} params\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n\t     * element with the remote\n\t     * audio and/or video attached.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {Array<RTCConstraints>} [params.constraints]\n\t     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t     * @param {boolean} [params.sendOnly] - whether or not we send media\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n\t     * all connections belonging to this endpoint.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n\t     * video attached to it.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n\t     * video attached to it.\n\t     * @param {*} [params.metadata] - Metadata to be attached to the call, accessible by the callee.\n\t     * @returns {respoke.Call}\n\t     */\n\t    that.startCall = function (params) {\n\t        var call;\n\t        params = params || {};\n\t\n\t        params.constraints = respoke.convertConstraints(params.constraints, [{\n\t            video: true,\n\t            audio: true,\n\t            mandatory: {},\n\t            optional: []\n\t        }]);\n\t\n\t        // If they are requesting a screen share by constraints without having called startScreenShare\n\t        if (params.target !== 'screenshare' && params.constraints[0] &&\n\t                respoke.constraintsHasScreenShare(params.constraints[0])) {\n\t            return that.startScreenShare(params);\n\t        }\n\t\n\t        params.target = params.target || \"call\";\n\t\n\t        log.debug('Endpoint.call', params);\n\t        client.verifyConnected();\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        if (!that.id) {\n\t            log.error(\"Can't start a call without endpoint ID!\");\n\t            return;\n\t        }\n\t\n\t        params.instanceId = instanceId;\n\t        params.remoteEndpoint = that;\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = that;\n\t            signalParams.metadata = params.metadata;\n\t\n\t            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'answer';\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = that;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = params.target;\n\t            signalParams.connectionId = signalParams.call.connectionId;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalParams.recipient = that;\n\t            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalModify = function (signalParams) {\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = that;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalingChannel.sendModify(signalParams).done();\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = that;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            return signalingChannel.sendCandidate(signalParams);\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = params.target;\n\t            signalParams.recipient = that;\n\t            signalParams.sessionId = signalParams.call.sessionId;\n\t            signalingChannel.sendHangup(signalParams).done();\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            log.debug(\"Sending debug report\", signalParams.report);\n\t            signalingChannel.sendReport(signalParams).done();\n\t        };\n\t\n\t        params.signalingChannel = signalingChannel;\n\t        call = respoke.Call(params);\n\t        addCall({call: call});\n\t        return call;\n\t    };\n\t\n\t    /**\n\t     * Create a new DirectConnection.  This method creates a new Call as well, attaching this DirectConnection to\n\t     * it for the purposes of creating a peer-to-peer link for sending data such as messages to the other endpoint.\n\t     * Information sent through a DirectConnection is not handled by the cloud infrastructure.  If there is already\n\t     * a direct connection open, this method will resolve the promise with that direct connection instead of\n\t     * attempting to create a new one.\n\t     *\n\t     *     endpoint.startDirectConnection({\n\t     *         onOpen: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.startDirectConnection\n\t     * @param {object} params\n\t     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess] - Success handler for this\n\t     * invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @param {respoke.DirectConnection.onStart} [params.onStart] - A callback for when setup of the direct\n\t     * connection begins. The direct connection will not be open yet.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - A callback for receiving notification of when\n\t     * the DirectConnection is open and ready to be used.\n\t     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n\t     * connection.\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - A callback for receiving notification of\n\t     * when the DirectConnection is closed and the two Endpoints are disconnected.\n\t     * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the\n\t     * request for a direct connection and setup begins.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - A callback for receiving messages sent\n\t     * through the DirectConnection.\n\t     * @param {string} [params.connectionId] - An optional connection ID to use for this connection. This allows\n\t     * the connection to be made to a specific instance of an endpoint in the case that the same endpoint is logged\n\t     * in from multiple locations.\n\t     * @returns {Promise<respoke.DirectConnection>} The DirectConnection which can be used to send data and messages\n\t     * directly to the other endpoint.\n\t     */\n\t    that.startDirectConnection = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t        var call;\n\t\n\t        try {\n\t            client.verifyConnected();\n\t        } catch (err) {\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        if (that.directConnection || params.create === false) {\n\t            deferred.resolve(that.directConnection);\n\t            return retVal;\n\t        }\n\t\n\t        if (typeof params.caller !== 'boolean') {\n\t            params.caller = true;\n\t        }\n\t\n\t        if (!that.id) {\n\t            deferred.reject(new Error(\"Can't start a direct connection without endpoint ID!\"));\n\t            return retVal;\n\t        }\n\t\n\t        params.instanceId = instanceId;\n\t        params.remoteEndpoint = that;\n\t\n\t        params.signalOffer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.signalType = 'offer';\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            signalParams.metadata = params.metadata;\n\t\n\t            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n\t        };\n\t        params.signalConnected = function (signalParams) {\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n\t                signalParams.call.hangup();\n\t            });\n\t        };\n\t        params.signalAnswer = function (signalParams) {\n\t            var onSuccess = signalParams.onSuccess;\n\t            var onError = signalParams.onError;\n\t            delete signalParams.onSuccess;\n\t            delete signalParams.onError;\n\t\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            signalParams.signalType = 'answer';\n\t            signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n\t                signalParams.call.hangup({signal: false});\n\t            });\n\t        };\n\t        params.signalCandidate = function (signalParams) {\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            return signalingChannel.sendCandidate(signalParams);\n\t        };\n\t        params.signalHangup = function (signalParams) {\n\t            signalParams.target = 'directConnection';\n\t            signalParams.recipient = that;\n\t            signalingChannel.sendHangup(signalParams).done();\n\t        };\n\t        params.signalReport = function (signalParams) {\n\t            signalParams.report.target = 'directConnection';\n\t            log.debug(\"Not sending report\");\n\t            log.debug(signalParams.report);\n\t        };\n\t        params.needDirectConnection = true;\n\t        // Don't include audio in the offer SDP\n\t        params.offerOptions = {\n\t            mandatory: {\n\t                OfferToReceiveAudio: false\n\t            }\n\t        };\n\t\n\t        params.signalingChannel = signalingChannel;\n\t        call = respoke.Call(params);\n\t        addCall({call: call});\n\t        call.listen('direct-connection', function directConnectionHandler(evt) {\n\t            that.directConnection = evt.directConnection;\n\t            if (params.caller !== true) {\n\t                if (!client.hasListeners('direct-connection') &&\n\t                        !client.hasListeners('direct-connection') &&\n\t                        !call.hasListeners('direct-connection')) {\n\t                    that.directConnection.reject();\n\t                    deferred.reject(new Error(\"Got an incoming direct connection with no handlers to accept it!\"));\n\t                    return;\n\t                }\n\t\n\t                deferred.resolve(that.directConnection);\n\t                that.directConnection.listen('close', function closeHandler(evt) {\n\t                    that.directConnection = undefined;\n\t                }, true);\n\t            }\n\t        }, true);\n\t\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Default presence list.\n\t     * @private\n\t     */\n\t    var PRESENCE_CONSTANTS = ['chat', 'available', 'away', 'dnd', 'xa', 'unavailable'];\n\t\n\t    /**\n\t     * Find the presence out of all known connections with the highest priority (most availability)\n\t     * and set it as the endpoint's resolved presence.\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.resolvePresence\n\t     * @private\n\t     */\n\t    that.resolvePresence = function () {\n\t\n\t        var presenceList = that.connections.map(function (connection) {\n\t            return connection.presence;\n\t        });\n\t\n\t        if (resolveEndpointPresence !== undefined) {\n\t            that.presence = resolveEndpointPresence(presenceList);\n\t        } else {\n\t            var idList;\n\t\n\t            /*\n\t             * Sort the connections array by the priority of the value of the presence of that\n\t             * connectionId. This will cause the first element in the list to be the id of the\n\t             * session with the highest priority presence so we can access it by the 0 index.\n\t             * TODO: If we don't really care about the sorting and only about the highest priority\n\t             * we could use Array.prototype.every to improve this algorithm.\n\t             */\n\t            idList = that.connections.sort(function sorter(a, b) {\n\t                var indexA = PRESENCE_CONSTANTS.indexOf(a.presence);\n\t                var indexB = PRESENCE_CONSTANTS.indexOf(b.presence);\n\t                // Move it to the end of the list if it isn't one of our accepted presence values\n\t                indexA = indexA === -1 ? 1000 : indexA;\n\t                indexB = indexB === -1 ? 1000 : indexB;\n\t                return indexA < indexB ? -1 : (indexB < indexA ? 1 : 0);\n\t            });\n\t\n\t            if (idList[0]) {\n\t                that.presence = idList[0].presence;\n\t            } else {\n\t                that.presence = 'unavailable';\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Get the Connection with the specified id. The connection ID is optional if only one connection exists.\n\t     *\n\t     *     var connection = endpoint.getConnection({\n\t     *         connectionId: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\"\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Endpoint\n\t     * @method respoke.Endpoint.getConnection\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} [params.connectionId]\n\t     * @return {respoke.Connection}\n\t     */\n\t    that.getConnection = function (params) {\n\t        var connection = null;\n\t        params = params || {};\n\t        if (that.connections.length === 1 &&\n\t                (!params.connectionId || that.connections[0] === params.connectionId)) {\n\t            return that.connections[0];\n\t        }\n\t\n\t        if (!params || !params.connectionId) {\n\t            throw new Error(\"Can't find a connection without the connectionId.\");\n\t        }\n\t\n\t        that.connections.every(function eachConnection(conn) {\n\t            if (conn.id === params.connectionId) {\n\t                connection = conn;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t\n\t        return connection;\n\t    };\n\t\n\t    /**\n\t     * Called to indicate that a connection for this endpoint has joined a\n\t     * group.\n\t     *\n\t     * @private\n\t     * @returns {number} Number of groups this endpoint is a member of.\n\t     */\n\t    that.joinedGroup = function () {\n\t        ++that.groupConnectionCount;\n\t    };\n\t\n\t    /**\n\t     * Called to indicate that a connection for this endpoint has left a\n\t     * group.\n\t     *\n\t     * @private\n\t     * @returns {number} Number of groups this endpoint is a member of.\n\t     */\n\t    that.leftGroup = function () {\n\t        --that.groupConnectionCount;\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.Endpoint\n\t/**\n\t * Handle messages sent to the logged-in user from this one Endpoint.  This callback is called every time\n\t * respoke.Endpoint#message fires.\n\t * @callback respoke.Endpoint.onMessage\n\t * @param {respoke.Event} evt\n\t * @param {respoke.TextMessage} evt.message - the message\n\t * @param {respoke.Endpoint} evt.target\n\t * @param {string} evt.name - the event name\n\t */\n\t/**\n\t * Handle presence notifications from this one Endpoint.  This callback is called every time\n\t * respoke.Endpoint#message fires.\n\t * @callback respoke.Endpoint.onPresence\n\t * @param {respoke.Event} evt\n\t * @param {string|number|object|Array} evt.presence - the Endpoint's presence\n\t * @param {respoke.Endpoint} evt.target\n\t * @param {string} evt.name - the event name\n\t */\n\t /**\n\t * Handle resolving presence for this endpoint\n\t * @callback respoke.Client.resolveEndpointPresence\n\t * @param {Array<object>} connectionPresence\n\t * @returns {object|string|number}\n\t */\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\t/**\n\t * A text message and the information needed to route it.\n\t * @class respoke.TextMessage\n\t * @constructor\n\t * @param {object} params\n\t * @param {string} [params.endpointId] - If sending, endpoint ID of the thing we're sending a message to.\n\t * @param {string} [params.cSelf] - Copy this client's own endpoint on this message so that they arrive\n\t * at other devices it might be logged into elsewhere.\n\t * @param {string} [params.connectionId] - If sending, connection ID of the thing we're sending a message to.\n\t * @param {string} [params.message] - If sending, a message to send\n\t * @param {object} [params.rawMessage] - If receiving, the parsed JSON we got from the server\n\t * @private\n\t * @returns {respoke.TextMessage}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var that = {};\n\t\n\t    /**\n\t     * Parse rawMessage and set attributes required for message delivery.\n\t     * @memberof! respoke.TextMessage\n\t     * @method respoke.TextMessage.parse\n\t     * @private\n\t     */\n\t    function parse() {\n\t        if (params.rawMessage) {\n\t            try {\n\t                that.endpointId = params.rawMessage.header.from;\n\t                that.originalRecipient = params.rawMessage.header.toOriginal;\n\t                that.connectionId = params.rawMessage.header.fromConnection;\n\t                that.timestamp = params.rawMessage.header.timestamp;\n\t            } catch (e) {\n\t                throw new Error(e);\n\t            }\n\t            that.message = params.rawMessage.message || params.rawMessage.body;\n\t            if (params.rawMessage.header.channel) {\n\t                that.recipient = params.rawMessage.header.channel;\n\t            }\n\t        } else {\n\t            try {\n\t                that.to = params.endpointId;\n\t                that.ccSelf = params.ccSelf;\n\t                that.toConnection = params.connectionId;\n\t                that.requestConnectionReply = (params.requestConnectionReply === true);\n\t                that.push = (params.push === true);\n\t            } catch (e) {\n\t                throw new Error(e);\n\t            }\n\t            that.message = params.message;\n\t        }\n\t    }\n\t\n\t    parse();\n\t    return that;\n\t}; // End respoke.TextMessage\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\t/**\n\t * A signaling message and the information needed to route it.\n\t * @class respoke.SignalingMessage\n\t * @constructor\n\t * @param {object} params\n\t * @param {string} [params.fromEndpoint] - If sending, the endpoint ID of the recipient\n\t * @param {string} [params.fromConnection] - If sending, the connection ID of the recipient\n\t * @param {string} [params.connectionId] - The connectionId of the endpoint whose answer signal has been accepted.\n\t * @param {string} [params.signal] - If sending, a message to send\n\t * @param {respoke.Endpoint} [params.recipient]\n\t * @param {string} [params.signalType]\n\t * @param {string} [params.sessionId] - A globally unique ID to identify this call.\n\t * @param {string} [params.target] - Either 'call' or 'directConnection', TODO remove the need for this.\n\t * @param {string} [params.callerId] - Human readable caller ID. Not implemented.\n\t * @param {RTCSessionDescription} [params.sdp]\n\t * @param {Array<RTCIceCandidate>} [params.iceCandidates]\n\t * @param {object} [params.offering] - Object describing the media we're offering to send the remote party in a more\n\t * usable way than SDP. Not implemented.\n\t * @param {object} [params.requesting] - Object describing the media we're requesting from the remote party in a more\n\t * usable way than SDP. Not implemented.\n\t * @param {string} [params.reason] - Human readable reason for hanging up.\n\t * @param {string} [params.error] - String indicating that a previous signal was malformed or received in the wrong\n\t * state. Not implemented.\n\t * @param {string} [params.status] - \"Ringing\". Not implemented.\n\t * @param {object} [params.rawMessage] - If receiving, the parsed JSON we got from the server\n\t * @private\n\t * @returns {respoke.SignalingMessage}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var that = {};\n\t\n\t    /**\n\t     * Attributes without which we cannot build a signaling message.\n\t     * @memberof! respoke.SignalingMessage\n\t     * @name required\n\t     * @private\n\t     */\n\t    var required = ['signalType', 'sessionId', 'target', 'signalId'];\n\t\n\t    /**\n\t     * Attributes which we will copy onto the signal if defined.\n\t     * @memberof! respoke.SignalingMessage\n\t     * @name required\n\t     * @private\n\t     */\n\t    var optional = [\n\t        'sessionDescription', 'iceCandidates', 'offering', 'callerId', 'requesting',\n\t        'reason', 'error', 'status', 'connectionId', 'finalCandidates', 'metadata',\n\t        'action'\n\t    ];\n\t\n\t    /**\n\t     * Parse rawMessage and set attributes required for message delivery.\n\t     * @memberof! respoke.SignalingMessage\n\t     * @method respoke.SignalingMessage.parse\n\t     * @private\n\t     */\n\t    function parse() {\n\t        if (params.rawMessage) {\n\t            try {\n\t                that = JSON.parse(params.rawMessage.body); // Incoming message\n\t            } catch (e) {\n\t                that = params.rawMessage.body;\n\t            }\n\t            that.fromType = params.rawMessage.header.fromType;\n\t            that.fromEndpoint = params.rawMessage.header.from;\n\t            that.fromConnection = params.rawMessage.header.fromConnection;\n\t            that.timestamp = params.rawMessage.header.timestamp;\n\t\n\t            if (!that.target) {\n\t                that.target = 'call';\n\t            }\n\t        } else {\n\t            required.forEach(function eachAttr(attr) {\n\t                if (!params.hasOwnProperty(attr)) {\n\t                    throw new Error(\"Can't build a signaling without \" + attr);\n\t                }\n\t                that[attr] = params[attr];\n\t            });\n\t\n\t            optional.forEach(function eachAttr(attr) {\n\t                if (params.hasOwnProperty(attr)) {\n\t                    that[attr] = params[attr];\n\t                }\n\t            });\n\t        }\n\t    }\n\t\n\t    parse();\n\t\n\t    that.version = '1.0';\n\t\n\t    return that;\n\t}; // End respoke.SignalingMessage\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(8);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * A `respoke.Group` represents a collection of endpoints.\n\t *\n\t * There are methods to communicate with the endpoints at the group level and track\n\t * their presence in the group.\n\t *\n\t * @class respoke.Group\n\t * @augments respoke.EventEmitter\n\t * @constructor\n\t * @param {object} params\n\t * @param {string} params.instanceId\n\t * @param {respoke.Group.onJoin} params.onJoin - A callback to receive notifications every time a new\n\t * endpoint has joined the group. This callback does not get called when the client joins the group.\n\t * @param {respoke.Group.onMessage} params.onMessage - A callback to receive messages sent to the group from\n\t * remote endpoints.\n\t * @param {respoke.Group.onLeave} params.onLeave - A callback to receive notifications every time a new\n\t * endpoint has left the group. This callback does not get called when the client leaves the group.\n\t * @returns {respoke.Group}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t\n\t    var that = respoke.EventEmitter(params);\n\t    /**\n\t     * @memberof! respoke.Group\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var client = respoke.getClient(instanceId);\n\t\n\t    if (!that.id) {\n\t        throw new Error(\"Can't create a group without an ID.\");\n\t    }\n\t\n\t    /**\n\t     * Indicates whether there have been group membership changes since the last time we performed\n\t     * a network request to list group members.\n\t     * @memberof! respoke.Group\n\t     * @name cacheIsValid\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var cacheIsValid = false;\n\t\n\t    /**\n\t     * Internal reference to the api signaling channel.\n\t     * @memberof! respoke.Group\n\t     * @name signalingChannel\n\t     * @type respoke.SignalingChannel\n\t     * @private\n\t     */\n\t    var signalingChannel = params.signalingChannel;\n\t    delete params.signalingChannel;\n\t\n\t    /**\n\t     * The connections to members of this group.\n\t     * @memberof! respoke.Group\n\t     * @name endpoints\n\t     * @type {array<respoke.Connection>}\n\t     */\n\t    that.connections = [];\n\t    /**\n\t     * A name to identify the type of this object.\n\t     * @memberof! respoke.Group\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Group';\n\t    that.listen('join', params.onJoin);\n\t    /**\n\t     * Indicates that a message has been sent to this group.\n\t     * @event respoke.Group#message\n\t     * @type {respoke.Event}\n\t     * @property {respoke.TextMessage} message\n\t     * @property {string} name - The event name.\n\t     * @property {respoke.Group} target\n\t     */\n\t    that.listen('message', params.onMessage);\n\t    that.listen('leave', params.onLeave);\n\t\n\t    /**\n\t     * Clear out the connections within this group. Called when we're no longer\n\t     * connected to the group.\n\t     * @private\n\t     */\n\t    function clearConnections() {\n\t        that.connections.forEach(function (connection) {\n\t            connection.getEndpoint().leftGroup();\n\t        });\n\t        that.connections = [];\n\t    }\n\t\n\t    client.listen('disconnect', function disconnectHandler() {\n\t        cacheIsValid = false;\n\t        clearConnections();\n\t    }, true);\n\t\n\t    delete that.instanceId;\n\t    delete that.onMessage;\n\t    delete that.onPresence;\n\t    delete that.onJoin;\n\t    delete that.onLeave;\n\t\n\t    /**\n\t     * Join this group.\n\t     *\n\t     *     group.join().done(function () {\n\t     *         group.sendMessage({\n\t     *             message: \"Hey, ppl! I'm here!\"\n\t     *         });\n\t     *     }, function (err) {\n\t     *         // Couldn't join the group, possibly permissions error\n\t     *     });\n\t     *\n\t     * **Using callbacks** will disable promises.\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.join\n\t     * @return {Promise|undefined}\n\t     * @param {object} params\n\t     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @fires respoke.Client#join\n\t     */\n\t    that.join = function () {\n\t        var params = {\n\t            id: that.id\n\t        };\n\t        var promise;\n\t        var deferred;\n\t        var retVal;\n\t        cacheIsValid = false;\n\t\n\t        try {\n\t            validateConnection();\n\t        } catch (err) {\n\t            deferred = Q.defer();\n\t            retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        promise = client.join(params);\n\t        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Leave this group. If this method is called multiple times synchronously, it will batch requests and\n\t     * only make one API call to Respoke.\n\t     *\n\t     *     group.leave({\n\t     *         onSuccess: function () {\n\t     *             // good riddance\n\t     *         },\n\t     *         onError: function (err) {\n\t     *             // Couldn't leave the group, possibly a permissions error\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.leave\n\t     * @param {object} params\n\t     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @return {Promise|undefined}\n\t     * @fires respoke.Client#leave\n\t     */\n\t    that.leave = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        try {\n\t            validateConnection();\n\t            validateMembership();\n\t        } catch (err) {\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        signalingChannel.leaveGroup({\n\t            groupList: [that.id]\n\t        }).done(function successHandler() {\n\t            clearConnections();\n\t            deferred.resolve();\n\t            cacheIsValid = false;\n\t\n\t            /**\n\t             * This event is fired when the client leaves a group.\n\t             * @event respoke.Client#leave\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Group} group\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             * @private\n\t             */\n\t            client.fire('leave', {\n\t                group: that\n\t            });\n\t        }, function errorHandler(err) {\n\t            deferred.reject();\n\t        });\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Remove a Connection from a Group. This does not change the status of the remote Endpoint, it only changes the\n\t     * internal representation of the Group membership. This method should only be used internally.\n\t     * @private\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.removeMember\n\t     * @param {object} params\n\t     * @param {string} [params.connectionId] - Endpoint's connection id\n\t     * @fires respoke.Group#leave\n\t     */\n\t    that.removeMember = function (params) {\n\t        params = params || {};\n\t\n\t        try {\n\t            validateConnection();\n\t            validateMembership();\n\t        } catch (err) {\n\t            return;\n\t        }\n\t\n\t        if (!params.connectionId) {\n\t            throw new Error(\"Can't remove a member to the group without it's Connection id.\");\n\t        }\n\t\n\t        cacheIsValid = false;\n\t\n\t        that.connections.every(function eachConnection(conn, index) {\n\t            if (conn.id === params.connectionId) {\n\t                that.connections.splice(index, 1);\n\t                conn.getEndpoint().leftGroup();\n\t\n\t                /**\n\t                 * This event is fired when a member leaves a group the client is a member of.\n\t                 * @event respoke.Group#leave\n\t                 * @type {respoke.Event}\n\t                 * @property {respoke.Connection} connection - The connection that left the group.\n\t                 * @property {string} name - The event name.\n\t                 * @property {respoke.Group} target\n\t                 */\n\t                that.fire('leave', {\n\t                    connection: conn\n\t                });\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Return true if the logged-in user is a member of this group and false if not.\n\t     *\n\t     *     if (group.isJoined()) {\n\t     *         // I'm a member!\n\t     *     } else {\n\t     *         // Maybe join here\n\t     *     }\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.isJoined\n\t     * @returns {boolean}\n\t     */\n\t    that.isJoined = function () {\n\t        // connections array contains some connections and ours is among them.\n\t        return (that.connections.length > 0 && !that.connections.every(function (conn) {\n\t            return conn.id !== client.connectionId;\n\t        }));\n\t    };\n\t\n\t    /**\n\t     * Add a Connection to a group. This does not change the status of the remote Endpoint, it only changes the\n\t     * internal representation of the Group membership. This method should only be used internally.\n\t     * @memberof! respoke.Group\n\t     * @private\n\t     * @method respoke.Group.addMember\n\t     * @param {object} params\n\t     * @param {respoke.Connection} params.connection\n\t     * @fires respoke.Group#join\n\t     */\n\t    that.addMember = function (params) {\n\t        params = params || {};\n\t        var absent;\n\t\n\t        validateConnection();\n\t\n\t        if (!params.connection) {\n\t            throw new Error(\"Can't add a member to the group without it's Connection object.\");\n\t        }\n\t\n\t        cacheIsValid = false;\n\t\n\t        absent = that.connections.every(function eachConnection(conn) {\n\t            return (conn.id !== params.connection.id);\n\t        });\n\t\n\t        if (absent) {\n\t            that.connections.push(params.connection);\n\t            params.connection.getEndpoint().joinedGroup();\n\t            if (params.skipEvent) {\n\t                return;\n\t            }\n\t\n\t            /**\n\t             * This event is fired when a member joins a Group that the currently logged-in endpoint is a member\n\t             * of.\n\t             * @event respoke.Group#join\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Connection} connection - The connection that joined the group.\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Group} target\n\t             */\n\t            that.fire('join', {\n\t                connection: params.connection\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Validate that the client is connected to the Respoke infrastructure.\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.validateConnection\n\t     * @private\n\t     */\n\t    function validateConnection() {\n\t        if (!signalingChannel || !signalingChannel.isConnected()) {\n\t            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Validate that the client is a member of this group.\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.validateMembership\n\t     * @private\n\t     */\n\t    function validateMembership() {\n\t        if (!that.isJoined()) {\n\t            throw new Error(\"Not a member of this group anymore.\");\n\t        }\n\t    }\n\t\n\t    /**\n\t     *\n\t     * Send a message to all of the endpoints in the group.\n\t     *\n\t     *      var group = client.getGroup({ id: 'js-enthusiasts'});\n\t     *\n\t     *      group.sendMessage({\n\t     *          message: \"Cat on keyboard\",\n\t     *          onSuccess: function (evt) {\n\t     *              console.log('Message was sent');\n\t     *          }\n\t     *      });\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.sendMessage\n\t     * @param {object} params\n\t     * @param {string} params.message - The message.\n\t     * @param {boolean} [params.push=false] - Whether or not the message should be considered for push notifications to\n\t     * mobile devices.\n\t     * @param {function} params.onSuccess - Success handler indicating that the message was delivered.\n\t     * @param {function} params.onError - Error handler indicating that the message was not delivered.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        params = params || {};\n\t        params.id = that.id;\n\t        var promise;\n\t\n\t        try {\n\t            validateConnection();\n\t            validateMembership();\n\t        } catch (err) {\n\t            promise = Q.reject(err);\n\t        }\n\t\n\t        return respoke.handlePromise(promise ? promise : signalingChannel.publish(params),\n\t                params.onSuccess, params.onError);\n\t    };\n\t\n\t    /**\n\t     * Get group members\n\t     *\n\t     * Get an array containing all connections subscribed to the group. Accepts onSuccess or onError parameters,\n\t     * or it returns a promise that you can observe. An endpoint may have more than one connection subscribed to\n\t\t * a group, so if you're interested in unique endpoints, you may want to filter the connections by endpointId.\n\t     *\n\t     *     group.getMembers({\n\t     *         onSuccess: function (connections) {\n\t     *             connections.forEach(function (connection) {\n\t     *                 console.log(connection.endpointId);\n\t     *             });\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.getMembers\n\t     * @param {object} params\n\t     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Success handler for this invocation of this method only.\n\t     * @returns {Promise<Array>} A promise to an array of Connections.\n\t     */\n\t    that.getMembers = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        try {\n\t            validateConnection();\n\t            validateMembership();\n\t        } catch (err) {\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        if (that.connections.length > 0 && cacheIsValid) {\n\t            deferred.resolve(that.connections);\n\t            return retVal;\n\t        }\n\t\n\t        signalingChannel.getGroupMembers({\n\t            id: that.id\n\t        }).done(function successHandler(list) {\n\t            var endpointList = [];\n\t            list.forEach(function eachMember(params) {\n\t                var connection = client.getConnection({\n\t                    endpointId: params.endpointId,\n\t                    connectionId: params.connectionId,\n\t                    skipCreate: true\n\t                });\n\t\n\t                if (!connection) {\n\t                    // Create the connection\n\t                    connection = client.getConnection({\n\t                        endpointId: params.endpointId,\n\t                        connectionId: params.connectionId\n\t                    });\n\t                }\n\t\n\t                if (endpointList.indexOf(params.endpointId) === -1) {\n\t                    endpointList.push(params.endpointId);\n\t                }\n\t                that.addMember({\n\t                    connection: connection,\n\t                    skipEvent: true\n\t                });\n\t            });\n\t\n\t            cacheIsValid = true;\n\t\n\t            deferred.resolve(that.connections);\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Experimental. Create a new conference call. The ID will be the group name. Only members of this group will\n\t     * be permitted to participate in the conference call.\n\t     *\n\t     *     group.joinConference({\n\t     *         onConnect: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Group\n\t     * @method respoke.Group.joinConference\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string|boolean} params.audio - Whether participant should send and receive audio. Boolean `true`\n\t     * indicates send and receive. Boolean `false` indicates neither send nor receive. Strings `send` and `receive`\n\t     * indicate send only and receive only respectively.\n\t     * @param {string|boolean} params.video - Whether participant should send and receive audio. Boolean `true`\n\t     * indicates send and receive. Boolean `false` indicates neither send nor receive. Strings `send` and `receive`\n\t     * indicate send only and receive only respectively.\n\t     * @param {boolean} params.mixAudio - Whether Respoke should mix all the audio streams together to save bandwidth\n\t     * for this one participant.\n\t     * @arg {respoke.Conference.onJoin} [params.onJoin] - Callback for when a participant joins the conference.\n\t     * @arg {respoke.Conference.onLeave} [params.onLeave] - Callback for when a participant leaves the conference.\n\t     * @arg {respoke.Conference.onMessage} [params.onMessage] - Callback for when a message is sent to the conference.\n\t     * @param {respoke.Conference.onMute} [params.onMute] - Callback for when local or remote media is muted or unmuted.\n\t     * @arg {respoke.Conference.onTopic} [params.onTopic] - Callback for the conference topic changes.\n\t     * @arg {respoke.Conference.onPresenter} [params.onPresenter] - Callback for when the presenter changes.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t     * media renegotiation.\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n\t     * and the remote party has received the video.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n\t     * hung up.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n\t     * browser has granted access to media.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n\t     * information.\n\t     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t     * relay servers. If it cannot flow through relay servers, the call will fail.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @returns {respoke.Conference}\n\t     */\n\t    that.joinConference = function (params) {\n\t        var conference = null;\n\t        params = params || {};\n\t        params.id = that.id;\n\t\n\t        conference = client.joinConference(params);\n\t        return conference;\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.Group\n\t/**\n\t * Receive notification that an endpoint has joined this group. This callback is called everytime\n\t * respoke.Group#join is fired.\n\t * @callback respoke.Group.onJoin\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Connection} evt.connection\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Group} evt.target\n\t */\n\t/**\n\t * Receive notification that an endpoint has left this group. This callback is called everytime\n\t * respoke.Group#leave is fired.\n\t * @callback respoke.Group.onLeave\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Connection} evt.connection\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Group} evt.target\n\t */\n\t/**\n\t * Receive notification that a message has been received to a group. This callback is called every time\n\t * respoke.Group#message is fired.\n\t * @callback respoke.Group.onMessage\n\t * @param {respoke.Event} evt\n\t * @param {respoke.TextMessage} evt.message\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Group} evt.target\n\t */\n\t/**\n\t * Get a list of the Connections which are members of this Group.\n\t * @callback respoke.Group.connectionsHandler\n\t * @param {Array<respoke.Connection>} connections\n\t */\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t'use strict';\n\t\n\tvar Q = __webpack_require__(8);\n\tvar respoke = __webpack_require__(1);\n\tvar template = __webpack_require__(16);\n\tvar log = respoke.log;\n\t\n\tvar sdkHeaderValue = 'Respoke.js/' + respoke.version;\n\t\n\tvar billingSuspensionErrorMessage = \"Can't perform this action: Not Authorized. Your account is suspended due to a \" +\n\t    \"billing issue. Please visit the Respoke Developer Portal (https://www.respoke.io) or contact customer support \" +\n\t    \"(support@respoke.io) to address this issue.\";\n\t\n\tvar suspensionErrorMessage = \"Canot perform this action: Not Authorized. Your account is suspended. Please visit \" +\n\t    \"the Respoke Developer Portal (https://www.respoke.io) or contact customer support (support@respoke.io) to \" +\n\t    \"address this issue.\";\n\t\n\t/**\n\t * Returns a timestamp, measured in milliseconds.\n\t *\n\t * This method will use high resolution time, if available. Otherwise it falls back to just\n\t * using the wall clock.\n\t *\n\t * @return {number} Number of milliseconds that have passed since some point in the past.\n\t * @private\n\t */\n\tvar now;\n\tif (window.performance && window.performance.now) {\n\t    now = window.performance.now.bind(window.performance);\n\t} else if (Date.now) {\n\t    now = Date.now.bind(Date);\n\t} else {\n\t    now = function () {\n\t        return new Date().getTime();\n\t    };\n\t}\n\t\n\t/**\n\t * Container for holding requests that are currently waiting on responses.\n\t * @returns {PendingRequests}\n\t * @private\n\t * @constructor\n\t */\n\tvar PendingRequests = function () {\n\t    /**\n\t     * Pending requests.\n\t     * @private\n\t     * @type {Array}\n\t     */\n\t    var contents = [];\n\t    /**\n\t     * Counter to provide the next id.\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var counter = 0;\n\t    var that = {};\n\t\n\t    /**\n\t     * Add a new pending request.\n\t     *\n\t     * @memberof PendingRequests\n\t     * @param obj\n\t     * @returns {*} The key to use for the `remove` method.\n\t     */\n\t    that.add = function (obj) {\n\t        contents[counter] = obj;\n\t        counter++;\n\t        return counter;\n\t    };\n\t\n\t    /**\n\t     * Remove a pending request.\n\t     *\n\t     * @param {*} key Key returned from `add` method.\n\t     */\n\t    that.remove = function (key) {\n\t        delete contents[key];\n\t    };\n\t\n\t    /**\n\t     * Disposes of any currently pending requests, synchronously invoking the provided function on\n\t     * each.\n\t     *\n\t     * @param {function} [fn] Callback for pending requests.\n\t     */\n\t    that.reset = function (fn) {\n\t        if (fn) {\n\t            contents.forEach(fn);\n\t        }\n\t        contents = [];\n\t    };\n\t\n\t    return that;\n\t};\n\t\n\t/**\n\t * The purpose of this class is to make a method call for each API call\n\t * to the backend REST interface.  This class takes care of App authentication, websocket connection,\n\t * Endpoint authentication, and all App interactions thereafter.  Almost all methods return a Promise.\n\t * @class respoke.SignalingChannel\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId - client id\n\t * @private\n\t * @returns {respoke.SignalingChannel}\n\t */\n\tmodule.exports = function (params) {\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name className\n\t     * @type {string}\n\t     * @private\n\t     */\n\t    that.className = 'respoke.SignalingChannel';\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name client\n\t     * @private\n\t     * @type {respoke.Client}\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name socket\n\t     * @private\n\t     * @type {Socket.io.Socket}\n\t     */\n\t    that.socket = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name clientSettings\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var clientSettings = params.clientSettings;\n\t    delete that.clientSettings;\n\t    clientSettings.baseURL = clientSettings.baseURL || 'https://api.respoke.io';\n\t    /**\n\t     * A map to avoid duplicate endpoint presence registrations.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name presenceRegistered\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var presenceRegistered = {};\n\t    /**\n\t     * A reference to the private function Client.actuallyConnect that gets set in SignalingChannel.open() so we\n\t     * don't have to make it public.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name actuallyConnect\n\t     * @private\n\t     * @type {function}\n\t     */\n\t    var actuallyConnect = null;\n\t    /**\n\t     * Set of promises for any pending requests on the WebSocket.\n\t     * @private\n\t     * @type {PendingRequests}\n\t     */\n\t    var pendingRequests = PendingRequests();\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name reconnectTimeout\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var reconnectTimeout = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name maxReconnectTimeout\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var maxReconnectTimeout = 5 * 60 * 1000;\n\t    /**\n\t     * Rejects a message if the body size is greater than this. It is enforced servcer side, so changing this\n\t     * won't make the bodySizeLimit any bigger, this just gives you a senseable error if it's too big.\n\t     * @memberof! respoke.signalingChannel\n\t     * @name bodySizeLimit\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var bodySizeLimit = 20000;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name appId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var appId = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name endpointId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var endpointId = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name token\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var token = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name appToken\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var appToken = null;\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name xhr\n\t     * @private\n\t     * @type {XMLHttpRequest}\n\t     */\n\t    var xhr = new XMLHttpRequest();\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name routingMethods\n\t     * @private\n\t     * @type {object}\n\t     * @desc The methods contained in this object are statically defined methods that are called by constructing\n\t     * their names dynamically. 'do' + $className + $signalType == 'doCallOffer', et. al.\n\t     */\n\t    var routingMethods = {};\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name handlerQueue\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var handlerQueue = {\n\t        'message': [],\n\t        'signal': [],\n\t        'presence': []\n\t    };\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @name errors\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var errors = {\n\t        400: \"Can't perform this action: missing or invalid parameters.\",\n\t        401: \"Can't perform this action: not authenticated.\",\n\t        403: \"Can't perform this action: not authorized.\",\n\t        404: \"Item not found.\",\n\t        409: \"Can't perform this action: item in the wrong state.\",\n\t        429: \"API rate limit was exceeded.\",\n\t        500: \"Can't perform this action: server problem.\"\n\t    };\n\t\n\t    /**\n\t     * Indicate whether the signaling channel has a valid connection to Respoke.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.isConnected\n\t     * @return {boolean}\n\t     */\n\t    that.isConnected = function () {\n\t        return !!(that.socket && that.socket.socket.connected);\n\t    };\n\t\n\t    /**\n\t     * Indicate whether the signaling channel is currently waiting on a websocket to connect.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.isConnecting\n\t     * @private\n\t     * @return {boolean}\n\t     */\n\t    function isConnecting() {\n\t        return !!(that.socket && that.socket.socket.connecting);\n\t    }\n\t\n\t    /**\n\t     * Get the call debug preference.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.isSendingReport\n\t     * @private\n\t     * @return {boolean}\n\t     */\n\t    that.isSendingReport = function (params) {\n\t        return clientSettings.enableCallDebugReport;\n\t    };\n\t\n\t    /**\n\t     * Open a connection to the REST API and validate the app, creating a session token.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.open\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} [params.token] - The Endpoint's auth token\n\t     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @return {Promise}\n\t     */\n\t    that.open = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug('SignalingChannel.open', params, clientSettings);\n\t        token = params.token || token;\n\t        actuallyConnect = typeof params.actuallyConnect === 'function' ? params.actuallyConnect : actuallyConnect;\n\t\n\t        Q.fcall(function tokenPromise() {\n\t            if (clientSettings.developmentMode === true && clientSettings.appId && params.endpointId) {\n\t                return that.getToken({\n\t                    appId: clientSettings.appId,\n\t                    endpointId: params.endpointId\n\t                });\n\t            }\n\t            return null;\n\t        }).then(function successHandler(newToken) {\n\t            token = newToken || token;\n\t            return doOpen({token: token});\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t            log.debug('client', client);\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Get a developer mode token for an endpoint. App must be in developer mode.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getToken\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n\t     * endpoint. This is only used when `developmentMode` is set to `true`.\n\t     * @return {Promise<String>}\n\t     */\n\t    that.getToken = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug('SignalingChannel.getToken', params);\n\t\n\t        var callParams = {\n\t            path: '/v1/tokens',\n\t            httpMethod: 'POST',\n\t            parameters: {\n\t                appId: clientSettings.appId,\n\t                endpointId: params.endpointId,\n\t                ttl: 60 * 60 * 6\n\t            }\n\t        };\n\t\n\t        call(callParams).done(function (response) {\n\t            if (response.statusCode === 200 && response.body && response.body.tokenId) {\n\t                token = response.body.tokenId;\n\t                deferred.resolve(response.body.tokenId);\n\t                return;\n\t            }\n\t\n\t            var errorMessage = \"Couldn't get a developer mode token. \";\n\t            if (isBillingSuspensionUnauthorizedResponse(response)) {\n\t                errorMessage += billingSuspensionErrorMessage;\n\t            } else if (isSuspensionUnauthorizedResponse(response)) {\n\t                errorMessage += suspensionErrorMessage;\n\t            } else {\n\t                errorMessage += response.error;\n\t            }\n\t\n\t            deferred.reject(buildResponseError(response, errorMessage));\n\t        }, function (err) {\n\t            deferred.reject(new Error(\"Couldn't get a developer mode token. \" + err.message));\n\t        });\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Open a connection to the REST API and validate the app, creating a session token.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.doOpen\n\t     * @param {object} params\n\t     * @param {string} params.token - The Endpoint's auth token\n\t     * @return {Promise}\n\t     * @private\n\t     */\n\t    function doOpen(params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug('SignalingChannel.doOpen', params);\n\t\n\t        if (!params.token) {\n\t            deferred.reject(new Error(\"Can't open connection to Respoke without a token.\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        call({\n\t            path: '/v1/session-tokens',\n\t            httpMethod: 'POST',\n\t            parameters: {\n\t                tokenId: params.token\n\t            }\n\t        }).done(function (response) {\n\t            if (response.statusCode === 200) {\n\t                appToken = response.body.token;\n\t                deferred.resolve();\n\t                log.debug(\"Signaling connection open to\", clientSettings.baseURL);\n\t                return;\n\t            }\n\t\n\t            var errorMessage = \"Couldn't authenticate app. \";\n\t            if (isBillingSuspensionUnauthorizedResponse(response)) {\n\t                errorMessage += billingSuspensionErrorMessage;\n\t            } else if (isSuspensionUnauthorizedResponse(response)) {\n\t                errorMessage += suspensionErrorMessage;\n\t            } else {\n\t                errorMessage += response.error;\n\t            }\n\t\n\t            deferred.reject(buildResponseError(response, errorMessage));\n\t        }, function (err) {\n\t            log.error(\"Network call failed:\", err.message);\n\t            deferred.reject(new Error(\"Couldn't authenticate app. \" + err.message));\n\t        });\n\t\n\t        return deferred.promise;\n\t    }\n\t\n\t    /**\n\t     * Close a connection to the REST API. Invalidate the session token.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.close\n\t     * @private\n\t     * @return {Promise}\n\t     */\n\t    that.close = function () {\n\t        var deferred = Q.defer();\n\t\n\t        wsCall({\n\t            path: '/v1/connections/{id}/',\n\t            httpMethod: 'DELETE',\n\t            urlParams: {\n\t                id: client.endpointId\n\t            }\n\t        }).fin(function finallyHandler() {\n\t            return call({\n\t                path: '/v1/session-tokens',\n\t                httpMethod: 'DELETE'\n\t            });\n\t        }).fin(function finallyHandler() {\n\t            if (that.socket) {\n\t                that.socket.removeAllListeners();\n\t                that.socket.disconnect();\n\t            }\n\t            that.socket = null;\n\t            deferred.resolve();\n\t        }).done();\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Generate and send a presence message representing the client's current status. This triggers\n\t     * the server to send the client's endpoint's presence.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendPresence\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string|number|object|Array} [params.presence=available]\n\t     * @param {string} [params.status] - Non-enumeration human-readable status.\n\t     * @param {string} [params.show] - I can't remember what this is.\n\t     * @returns {Promise}\n\t     */\n\t    that.sendPresence = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        log.debug(\"Signaling sendPresence\");\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/presence',\n\t            httpMethod: 'POST',\n\t            parameters: {\n\t                'presence': {\n\t                    show: params.show,\n\t                    'status': params.status,\n\t                    type: params.presence || \"available\"\n\t                }\n\t            }\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * If the logged-in endpoint has permission through its Respoke role, forcibly remove another participant\n\t     * from the conference, ending its conference call.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.removeConferenceParticipant\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} [endpointId] - The endpoint id of the endpoint to be removed\n\t     * @param {string} [connectionId] - The connection id of the connection to be removed\n\t     * @returns {Promise}\n\t     */\n\t    that.removeConferenceParticipant = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var endpointId = params.endpointId;\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!endpointId && params.connectionId) {\n\t            try {\n\t                endpointId = client.getConnection({\n\t                    connectionId: params.connectionId\n\t                }).getEndpoint().id;\n\t            } catch (err) {}\n\t\n\t            if (!endpointId) {\n\t                deferred.reject(new Error(\"conference.removeParticipant can't figure out what endpoint to remove!\"));\n\t                return deferred.promise;\n\t            }\n\t        }\n\t\n\t        wsCall({\n\t            httpMethod: 'DELETE',\n\t            path: '/v1/conferences/{id}/participants/{endpointId}',\n\t            urlParams: {\n\t                id: params.conferenceId,\n\t                endpointId: endpointId\n\t            },\n\t            parameters: {\n\t                connectionId: params.connectionId // Optional; It's OK if it's undefined here.\n\t            }\n\t        }).then(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * If the logged-in endpoint has permission through its Respoke role, close down the conference, removing all\n\t     * participants.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.destroyConference\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     * @private\n\t     * @returns {Promise}\n\t     */\n\t    that.destroyConference = function (params) {\n\t        var deferred = Q.defer();\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            httpMethod: 'DELETE',\n\t            path: '/v1/conferences/{id}/',\n\t            urlParams: { id: params.conferenceId }\n\t        }).then(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Retrieve the list of participants in the specified conference.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getConferenceParticipants\n\t     * @private\n\t     * @returns {Promise<respoke.Connection>}\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     */\n\t    that.getConferenceParticipants = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            httpMethod: 'GET',\n\t            path: '/v1/conferences/{id}/participants/',\n\t            urlParams: { id: params.id }\n\t        }).then(function successHandler(participants) {\n\t            deferred.resolve(participants.map(function (par) {\n\t                return client.getConnection({\n\t                    connectionId: par.connectionId,\n\t                    endpointId: par.endpointId\n\t                });\n\t            }));\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Get or create a group in the infrastructure.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getGroup\n\t     * @private\n\t     * @returns {Promise<respoke.Group>}\n\t     * @param {object} params\n\t     * @param {string} params.name\n\t     */\n\t    that.getGroup = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            httpMethod: 'POST',\n\t            path: '/v1/channels/',\n\t            parameters: {\n\t                name: params.name\n\t            }\n\t        }).then(function successHandler(group) {\n\t            deferred.resolve(group);\n\t        }, function errorHandler(err) {\n\t            // Group was already created, just return back the same params we were given.\n\t            deferred.resolve({id: params.name});\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Leave a group. In order to aggregate subsequent repeated requests, this function, when called synchronously,\n\t     * will continue to accumulate group ids until the next tick of the event loop, when the request will be\n\t     * issued. The same instance of Promise is returned each time.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @private\n\t     * @method respoke.SignalingChannel.leaveGroup\n\t     * @returns {Promise}\n\t     * @param {object} params\n\t     * @param {array} params.groupList\n\t     */\n\t    that.leaveGroup = (function () {\n\t        var groups = {};\n\t        var deferred = Q.defer();\n\t\n\t        return function (params) {\n\t            params = params || {};\n\t            params.groupList = params.groupList || [];\n\t\n\t            var toRun = (Object.keys(groups).length === 0);\n\t\n\t            if (!that.isConnected()) {\n\t                deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t                return deferred.promise;\n\t            }\n\t\n\t            params.groupList.forEach(function (id) {\n\t                if (typeof id === 'string') {\n\t                    groups[id] = true;\n\t                }\n\t            });\n\t\n\t            if (!toRun) {\n\t                return deferred.promise;\n\t            }\n\t\n\t            setTimeout(function () {\n\t                // restart accumulation\n\t                var groupList = Object.keys(groups);\n\t                groups = {};\n\t                var saveDeferred = deferred;\n\t                deferred = Q.defer();\n\t\n\t                if (groupList.length === 0) {\n\t                    saveDeferred.resolve();\n\t                    return;\n\t                }\n\t\n\t                wsCall({\n\t                    path: '/v1/groups/',\n\t                    parameters: {\n\t                        groups: groupList\n\t                    },\n\t                    httpMethod: 'DELETE'\n\t                }).done(function successHandler() {\n\t                    saveDeferred.resolve();\n\t                }, function errorHandler(err) {\n\t                    saveDeferred.reject(err);\n\t                });\n\t            });\n\t            return deferred.promise;\n\t        };\n\t    })();\n\t\n\t    /**\n\t     * Join a group. In order to aggregate subsequent repeated requests, this function, when called synchronously,\n\t     * will continue to accumulate group ids until the next tick of the event loop, when the request will be\n\t     * issued. The same instance of Promise is returned each time.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.joinGroup\n\t     * @private\n\t     * @returns {Promise}\n\t     * @param {object} params\n\t     * @param {array} params.groupList\n\t     */\n\t    that.joinGroup = (function () {\n\t        var groups = {};\n\t        var deferred = Q.defer();//i think this needs to go in actualJoinGroup\n\t\n\t        return function actualJoinGroup(params) {\n\t            params = params || {};\n\t            params.groupList = params.groupList || [];\n\t\n\t            log.trace('been asked to join groups', params.groupList);\n\t\n\t            var needsToRun = (Object.keys(groups).length === 0);\n\t\n\t            if (!that.isConnected()) {\n\t                deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t                return deferred.promise;\n\t            }\n\t\n\t            params.groupList.forEach(function (id) {\n\t                if (typeof id === 'string') {\n\t                    log.trace('put group', id, 'in the join queue');\n\t                    groups[id] = true;\n\t                }\n\t            });\n\t\n\t            if (!needsToRun) {\n\t                return deferred.promise;\n\t            }\n\t\n\t            setTimeout(function requestJoinsForGroupQueue() {\n\t                // restart accumulation\n\t                var groupList = Object.keys(groups);\n\t                log.trace('list of groups to be requested', groupList);\n\t                //reset the groups object\n\t                groups = {};\n\t                var saveDeferred = deferred;\n\t                deferred = Q.defer();\n\t\n\t                if (groupList.length === 0) {\n\t                    log.trace('list of groups was empty so not sending queue');\n\t                    saveDeferred.resolve();\n\t                    return;\n\t                }\n\t\n\t                wsCall({\n\t                    path: '/v1/groups/',\n\t                    parameters: {\n\t                        groups: groupList\n\t                    },\n\t                    httpMethod: 'POST'\n\t                }).done(function successHandler() {\n\t                    saveDeferred.resolve();\n\t                }, function errorHandler(err) {\n\t                    saveDeferred.reject(err);\n\t                });\n\t            });\n\t            return deferred.promise;\n\t        };\n\t    })();\n\t\n\t    /**\n\t     * Publish a message to a group.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @private\n\t     * @method respoke.SignalingChannel.publish\n\t     * @returns {Promise}\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     * @param {string} params.message\n\t     * @param {boolean} [params.push=false]\n\t     */\n\t    that.publish = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var message = respoke.TextMessage({\n\t            endpointId: params.id,\n\t            message: params.message,\n\t            push: !!params.push\n\t        });\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/channels/{id}/publish/',\n\t            urlParams: { id: params.id },\n\t            httpMethod: 'POST',\n\t            parameters: message\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Register as an observer of presence for the specified endpoint ids. In order to aggregate subsequent repeated\n\t     * requests, this function, when called synchronously, will continue to accumulate endpoint ids until the next\n\t     * tick of the event loop, when the request will be issued. The same instance of Promise is returned each time.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.registerPresence\n\t     * @private\n\t     * @param {object} params\n\t     * @param {Array<string>} params.endpointList\n\t     * @returns {Promise}\n\t     */\n\t    that.registerPresence = (function () {\n\t        var endpoints = {};\n\t        var deferred = Q.defer();\n\t\n\t        return function (params) {\n\t            params = params || {};\n\t            params.endpointList = params.endpointList || [];\n\t            var toRun = (Object.keys(endpoints).length === 0);\n\t\n\t            if (!that.isConnected()) {\n\t                return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            }\n\t\n\t            params.endpointList.forEach(function (ep) {\n\t                if (typeof ep === 'string' && presenceRegistered[ep] !== true) {\n\t                    endpoints[ep] = true;\n\t                }\n\t            });\n\t\n\t            if (!toRun) {\n\t                return deferred.promise;\n\t            }\n\t\n\t            setTimeout(function () {\n\t                // restart accumulation\n\t                var endpointList = Object.keys(endpoints);\n\t                endpoints = {};\n\t                var saveDeferred = deferred;\n\t                deferred = Q.defer();\n\t\n\t                if (endpointList.length === 0) {\n\t                    saveDeferred.resolve();\n\t                    return;\n\t                }\n\t\n\t                wsCall({\n\t                    httpMethod: 'POST',\n\t                    path: '/v1/presenceobservers',\n\t                    parameters: {\n\t                        endpointList: endpointList\n\t                    }\n\t                }).done(function successHandler() {\n\t                    params.endpointList.forEach(function eachId(id) {\n\t                        presenceRegistered[id] = true;\n\t                    });\n\t                    saveDeferred.resolve();\n\t                }, function (err) {\n\t                    saveDeferred.reject(err);\n\t                });\n\t                // We could even add a tiny delay like 10ms if we want to get more conservative and\n\t                // catch asychronous calls to client.getEndpoint() and other methods which call\n\t                // this method.\n\t            });\n\t\n\t            return deferred.promise;\n\t        };\n\t    })();\n\t\n\t    /**\n\t     * Join a group.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getGroupMembers\n\t     * @private\n\t     * @returns {Promise<Array>}\n\t     * @param {object} params\n\t     * @param {string} params.id\n\t     */\n\t    that.getGroupMembers = function (params) {\n\t        var deferred = Q.defer();\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!params.id) {\n\t            deferred.reject(new Error(\"Can't get group's endpoints without group ID.\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        return wsCall({\n\t            path: '/v1/channels/{id}/subscribers/',\n\t            urlParams: { id: params.id },\n\t            httpMethod: 'GET'\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Send a chat message.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendMessage\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.SignalingMessage} params.message - The string text message to send.\n\t     * @param {respoke.Endpoint} params.recipient\n\t     * @param {string} [params.connectionId]\n\t     * @param {boolean} [params.push=false]\n\t     * @returns {Promise}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var message = respoke.TextMessage({\n\t            endpointId: params.recipient.id,\n\t            ccSelf: params.ccSelf,\n\t            connectionId: params.connectionId,\n\t            message: params.message,\n\t            push: !!params.push\n\t        });\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/messages',\n\t            httpMethod: 'POST',\n\t            parameters: message\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Send an ACK signal to acknowlege reception of a signal.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendACK\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.SignalingMessage} params.signal\n\t     * @return {Promise}\n\t     */\n\t    that.sendACK = function (params) {\n\t        var endpoint;\n\t        params = params || {};\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        if (!params.signal) {\n\t            return Q.reject(new Error(\"Can't send ACK, no signal was given.\"));\n\t        }\n\t\n\t        endpoint = client.getEndpoint({\n\t            id: params.signal.fromEndpoint,\n\t            skipPresence: true\n\t        });\n\t        if (!endpoint) {\n\t            return Q.reject(new Error(\"Can't send ACK, can't get endpoint.\"));\n\t        }\n\t\n\t        return that.sendSignal({\n\t            recipient: endpoint,\n\t            signalType: 'ack',\n\t            signalId: params.signal.signalId,\n\t            sessionId: params.signal.sessionId,\n\t            target: params.signal.target,\n\t            ackedSignalType: params.signal.signalType\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Send a signaling message.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendSignal\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Call} [params.call] - For getting the sessionId & connectionId. Not required for 'ack'.\n\t     * @return {Promise}\n\t     */\n\t    that.sendSignal = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var signal;\n\t        var to;\n\t        var toConnection;\n\t        var toType;\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (params.call) {\n\t            params.sessionId = params.call.id;\n\t            if (params.call.connectionId) { // the recipient's connectionId\n\t                params.connectionId = params.call.connectionId;\n\t            }\n\t        }\n\t\n\t        to = params.recipient.id;\n\t        toConnection = params.connectionId;\n\t        toType = params.toType || 'web';\n\t\n\t        try {\n\t            params.signalId = respoke.makeGUID();\n\t            // This will strip off non-signaling attributes.\n\t            signal = respoke.SignalingMessage(params);\n\t        } catch (e) {\n\t            deferred.reject(e);\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/signaling',\n\t            httpMethod: 'POST',\n\t            parameters: {\n\t                ccSelf: params.ccSelf,\n\t                signal: JSON.stringify(signal),\n\t                to: to,\n\t                toConnection: toConnection,\n\t                toType: toType\n\t            }\n\t        }).done(function successHandler() {\n\t            deferred.resolve();\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Send an ICE candidate.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendCandidate\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @param {string} [params.connectionId]\n\t     * @param {Array<RTCIceCandidate>} params.iceCandidates - An array of ICE candidate.\n\t     * @return {Promise}\n\t     */\n\t    that.sendCandidate = function (params) {\n\t        params = params || {};\n\t        params.signalType = 'iceCandidates';\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        if (typeof params.finalCandidates !== 'undefined') {\n\t            log.debug('Sending final', params.iceCandidates.length, 'of', params.finalCandidates.length, 'ice candidates');\n\t        } else {\n\t            log.debug('Sending', params.iceCandidates.length, 'ice candidates');\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Send an SDP.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendSDP\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @param {string} [params.connectionId]\n\t     * @param {RTCSessionDescription} params.sessionDescription - An SDP to JSONify and send.\n\t     * @return {Promise}\n\t     */\n\t    that.sendSDP = function (params) {\n\t        params = params || {};\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        if (['offer', 'answer'].indexOf(params.signalType) === -1) {\n\t            return Q.reject(\"Not an SDP type signal.\");\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Send a call report to the cloud infrastructure.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendReport\n\t     * @private\n\t     * @param {object} params\n\t     * @todo TODO document the params.\n\t     * @return {Promise}\n\t     */\n\t    that.sendReport = function (params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var message = {\n\t            debugData: params\n\t        };\n\t\n\t        if (!clientSettings.enableCallDebugReport) {\n\t            log.debug('not sending call debugs - disabled');\n\t            deferred.resolve();\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            path: '/v1/call-debugs',\n\t            httpMethod: 'POST',\n\t            parameters: message\n\t        }).done(function () {\n\t            deferred.resolve();\n\t        }, function (err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Send a message hanging up the WebRTC session.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendHangup\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @param {string} [params.connectionId]\n\t     * @param {string} params.reason - The reason the session is being hung up.\n\t     * @return {Promise}\n\t     */\n\t    that.sendHangup = function (params) {\n\t        params = params || {};\n\t        params.signalType = 'bye';\n\t        params.ccSelf = true;\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Send a message to all connection ids indicating we have negotiated a call with one connection.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendConnected\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @return {Promise}\n\t     */\n\t    that.sendConnected = function (params) {\n\t        params = params || {};\n\t        params.signalType = 'connected';\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Send a message to the remote party indicating a desire to renegotiate media.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.sendModify\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.Endpoint} params.recipient - The recipient.\n\t     * @param {string} params.action - The state of the modify request, one of: 'initiate', 'accept', 'reject'\n\t     * @return {Promise}\n\t     */\n\t    that.sendModify = function (params) {\n\t        params = params || {};\n\t        params.signalType = 'modify';\n\t\n\t        if (['initiate', 'accept', 'reject'].indexOf(params.action) === -1) {\n\t            return Q.reject(\"No valid action in modify signal.\");\n\t        }\n\t\n\t        if (!that.isConnected()) {\n\t            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t        }\n\t\n\t        return that.sendSignal(params);\n\t    };\n\t\n\t    /**\n\t     * Uppercase the first letter of the word.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.firstUpper\n\t     * @private\n\t     */\n\t    function firstUpper(str) {\n\t        return str[0].toUpperCase() + str.slice(1);\n\t    }\n\t\n\t    /**\n\t     * Route different types of signaling messages via events.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routeSignal\n\t     * @private\n\t     * @param {respoke.SignalingMessage} signal - A message to route\n\t     * @fires respoke.Call#offer\n\t     * @fires respoke.Call#connected\n\t     * @fires respoke.Call#answer\n\t     * @fires respoke.Call#iceCandidates\n\t     * @fires respoke.Call#hangup\n\t     * @fires respoke.DirectConnection#offer\n\t     * @fires respoke.DirectConnection#connected\n\t     * @fires respoke.DirectConnection#answer\n\t     * @fires respoke.DirectConnection#iceCandidates\n\t     * @fires respoke.DirectConnection#hangup\n\t     */\n\t    that.routeSignal = function (signal) {\n\t        var target = null;\n\t        var method = 'do';\n\t\n\t        if (signal.signalType !== 'iceCandidates' || respoke.ridiculous) { // Too many of these!\n\t            log.debug(signal.signalType, signal);\n\t        }\n\t\n\t        // Only create if this signal is an offer.\n\t        return Q().then(function () {\n\t            var endpoint;\n\t\n\t            if (signal.target === undefined) {\n\t                throw new Error(\"target undefined\");\n\t            }\n\t\n\t            /*\n\t             * This will return calls regardless of whether they are associated\n\t             * with a direct connection or not, and it will create a call if no\n\t             * call is found and this signal is an offer. Direct connections get\n\t             * created in the next step.\n\t             *\n\t             * signal.toOriginal will be undefined except in the case that another connection\n\t             * with our same endpointId has just hung up on the call.\n\t             */\n\t            target = client.getCall({\n\t                id: signal.sessionId,\n\t                endpointId: signal.toOriginal || signal.fromEndpoint,\n\t                target: signal.target,\n\t                conferenceId: signal.conferenceId,\n\t                type: signal.fromType,\n\t                create: (signal.target !== 'directConnection' && signal.signalType === 'offer'),\n\t                callerId: signal.callerId,\n\t                metadata: signal.metadata\n\t            });\n\t            if (target) {\n\t                return target;\n\t            }\n\t\n\t            if (signal.target === 'directConnection') {\n\t                // return a promise\n\t                endpoint = client.getEndpoint({\n\t                    id: signal.fromEndpoint,\n\t                    skipPresence: true\n\t                });\n\t\n\t                if (endpoint.directConnection && endpoint.directConnection.call.id === signal.sessionId) {\n\t                    return endpoint.directConnection;\n\t                }\n\t\n\t                return endpoint.startDirectConnection({\n\t                    id: signal.sessionId,\n\t                    create: (signal.signalType === 'offer'),\n\t                    caller: (signal.signalType !== 'offer'),\n\t                    metadata: signal.metadata\n\t                });\n\t            }\n\t        }).then(function successHandler(target) {\n\t            // target might be null, a Call, or a DirectConnection.\n\t            if (target) {\n\t                target = target.call || target;\n\t            }\n\t            if (!target || target.id !== signal.sessionId) {\n\t                // orphaned signal\n\t                log.warn(\"Couldn't associate signal with a call. This is usually OK.\", signal);\n\t                return;\n\t            }\n\t\n\t            method += firstUpper(signal.signalType);\n\t            routingMethods[method]({\n\t                call: target,\n\t                signal: signal\n\t            });\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doOffer\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-offer\n\t     */\n\t    routingMethods.doOffer = function (params) {\n\t        params.call.connectionId = params.signal.fromConnection;\n\t        /**\n\t         * Send the `offer` signal into the Call.\n\t         * @event respoke.Call#signal-offer\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-offer', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doConnected\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-connected\n\t     */\n\t    routingMethods.doConnected = function (params) {\n\t        /**\n\t         * Send the `connected` signal into the Call.\n\t         * @event respoke.Call#signal-connected\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-connected', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.dModify\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-modify\n\t     */\n\t    routingMethods.doModify = function (params) {\n\t        /**\n\t         * Send the `modify` signal into the Call.\n\t         * @event respoke.Call#signal-modify\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-modify', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doAnswer\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-answer\n\t     */\n\t    routingMethods.doAnswer = function (params) {\n\t        params.call.connectionId = params.signal.fromConnection;\n\t        /**\n\t         * Send the `answer` signal into the Call.\n\t         * @event respoke.Call#signal-answer\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-answer', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doIceCandidates\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-icecandidates\n\t     */\n\t    routingMethods.doIceCandidates = function (params) {\n\t        /**\n\t         * Send the `icecandidates` signal into the Call.\n\t         * @event respoke.Call#signal-icecandidates\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-icecandidates', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doBye\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     * @fires respoke.Call#signal-hangup\n\t     */\n\t    routingMethods.doBye = function (params) {\n\t        /**\n\t         *  The caller may receive hangup from one or more parties after connectionId is set if the call is rejected\n\t         *  by a connection that didn't win the call. In this case, we have to ignore the signal since\n\t         *  we are already on a call.\n\t         *\n\t         *  The callee's connectionId is always set.\n\t         */\n\t        if (params.call.caller && params.call.connectionId &&\n\t                params.call.connectionId !== params.signal.fromConnection) {\n\t            return;\n\t        }\n\t        /**\n\t         * Send the `hangup` signal into the Call.\n\t         * @event respoke.Call#signal-hangup\n\t         * @type {respoke.Event}\n\t         * @property {object} signal\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        params.call.fire('signal-hangup', {\n\t            signal: params.signal\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.routingMethods.doUnknown\n\t     * @private\n\t     * @params {object} params\n\t     * @params {object} params.signal\n\t     */\n\t    routingMethods.doUnknown = function (params) {\n\t        log.error(\"Don't know what to do with\", params.signal.target, \"msg of unknown type\", params.signal.signalType);\n\t    };\n\t\n\t    /**\n\t     * Add a handler to the connection for messages of different types.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.addHandler\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} params.type - The type of socket message, i. e., 'message', 'presence', 'join'\n\t     * @param {function} params.handler - A function to which to pass the message\n\t     * @todo TODO See if this is necessary anymore\n\t     */\n\t    that.addHandler = function (params) {\n\t        if (that.socket.socket && that.socket.socket.open) {\n\t            that.socket.on(params.type, params.handler);\n\t        } else {\n\t            handlerQueue[params.type].push(params.handler);\n\t        }\n\t    };\n\t\n\t    function socketOnSignal(message) {\n\t        var knownSignals = ['offer', 'answer', 'connected', 'modify', 'iceCandidates', 'bye'];\n\t        var signal = respoke.SignalingMessage({\n\t            rawMessage: message\n\t        });\n\t\n\t        if (signal.signalType === 'ack') {\n\t            return;\n\t        }\n\t\n\t        if (!signal.target || !signal.signalType || knownSignals.indexOf(signal.signalType) === -1) {\n\t            log.error(\"Got malformed signal.\", signal);\n\t            throw new Error(\"Can't route signal without target or type.\");\n\t        }\n\t\n\t        that.routeSignal(signal).done();\n\t    }\n\t    that.socketOnSignal = socketOnSignal;\n\t\n\t    /**\n\t     * Socket handler for pub-sub messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.socketOnPubSub\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     * @fires respoke.Group#message\n\t     * @fires respoke.Client#message\n\t     */\n\t    function socketOnPubSub(message) {\n\t        var group;\n\t        var groupMessage = respoke.TextMessage({\n\t            rawMessage: message\n\t        });\n\t\n\t        group = client.getGroup({id: message.header.channel});\n\t        if (group) {\n\t            /**\n\t             * Indicate that a message has been received to a group.\n\t             * @event respoke.Group#message\n\t             * @type {respoke.Event}\n\t             * @property {respoke.TextMessage} message\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Group} target\n\t             */\n\t            group.fire('message', {\n\t                message: groupMessage\n\t            });\n\t        }\n\t        /**\n\t         * Indicate that a message has been received.\n\t         * @event respoke.Client#message\n\t         * @type {respoke.Event}\n\t         * @property {respoke.TextMessage} message\n\t         * @property {respoke.Group} [group] - If the message is to a group we already know about,\n\t         * this will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\n\t         * the group. From that point forward, Group#message will fire when a message is received as well. If\n\t         * group is undefined instead of null, the message is not a group message at all.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Client} target\n\t         */\n\t        client.fire('message', {\n\t            message: groupMessage,\n\t            group: group || null\n\t        });\n\t    }\n\t    that.socketOnPubSub = socketOnPubSub;\n\t\n\t    /**\n\t     * Socket handler for join messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.socketOnJoin\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     */\n\t    function socketOnJoin(message) {\n\t        var group;\n\t        var presenceMessage;\n\t        var endpoint;\n\t        var connection;\n\t\n\t        if (message.connectionId === client.connectionId) {\n\t            connection = client.getConnection({connectionId: message.connectionId, endpointId: message.endpointId});\n\t            group = client.getGroup({id: message.header.channel});\n\t            if (!group) {\n\t                group = respoke.Group({\n\t                    id: message.header.channel,\n\t                    instanceId: instanceId,\n\t                    signalingChannel: that\n\t                });\n\t                client.addGroup(group);\n\t            }\n\t            if (!group.isJoined()) {\n\t                group.addMember({connection: connection});\n\t                client.fire('join', {\n\t                    group: group\n\t                });\n\t            }\n\t        } else {\n\t\n\t            endpoint = client.getEndpoint({\n\t                skipPresence: true,\n\t                id: message.endpointId,\n\t                instanceId: instanceId,\n\t                name: message.endpointId\n\t            });\n\t\n\t            // Handle presence not associated with a channel\n\t            if (!connection) {\n\t                endpoint.setPresence({\n\t                    connectionId: message.connectionId\n\t                });\n\t                connection = client.getConnection({\n\t                    connectionId: message.connectionId,\n\t                    endpointId: message.endpointId\n\t                });\n\t            }\n\t\n\t            group = client.getGroup({id: message.header.channel});\n\t\n\t            if (group && connection) {\n\t                group.addMember({connection: connection});\n\t            } else {\n\t                log.error(\"Can't add endpoint to group:\", message, group, endpoint, connection);\n\t            }\n\t        }\n\t    }\n\t    that.socketOnJoin = socketOnJoin;\n\t\n\t    /**\n\t     * Socket handler for leave messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.socketOnLeave\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     */\n\t    function socketOnLeave(message) {\n\t        var group;\n\t        var presenceMessage;\n\t        var endpoint;\n\t        if (message.connectionId === client.connectionId) {\n\t            group = client.getGroup({id: message.header.channel});\n\t            client.fire('leave', {\n\t                group: group\n\t            });\n\t        } else {\n\t\n\t            endpoint = client.getEndpoint({\n\t                skipPresence: true,\n\t                id: message.endpointId\n\t            });\n\t\n\t            endpoint.connections.every(function eachConnection(conn, index) {\n\t                if (conn.id === message.connectionId) {\n\t                    endpoint.connections.splice(index, 1);\n\t                    return false;\n\t                }\n\t                return true;\n\t            });\n\t\n\t            group = client.getGroup({id: message.header.channel});\n\t            if (group) {\n\t                group.removeMember({connectionId: message.connectionId});\n\t            }\n\t        }\n\t    }\n\t    that.socketOnLeave = socketOnLeave;\n\t\n\t    /**\n\t     * Socket handler for presence messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.onMessage\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     * @fires respoke.Endpoint#message\n\t     * @fires respoke.Client#message\n\t     */\n\t    function socketOnMessage(message) {\n\t        var endpoint;\n\t        message = respoke.TextMessage({rawMessage: message});\n\t        if (message.originalRecipient || message.endpointId) {\n\t            endpoint = client.getEndpoint({\n\t                id: message.originalRecipient || message.endpointId,\n\t                skipCreate: true\n\t            });\n\t        }\n\t        if (endpoint) {\n\t            /**\n\t             * Indicate that a message has been received.\n\t             * @event respoke.Endpoint#message\n\t             * @type {respoke.Event}\n\t             * @property {respoke.TextMessage} message\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Endpoint} target\n\t             */\n\t            endpoint.fire('message', {\n\t                message: message\n\t            });\n\t        }\n\t        /**\n\t         * Indicate that a message has been received.\n\t         * @event respoke.Client#message\n\t         * @type {respoke.Event}\n\t         * @property {respoke.TextMessage} message\n\t         * @property {respoke.Endpoint} [endpoint] - If the message is from an endpoint we already know about,\n\t         * this will be set. If null, the developer can use client.getEndpoint({id: evt.message.endpointId}) to get\n\t         * the Endpoint. From that point forward, Endpoint#message will fire when a message is received as well.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Client} target\n\t         */\n\t        client.fire('message', {\n\t            endpoint: endpoint || null,\n\t            message: message\n\t        });\n\t    }\n\t    that.socketOnMessage = socketOnMessage;\n\t\n\t    /**\n\t     * Create a socket handler for the onConnect event with all the right things in scope.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.generateConnectHandler\n\t     * @param {respoke.Client.successHandler} [onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @private\n\t     */\n\t    var generateConnectHandler = function generateConnectHandler(onSuccess, onError) {\n\t        onSuccess = onSuccess || function () {};\n\t        onError = onError || function () {};\n\t        return function onConnect() {\n\t            Object.keys(handlerQueue).forEach(function addEachHandlerType(category) {\n\t                if (!handlerQueue[category]) {\n\t                    return;\n\t                }\n\t\n\t                handlerQueue[category].forEach(function addEachHandler(handler) {\n\t                    that.socket.on(category, handler);\n\t                });\n\t                handlerQueue[category] = [];\n\t            });\n\t\n\t            wsCall({\n\t                path: '/v1/connections',\n\t                httpMethod: 'POST',\n\t                parameters: {\n\t                    capabilities: {\n\t                        iceFinalCandidates: true\n\t                    }\n\t                }\n\t            }).done(function successHandler(res) {\n\t                log.debug('connections result', res);\n\t                client.endpointId = res.endpointId;\n\t                client.connectionId = res.id;\n\t                onSuccess();\n\t            }, onError);\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Socket handler for presence messages.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.socketOnPresence\n\t     * @param {object} message The Socket.io message.\n\t     * @private\n\t     */\n\t    function socketOnPresence(message) {\n\t        var endpoint;\n\t        var groups;\n\t\n\t        if (message.header.from === client.endpointId) {\n\t            log.debug('socket.on presence for self ignored', message);\n\t            // Skip ourselves\n\t            return;\n\t        }\n\t        log.debug('socket.on presence', message);\n\t\n\t        endpoint = client.getEndpoint({\n\t            skipPresence: true,\n\t            id: message.header.from,\n\t            instanceId: instanceId,\n\t            // TODO: find out what this is for? should it be message.header.type?\n\t            name: message.header.from,\n\t            connection: message.header.fromConnection\n\t        });\n\t\n\t        endpoint.setPresence({\n\t            connectionId: message.header.fromConnection,\n\t            presence: message.type\n\t        });\n\t\n\t        if (endpoint.presence === 'unavailable') {\n\t            groups = client.getGroups();\n\t            if (groups) {\n\t                groups.forEach(function eachGroup(group) {\n\t                    group.removeMember({connectionId: message.header.fromConnection});\n\t                });\n\t            }\n\t        }\n\t    }\n\t    that.socketOnPresence = socketOnPresence;\n\t\n\t    /**\n\t     * On reconnect, start with a reconnect interval of 2000ms. Every time reconnect fails, the interval\n\t     * is doubled up to a maximum of 5 minutes. From then on, it will attempt to reconnect every 5 minutes forever.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.reconnect\n\t     * @private\n\t     */\n\t    function reconnect() {\n\t        if (clientSettings.reconnect !== true) {\n\t            return;\n\t        }\n\t        // Reconnects within reconnects is ungood\n\t        clientSettings.reconnect = false;\n\t\n\t        appToken = null;\n\t        token = null;\n\t\n\t        if (that.socket) {\n\t            that.socket.removeAllListeners();\n\t            that.socket.disconnect();\n\t            that.socket = null;\n\t        }\n\t\n\t        reconnectTimeout = (reconnectTimeout === null) ? 2500 : 2 * reconnectTimeout;\n\t\n\t        if (reconnectTimeout > (maxReconnectTimeout)) {\n\t            reconnectTimeout = maxReconnectTimeout;\n\t        }\n\t\n\t        setTimeout(function doReconnect() {\n\t            log.debug('Reconnecting...');\n\t\n\t            actuallyConnect().then(function successHandler() {\n\t                reconnectTimeout = null;\n\t                log.debug('socket reconnected');\n\t                return Q.all(client.getGroups().map(function iterGroups(group) {\n\t                    client.join({\n\t                        id: group.id,\n\t                        onMessage: clientSettings.onMessage,\n\t                        onJoin: clientSettings.onJoin,\n\t                        onLeave: clientSettings.onLeave\n\t                    }).catch(function (err) {\n\t                        log.error(\"Couldn't rejoin previous group.\", { id: group.id, message: err.message, stack: err.stack });\n\t                        throw err;\n\t                    });\n\t                }));\n\t            }).then(function successHandler() {\n\t                log.debug('groups rejoined after reconnect');\n\t                /**\n\t                 * Indicate that a reconnect has succeeded.\n\t                 * @event respoke.Client#reconnect\n\t                 * @property {string} name - the event name.\n\t                 * @property {respoke.Client}\n\t                 */\n\t                client.fire('reconnect');\n\t            }).fin(function finHandler() {\n\t                // re-enable reconnects\n\t                clientSettings.reconnect = true;\n\t            }).done(null, function errHandler(err) {\n\t                log.error(\"Couldn't reconnect. Retrying...\", { message: err.message, stack: err.stack });\n\t                reconnect();\n\t            });\n\t        }, reconnectTimeout);\n\t    }\n\t\n\t    /**\n\t     * Authenticate to the cloud and call the handler on state change.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.authenticate\n\t     * @private\n\t     * @param {object} params\n\t     * @return {Promise}\n\t     */\n\t    that.authenticate = function authenticate(params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var pieces = [];\n\t        var protocol = null;\n\t        var host = null;\n\t        var port = null;\n\t\n\t        if (!appToken) {\n\t            deferred.reject(new Error(\"Can't open a websocket without an app token.\"));\n\t        }\n\t\n\t        pieces = clientSettings.baseURL.split(/:\\/\\//);\n\t        protocol = pieces[0];\n\t        pieces = pieces[1].split(/:/);\n\t        host = pieces[0];\n\t        port = pieces[1];\n\t\n\t        var connectParams = {\n\t            'connect timeout': clientSettings.connectTimeoutMillis,\n\t            'force new connection': true, // Don't try to reuse old connection.\n\t            'sync disconnect on unload': true, // have Socket.io call disconnect() on the browser unload event.\n\t            reconnect: false,\n\t            host: host,\n\t            port: port || '443',\n\t            protocol: protocol,\n\t            secure: (protocol === 'https'),\n\t            query: '__sails_io_sdk_version=0.10.0&app-token=' + appToken + '&Respoke-SDK=' + sdkHeaderValue\n\t        };\n\t\n\t        if (that.isConnected() || isConnecting()) {\n\t            return;\n\t        }\n\t\n\t        that.socket = respoke.io.connect(clientSettings.baseURL, connectParams);\n\t\n\t        that.socket.on('connect', generateConnectHandler(function onSuccess() {\n\t            deferred.resolve();\n\t        }, function onError(err) {\n\t            deferred.reject(err);\n\t        }));\n\t\n\t        that.socket.on('join', socketOnJoin);\n\t        that.socket.on('leave', socketOnLeave);\n\t        that.socket.on('pubsub', socketOnPubSub);\n\t        that.socket.on('message', socketOnMessage);\n\t        that.socket.on('presence', socketOnPresence);\n\t        that.socket.on('signal', socketOnSignal);\n\t\n\t        // connection timeout\n\t        that.socket.on('connect_failed', function connectFailedHandler(res) {\n\t            deferred.reject(new Error(\"WebSocket connection failed.\"));\n\t            log.error('Socket.io connect timeout.', res || \"\");\n\t            reconnect();\n\t        });\n\t\n\t        // handshake error, 403, socket disconnects on FireFox\n\t        that.socket.on('error', function errorHandler(res) {\n\t            log.error('Socket.io error.', res || \"\");\n\t            reconnect();\n\t        });\n\t\n\t        that.socket.on('disconnect', function onDisconnect() {\n\t            log.debug('Socket.io disconnect.');\n\t            pendingRequests.reset(function (pendingRequest) {\n\t                log.debug('Failing pending requests');\n\t                pendingRequest.reject(new Error(\"WebSocket disconnected\"));\n\t            });\n\t\n\t            /**\n\t             * Indicate that this client has been disconnected from the Respoke service.\n\t             * @event respoke.Client#disconnect\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            client.fire('disconnect');\n\t\n\t            reconnect();\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Get ephemeral TURN credentials.  This method is called whenever a call is either\n\t     * sent or received, prior to creating a PeerConnection\n\t     *\n\t     * @memberof! respoke.SignalingChannel\n\t     * @private\n\t     * @method respoke.SignalingChannel.getTurnCredentials\n\t     * @return {Promise<Array>}\n\t     */\n\t    that.getTurnCredentials = function getTurnCredentials() {\n\t        var deferred = Q.defer();\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        wsCall({\n\t            httpMethod: 'GET',\n\t            path: '/v1/turn'\n\t        }).done(function successHandler(creds) {\n\t            var result = [];\n\t\n\t            if (!creds || !creds.uris) {\n\t                deferred.reject(new Error(\"Turn credentials empty.\"));\n\t                return;\n\t            }\n\t\n\t            creds.uris.forEach(function saveTurnUri(uri) {\n\t                var cred = null;\n\t\n\t                if (!uri) {\n\t                    return;\n\t                }\n\t\n\t                cred = createIceServer(uri, creds.username, creds.password);\n\t                result.push(cred);\n\t            });\n\t\n\t            if (result.length === 0) {\n\t                deferred.reject(new Error(\"Got no TURN credentials.\"));\n\t            }\n\t\n\t            log.debug('TURN creds', result);\n\t            deferred.resolve(result);\n\t        }, function errorHandler(err) {\n\t            deferred.reject(err);\n\t        });\n\t\n\t        return deferred.promise;\n\t    };\n\t\n\t    /**\n\t     * Construct a websocket API call and return the formatted response and errors. The 'success'\n\t     * attribute indicates the success or failure of the API call. The 'response' attribute\n\t     * is an associative array constructed by json.decode. The 'error' attriute is a message.\n\t     * If the API call is successful but the server returns invalid JSON, error will be\n\t     * \"Invalid JSON.\" and response will be the unchanged content of the response body.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.wsCall\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} params.httpMethod\n\t     * @param {string} params.path\n\t     * @param {string} params.objectId\n\t     * @param {object} params.parameters - These are request body parameters that get converted to JSON before\n\t     * being sent over the websocket. Undefined parameters and functions are removed by JSON.stringify.\n\t     * @return {Promise<object>}\n\t     */\n\t    function wsCall(params) {\n\t        params = params || {};\n\t        var deferred = Q.defer();\n\t        var start = now();\n\t        // Too many of these!\n\t        var logRequest = (params.path.indexOf('messages') === -1 && params.path.indexOf('signaling') === -1) ||\n\t            respoke.ridiculous;\n\t        var request;\n\t        var bodyLength = 0;\n\t        if (params.parameters) {\n\t            bodyLength = encodeURI(JSON.stringify(params.parameters)).split(/%..|./).length - 1;\n\t        }\n\t\n\t        if (!that.isConnected()) {\n\t            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!params) {\n\t            deferred.reject(new Error('No params.'));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (!params.path) {\n\t            deferred.reject(new Error('No request path.'));\n\t            return deferred.promise;\n\t        }\n\t\n\t        if (bodyLength > bodySizeLimit) {\n\t            deferred.reject(new Error('Request body exceeds maximum size of ' + bodySizeLimit + ' bytes'));\n\t            return deferred.promise;\n\t        }\n\t\n\t        params.httpMethod = (params.httpMethod || 'get').toLowerCase();\n\t\n\t        if (params.urlParams) {\n\t            params.path = template.parse(params.path).expand(params.urlParams);\n\t        }\n\t\n\t        if (logRequest) {\n\t            log.debug('socket request', {\n\t                method: params.httpMethod,\n\t                path: params.path,\n\t                parameters: params.parameters\n\t            });\n\t        }\n\t\n\t        request = {\n\t            method: params.httpMethod,\n\t            path: params.path,\n\t            parameters: params.parameters,\n\t            tries: 0,\n\t            durationMillis: 0\n\t        };\n\t\n\t        request.id = pendingRequests.add(deferred);\n\t\n\t        function handleResponse(response) {\n\t            var thisHandler = this; // jshint ignore:line\n\t            /*\n\t             * Response:\n\t             *  {\n\t             *      body: {},\n\t             *      headers: {},\n\t             *      statusCode: 200\n\t             *  }\n\t             */\n\t            try {\n\t                response.body = JSON.parse(response.body);\n\t            } catch (e) {\n\t                if (typeof response.body !== 'object') {\n\t                    deferred.reject(new Error(\"Server response could not be parsed!\" + response.body));\n\t                    return;\n\t                }\n\t            }\n\t\n\t            if (response.statusCode === 429) {\n\t                if (request.tries < 3 && deferred.promise.isPending()) {\n\t                    setTimeout(function () {\n\t                        start = now();\n\t                        sendWebsocketRequest(request, handleResponse);\n\t                    }, 1000); // one day this will be response.interval or something\n\t                } else {\n\t                    request.durationMillis = now() - start;\n\t                    pendingRequests.remove(request.id);\n\t                    failWebsocketRequest(request, response,\n\t                            \"Too many retries after rate limit exceeded.\", deferred);\n\t                }\n\t                return;\n\t            }\n\t\n\t            request.durationMillis = now() - start;\n\t            pendingRequests.remove(request.id);\n\t\n\t            if (logRequest) {\n\t                log.debug('socket response', {\n\t                    method: request.method,\n\t                    path: request.path,\n\t                    durationMillis: request.durationMillis,\n\t                    response: response\n\t                });\n\t            }\n\t\n\t            if (isBillingSuspensionUnauthorizedResponse(response)) {\n\t                failWebsocketRequest(request, response, billingSuspensionErrorMessage, deferred);\n\t                return;\n\t            }\n\t\n\t            if (isSuspensionUnauthorizedResponse(response)) {\n\t                failWebsocketRequest(request, response, suspensionErrorMessage, deferred);\n\t                return;\n\t            }\n\t\n\t            if ([200, 204, 205, 302, 401, 403, 404, 418].indexOf(thisHandler.status) === -1) {\n\t                failWebsocketRequest(request, response,\n\t                        response.body.error || errors[thisHandler.status] || \"Unknown error\", deferred);\n\t                return;\n\t            }\n\t\n\t            deferred.resolve(response.body);\n\t        }\n\t\n\t        start = now();\n\t        sendWebsocketRequest(request, handleResponse);\n\t        return deferred.promise;\n\t    }\n\t    that.wsCall = wsCall;\n\t\n\t    function failWebsocketRequest(request, response, error, deferred) {\n\t        if (response && response.body && response.body.error) {\n\t            deferred.reject(buildResponseError(response, error + ' (' + request.method + ' ' + request.path + ')'));\n\t        } else {\n\t            deferred.resolve(response.body);\n\t        }\n\t    }\n\t\n\t    function sendWebsocketRequest(request, handleResponse) {\n\t        request.tries += 1;\n\t        that.socket.emit(request.method, JSON.stringify({\n\t            url: request.path,\n\t            data: request.parameters,\n\t            headers: {\n\t                'App-Token': appToken,\n\t                'Respoke-SDK': sdkHeaderValue }\n\t        }), handleResponse);\n\t    }\n\t\n\t    /**\n\t     * Construct an API call and return the formatted response and errors. The 'success'\n\t     * attribute indicates the success or failure of the API call. The 'response' attribute\n\t     * is an associative array constructed by json.decode. The 'error' attribute is a message.\n\t     * If the API call is successful but the server returns invalid JSON, error will be\n\t     * \"Invalid JSON.\" and response will be the unchanged content of the response body.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.call\n\t     * @private\n\t     * @param {object} params\n\t     * @param {string} params.httpMethod\n\t     * @param {string} params.objectId\n\t     * @param {string} params.path\n\t     * @param {object} params.parameters\n\t     * @returns {Promise}\n\t     */\n\t    function call(params) {\n\t        /* Params go in the URI for GET, DELETE, same format for\n\t         * POST and PUT, but they must be sent separately after the\n\t         * request is opened. */\n\t        var deferred = Q.defer();\n\t        var paramString = null;\n\t        var uri = null;\n\t        var response = {\n\t            body: null,\n\t            statusCode: null\n\t        };\n\t        var start = now();\n\t\n\t        uri = clientSettings.baseURL + params.path;\n\t\n\t        if (!params) {\n\t            deferred.reject(new Error('No params.'));\n\t            return;\n\t        }\n\t\n\t        if (!params.httpMethod) {\n\t            deferred.reject(new Error('No HTTP method.'));\n\t            return;\n\t        }\n\t\n\t        if (!params.path) {\n\t            deferred.reject(new Error('No request path.'));\n\t            return;\n\t        }\n\t\n\t        if (params.urlParams) {\n\t            uri = template.parse(uri).expand(params.urlParams);\n\t        }\n\t\n\t        if (['GET', 'DELETE'].indexOf(params.httpMethod) > -1) {\n\t            uri += makeParamString(params.parameters);\n\t        }\n\t\n\t        xhr.open(params.httpMethod, uri);\n\t        xhr.setRequestHeader('Respoke-SDK', sdkHeaderValue);\n\t        if (appToken) {\n\t            xhr.setRequestHeader(\"App-Token\", appToken);\n\t        }\n\t        if (['POST', 'PUT'].indexOf(params.httpMethod) > -1) {\n\t            paramString = JSON.stringify(params.parameters);\n\t            if (paramString.length > bodySizeLimit) {\n\t                deferred.reject(new Error('Request body exceeds maximum size of ' + bodySizeLimit + ' bytes'));\n\t                return;\n\t            }\n\t            xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\t        } else if (['GET', 'DELETE'].indexOf(params.httpMethod) === -1) {\n\t            deferred.reject(new Error('Illegal HTTP request method ' + params.httpMethod));\n\t            return;\n\t        }\n\t        log.debug('request', {\n\t            method: params.httpMethod,\n\t            uri: uri,\n\t            params: paramString\n\t        });\n\t\n\t        try {\n\t            xhr.send(paramString);\n\t        } catch (err) {\n\t            deferred.reject(err);\n\t            return;\n\t        }\n\t\n\t        xhr.onreadystatechange = function () {\n\t            var durationMillis = now() - start;\n\t            var limit;\n\t            var unit;\n\t\n\t            if (this.readyState !== 4) {\n\t                return;\n\t            }\n\t\n\t            if (this.status === 0) {\n\t                deferred.reject(new Error(\"Status is 0: Incomplete request, SSL error, or CORS error.\"));\n\t                return;\n\t            }\n\t\n\t            response.statusCode = this.status;\n\t            response.headers = getAllResponseHeaders(this);\n\t            response.uri = uri;\n\t            response.params = params.parameters;\n\t            response.error = errors[this.status];\n\t\n\t            if (this.response) {\n\t                try {\n\t                    response.body = JSON.parse(this.response);\n\t                } catch (e) {\n\t                    response.body = this.response;\n\t                    response.error = \"Invalid JSON.\";\n\t                }\n\t            }\n\t\n\t            log.debug('response', {\n\t                method: params.httpMethod,\n\t                durationMillis: durationMillis,\n\t                response: response\n\t            });\n\t\n\t            if ([200, 204, 205, 302, 401, 403, 404, 418].indexOf(this.status) > -1) {\n\t                deferred.resolve(response);\n\t            } else if (this.status === 429) {\n\t                unit = getResponseHeader(this, 'RateLimit-Time-Units');\n\t                limit = getResponseHeader(this, 'RateLimit-Limit');\n\t                deferred.reject(buildResponseError(response, \"Rate limit of \" + limit + \"/\" + unit +\n\t                    \" exceeded. Try again in 1 \" + unit + \".\"));\n\t            } else {\n\t                deferred.reject(buildResponseError(response, 'unexpected response code ' + this.status));\n\t            }\n\t        };\n\t\n\t        return deferred.promise;\n\t    }\n\t\n\t    function isSuspensionUnauthorizedResponse(response) {\n\t        return (response.statusCode === 401) && response.body && response.body.details &&\n\t            (typeof response.body.details.message === 'string') &&\n\t            (response.body.details.message.indexOf('suspended') > -1);\n\t    }\n\t\n\t    function isBillingSuspensionUnauthorizedResponse(response) {\n\t        return isSuspensionUnauthorizedResponse(response) &&\n\t            (typeof response.body.details.reason === 'string') &&\n\t            (response.body.details.reason.indexOf('billing suspension') > -1);\n\t    }\n\t\n\t    /**\n\t     * Turn key/value and key/list pairs into an HTTP URL parameter string.\n\t     * var1=value1&var2=value2,value3,value4\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.makeParamString\n\t     * @private\n\t     * @param {object} params - Arbitrary collection of strings and arrays to serialize.\n\t     * @returns {string}\n\t     */\n\t    function makeParamString(params) {\n\t        var strings = [];\n\t        if (!params) {\n\t            return '';\n\t        }\n\t\n\t        Object.keys(params).forEach(function formatParam(name) {\n\t            var value = params[name];\n\t            /* Skip objects -- We won't know how to name these. */\n\t            if (value instanceof Array) {\n\t                strings.push([name, value.join(',')].join('='));\n\t            } else if (typeof value !== 'object' && typeof value !== 'function') {\n\t                strings.push([name, value].join('='));\n\t            }\n\t        });\n\t\n\t        if (strings.length > 0) {\n\t            return '?' + strings.join('&');\n\t        } else {\n\t            return '';\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Tries to retrieve a single header value from an XHR response. If the header is disallowed,\n\t     * or does not exist, will return null. Otherwise returns the value of the header.\n\t     *\n\t     * The CORS spec does not define what the browser should do in the case of a request for a\n\t     * disallowed header, but at least Chrome throws an exception.\n\t     *\n\t     * @param {object} xhrResponse The response of an XMLHttpRequest\n\t     * @param {string} header The name of the header to retrieve the value for\n\t     * @returns {string|null} The value(s) of the header, or null if disallowed or unavailable.\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getResponseHeader\n\t     * @private\n\t     */\n\t    function getResponseHeader(xhrResponse, header) {\n\t        try {\n\t            return xhrResponse.getResponseHeader(header);\n\t        } catch (e) {\n\t            return null;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Retrieves all headers from an XHR response as key/val pairs\n\t     *\n\t     * @param {object} xhrResponse The response of an XMLHttpRequest\n\t     * @returns {*} the key/val pairs of the response headers\n\t     * @memberof! respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.getAllResponseHeaders\n\t     * @private\n\t     */\n\t    function getAllResponseHeaders(xhrResponse) {\n\t        var result = {};\n\t        var headers;\n\t        var pairs;\n\t\n\t        headers = xhrResponse.getAllResponseHeaders();\n\t        if (!headers) {\n\t            return result;\n\t        }\n\t\n\t        // 1 header per line (cr+lf)\n\t        pairs = headers.split('\\u000d\\u000a');\n\t        pairs.forEach(function (pair) {\n\t            var key;\n\t            var val;\n\t\n\t            // key separated from value by ': '\n\t            // value may contain ': ', so using indexOf instead of split\n\t            var index = pair.indexOf('\\u003a\\u0020');\n\t            if (index > 0) {\n\t                key = pair.substring(0, index);\n\t                val = pair.substring(index + 2);\n\t                result[key] = val;\n\t            }\n\t        });\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an Error with the supplied `message` and, if available, the `Request-Id` header\n\t     * from the supplied `response`.\n\t     *\n\t     * @param {object} res\n\t     * @param {object} [res.headers]\n\t     * @param {string} [res.headers.Request-Id] The requestId to append to the Error message\n\t     * @param {string} message The message the Error should be constructed with\n\t     * @returns {Error} the constructed Error object\n\t     * @memberof respoke.SignalingChannel\n\t     * @method respoke.SignalingChannel.buildResponseError\n\t     * @api private\n\t     */\n\t    function buildResponseError(res, message) {\n\t        var requestId = res && res.headers && res.headers['Request-Id'];\n\t        if (requestId) {\n\t            message += ' [Request-Id: ' + requestId + ']';\n\t        }\n\t\n\t        return new Error(message);\n\t    }\n\t\n\t    return that;\n\t}; // End respoke.SignalingChannel\n\t/**\n\t * Handle an error that resulted from a method call.\n\t * @callback respoke.SignalingChannel.errorHandler\n\t * @params {Error} err\n\t */\n\t/**\n\t * Handle sending successfully.\n\t * @callback respoke.SignalingChannel.sendHandler\n\t */\n\t/**\n\t * Receive a group.\n\t * @callback respoke.SignalingChannel.groupHandler\n\t * @param {respoke.Group}\n\t */\n\t/**\n\t * Receive a list of groups.\n\t * @callback respoke.SignalingChannel.groupListHandler\n\t * @param {Array}\n\t */\n\t/**\n\t * Receive a list of TURN credentials.\n\t * @callback respoke.SignalingChannel.turnSuccessHandler\n\t * @param {Array}\n\t */\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (root, factory) {\n\t    if (true) {\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        define([], factory);\n\t    } else {\n\t        root.urltemplate = factory();\n\t    }\n\t}(this, function () {\n\t  /**\n\t   * @constructor\n\t   */\n\t  function UrlTemplate() {\n\t  }\n\t\n\t  /**\n\t   * @private\n\t   * @param {string} str\n\t   * @return {string}\n\t   */\n\t  UrlTemplate.prototype.encodeReserved = function (str) {\n\t    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n\t      if (!/%[0-9A-Fa-f]/.test(part)) {\n\t        part = encodeURI(part);\n\t      }\n\t      return part;\n\t    }).join('');\n\t  };\n\t\n\t  /**\n\t   * @private\n\t   * @param {string} operator\n\t   * @param {string} value\n\t   * @param {string} key\n\t   * @return {string}\n\t   */\n\t  UrlTemplate.prototype.encodeValue = function (operator, value, key) {\n\t    value = (operator === '+' || operator === '#') ? this.encodeReserved(value) : encodeURIComponent(value);\n\t\n\t    if (key) {\n\t      return encodeURIComponent(key) + '=' + value;\n\t    } else {\n\t      return value;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * @private\n\t   * @param {*} value\n\t   * @return {boolean}\n\t   */\n\t  UrlTemplate.prototype.isDefined = function (value) {\n\t    return value !== undefined && value !== null;\n\t  };\n\t\n\t  /**\n\t   * @private\n\t   * @param {string}\n\t   * @return {boolean}\n\t   */\n\t  UrlTemplate.prototype.isKeyOperator = function (operator) {\n\t    return operator === ';' || operator === '&' || operator === '?';\n\t  };\n\t\n\t  /**\n\t   * @private\n\t   * @param {Object} context\n\t   * @param {string} operator\n\t   * @param {string} key\n\t   * @param {string} modifier\n\t   */\n\t  UrlTemplate.prototype.getValues = function (context, operator, key, modifier) {\n\t    var value = context[key],\n\t        result = [];\n\t\n\t    if (this.isDefined(value) && value !== '') {\n\t      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n\t        value = value.toString();\n\t\n\t        if (modifier && modifier !== '*') {\n\t          value = value.substring(0, parseInt(modifier, 10));\n\t        }\n\t\n\t        result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n\t      } else {\n\t        if (modifier === '*') {\n\t          if (Array.isArray(value)) {\n\t            value.filter(this.isDefined).forEach(function (value) {\n\t              result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n\t            }, this);\n\t          } else {\n\t            Object.keys(value).forEach(function (k) {\n\t              if (this.isDefined(value[k])) {\n\t                result.push(this.encodeValue(operator, value[k], k));\n\t              }\n\t            }, this);\n\t          }\n\t        } else {\n\t          var tmp = [];\n\t\n\t          if (Array.isArray(value)) {\n\t            value.filter(this.isDefined).forEach(function (value) {\n\t              tmp.push(this.encodeValue(operator, value));\n\t            }, this);\n\t          } else {\n\t            Object.keys(value).forEach(function (k) {\n\t              if (this.isDefined(value[k])) {\n\t                tmp.push(encodeURIComponent(k));\n\t                tmp.push(this.encodeValue(operator, value[k].toString()));\n\t              }\n\t            }, this);\n\t          }\n\t\n\t          if (this.isKeyOperator(operator)) {\n\t            result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n\t          } else if (tmp.length !== 0) {\n\t            result.push(tmp.join(','));\n\t          }\n\t        }\n\t      }\n\t    } else {\n\t      if (operator === ';') {\n\t        result.push(encodeURIComponent(key));\n\t      } else if (value === '' && (operator === '&' || operator === '?')) {\n\t        result.push(encodeURIComponent(key) + '=');\n\t      } else if (value === '') {\n\t        result.push('');\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @param {string} template\n\t   * @return {function(Object):string}\n\t   */\n\t  UrlTemplate.prototype.parse = function (template) {\n\t    var that = this;\n\t    var operators = ['+', '#', '.', '/', ';', '?', '&'];\n\t\n\t    return {\n\t      expand: function (context) {\n\t        return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n\t          if (expression) {\n\t            var operator = null,\n\t                values = [];\n\t\n\t            if (operators.indexOf(expression.charAt(0)) !== -1) {\n\t              operator = expression.charAt(0);\n\t              expression = expression.substr(1);\n\t            }\n\t\n\t            expression.split(/,/g).forEach(function (variable) {\n\t              var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n\t              values.push.apply(values, that.getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n\t            });\n\t\n\t            if (operator && operator !== '+') {\n\t              var separator = ',';\n\t\n\t              if (operator === '?') {\n\t                separator = '&';\n\t              } else if (operator !== '#') {\n\t                separator = operator;\n\t              }\n\t              return (values.length !== 0 ? operator : '') + values.join(separator);\n\t            } else {\n\t              return values.join(',');\n\t            }\n\t          } else {\n\t            return that.encodeReserved(literal);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  };\n\t\n\t  return new UrlTemplate();\n\t}));\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(8);\n\tvar respoke = __webpack_require__(1);\n\tvar log = respoke.log;\n\t\n\t/**\n\t * A direct connection via RTCDataChannel, including state and path negotation.\n\t * @class respoke.DirectConnection\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {string} params\n\t * @param {string} params.instanceId - client id\n\t * @param {respoke.Call} params.call - The call that is handling state for this direct connection.\n\t * @param {boolean} [params.forceTurn] - If true, force the data to flow through relay servers instead of allowing\n\t * it to flow peer-to-peer. The relay acts like a blind proxy.\n\t * @param {string} params.connectionId - The connection ID of the remoteEndpoint.\n\t * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n\t * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n\t * @param {function} params.signalReport - Signaling action from SignalingChannel.\n\t * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n\t * @param {respoke.DirectConnection.onStart} [params.onStart] - Callback for when setup of the direct connection\n\t * begins. The direct connection will not be open yet.\n\t * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors that happen during\n\t * direct connection setup or media renegotiation.\n\t * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for closing the direct connection.\n\t * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for opening the direct connection.\n\t * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the request\n\t * for a direct connection and setup is about to begin.\n\t * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for incoming messages. Not usually\n\t * necessary to listen to this event if you are already listening to respoke.Endpoint#message.\n\t * @returns {respoke.DirectConnection}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t\n\t    /**\n\t     * A name to identify this class\n\t     * @memberof! respoke.DirectConnection\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.DirectConnection';\n\t    /**\n\t     * The unique identifier of the direct connection.\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = respoke.makeGUID();\n\t\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name call\n\t     * @type {respoke.Call}\n\t     */\n\t    if (!that.call.caller) {\n\t        that.call.caller = false;\n\t    }\n\t\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name dataChannel\n\t     * @type {RTCDataChannel}\n\t     * @private\n\t     */\n\t    var dataChannel = null;\n\t\n\t    /**\n\t     * @memberof! respoke.DirectConnection\n\t     * @name pc\n\t     * @type {RTCPeerConnection}\n\t     * @private\n\t     */\n\t    var pc = params.pc;\n\t    delete params.pc;\n\t\n\t    /**\n\t     * When the datachannel is availble, we need to attach the callbacks. The event this function is attached to\n\t     * only fires for the callee.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.listenDataChannel\n\t     * @param {respoke.Event} evt\n\t     * @private\n\t     */\n\t    function listenDataChannel(evt) {\n\t        dataChannel = evt.channel;\n\t        dataChannel.onerror = onDataChannelError;\n\t        dataChannel.onmessage = onDataChannelMessage;\n\t        if (dataChannel.readyState === 'open') {\n\t            dataChannel.onopen = null;\n\t            onDataChannelOpen();\n\t        } else {\n\t            dataChannel.onopen = onDataChannelOpen;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Register any event listeners passed in as callbacks\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.saveParameters\n\t     * @param {object} params\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for when the direct connection\n\t     * is closed.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for when the direct connection\n\t     * is open.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for incoming messages.\n\t     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n\t     * connection.\n\t     * @param {respoke.DirectConnection.onStart} [params.onStart] - Callback for when the direct connection\n\t     * is being set up. The direct connection will not be open yet.\n\t     * @param {boolean} [params.forceTurn] - If true, force the data to flow through relay servers instead of allowing\n\t     * it to flow peer-to-peer. The relay acts like a blind proxy.\n\t     * @private\n\t     */\n\t    function saveParameters(params) {\n\t        /**\n\t         * The direct connection is open.\n\t         * @event respoke.DirectConnection#open\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.listen('open', params.onOpen);\n\t        /**\n\t         * The direct connection is closed.\n\t         * @event respoke.DirectConnection#close\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.listen('close', params.onClose);\n\t        /**\n\t         * Incoming message on this direct connection.\n\t         * @event respoke.DirectConnection#message\n\t         * @type {respoke.Event}\n\t         * @property {respoke.TextMessage} message\n\t         * @property {respoke.Endpoint} endpoint\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.listen('message', params.onMessage);\n\t        // documented elsewhere\n\t        that.listen('start', params.onStart);\n\t        /**\n\t         * An error occurred while setting up the direct connection.\n\t         * @event respoke.DirectConnection#error\n\t         * @type {respoke.Event}\n\t         * @property {string} reason - A human-readable description of the error.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.listen('error', params.onError);\n\t        pc.listen('direct-connection', listenDataChannel, true);\n\t        pc.listen('stats', function fireStats(evt) {\n\t            /**\n\t             * This event is fired every time statistical information about the direct connection\n\t             * becomes available.\n\t             * @event respoke.DirectConnection#stats\n\t             * @type {respoke.Event}\n\t             * @property {object} stats - an object with stats in it.\n\t             * @property {respoke.DirectConnection} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.fire('stats', {stats: evt.stats});\n\t        }, true);\n\t\n\t    }\n\t    saveParameters(params);\n\t\n\t    delete that.onOpen;\n\t    delete that.onClose;\n\t    delete that.onMessage;\n\t\n\t    /**\n\t     * Return media stats. Since we have to wait for both the answer and offer to be available before starting\n\t     * statistics, we'll return a promise for the stats object.\n\t     *\n\t     *     directConnection.getStats({\n\t     *         onStats: function (evt) {\n\t     *             console.log('Stats', evt.stats);\n\t     *         }\n\t     *     }).done(function () {\n\t     *         console.log('Stats started.');\n\t     *     }, function (err) {\n\t     *         console.log('Direct connection is already closed.');\n\t     *     });\n\t     *\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.getStats\n\t     * @returns {Promise<object>|undefined}\n\t     * @param {object} params\n\t     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive the\n\t     * stats if the Respoke stats module is loaded. If no callback is provided, the connection's report will\n\t     * contain stats but the developer will not receive them on the client-side.\n\t     * @param {respoke.DirectConnection.statsSuccessHandler} [params.onSuccess] - Success handler for this\n\t     * invocation of this method only.\n\t     * @param {respoke.DirectConnection.errorHandler} [params.onError] - Error handler for this invocation of\n\t     * this method only.\n\t     */\n\t    that.getStats = function (params) {\n\t        if (pc && pc.getStats) {\n\t            that.listen('stats', params.onStats);\n\t            delete params.onStats;\n\t            return pc.getStats(params);\n\t        }\n\t        return null;\n\t    };\n\t\n\t    if (!respoke.MediaStats) {\n\t        delete that.getStats;\n\t    }\n\t\n\t    /**\n\t     * Detect datachannel errors for internal state.\n\t     * @memberof! respoke.DirectConnection\n\t     * @private\n\t     * @method respoke.DirectConnection.onDataChannelError\n\t     */\n\t    function onDataChannelError(error) {\n\t        /**\n\t         * Indicate that an error has occurred setting up the direct connection.\n\t         * @event respoke.DirectConnection#error\n\t         * @type {respoke.Event}\n\t         * @property {object} error\n\t         * @property {respoke.DirectConnection} directConnection\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('error', {\n\t            error: error\n\t        });\n\t        that.close();\n\t    }\n\t\n\t    /**\n\t     * Receive and route messages to the Endpoint.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.onDataChannelMessage\n\t     * @private\n\t     * @param {MessageEvent}\n\t     * @fires respoke.DirectConnection#message\n\t     */\n\t    function onDataChannelMessage(evt) {\n\t        var message;\n\t        try {\n\t            message = JSON.parse(evt.data);\n\t        } catch (e) {\n\t            message = evt.data;\n\t        }\n\t        /**\n\t         * A message has been received over the direct connection.\n\t         * @event respoke.Endpoint#message\n\t         * @type {respoke.Event}\n\t         * @property {object} message\n\t         * @property {respoke.DirectConnection} directConnection\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.call.remoteEndpoint.fire('message', {\n\t            message: message,\n\t            directConnection: that\n\t        });\n\t        /**\n\t         * A message has been received over the direct connection.\n\t         * @event respoke.DirectConnection#message\n\t         * @type {respoke.Event}\n\t         * @property {object} message\n\t         * @property {respoke.Endpoint} endpoint\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('message', {\n\t            message: message,\n\t            endpoint: that.call.remoteEndpoint\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Detect when the channel is open.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.onDataChannelOpen\n\t     * @private\n\t     * @param {MessageEvent}\n\t     * @fires respoke.DirectConnection#open\n\t     */\n\t    function onDataChannelOpen(evt) {\n\t        //dataChannel = evt.target || evt.channel;\n\t        /**\n\t         * The direct connection is open.\n\t         * @event respoke.DirectConnection#open\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('open');\n\t    }\n\t\n\t    /**\n\t     * Detect when the channel is closed.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.onDataChannelClose\n\t     * @private\n\t     * @param {MessageEvent}\n\t     * @fires respoke.DirectConnection#close\n\t     */\n\t    function onDataChannelClose(evt) {\n\t        //dataChannel = evt.target || evt.channel;\n\t        /**\n\t         * The direct connection is closed.\n\t         * @event respoke.DirectConnection#close\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('close');\n\t    }\n\t\n\t    /**\n\t     * Create the datachannel. For the caller, set up all the handlers we'll need to keep track of the\n\t     * datachannel's state and to receive messages.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.createDataChannel\n\t     * @private\n\t     */\n\t    function createDataChannel() {\n\t        dataChannel = pc.createDataChannel(\"respokeDataChannel\");\n\t        dataChannel.binaryType = 'arraybuffer';\n\t        dataChannel.onerror = onDataChannelError;\n\t        dataChannel.onmessage = onDataChannelMessage;\n\t        dataChannel.onopen = onDataChannelOpen;\n\t\n\t        /**\n\t         * The direct connection setup has begun. This does NOT mean it's ready to send messages yet. Listen to\n\t         * DirectConnection#open for that notification.\n\t         * @event respoke.DirectConnection#start\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('start');\n\t    }\n\t\n\t    /**\n\t     * Start the process of obtaining media. saveParameters will only be meaningful for the callee,\n\t     * since the library calls this method for the caller. Developers will use this method to pass in\n\t     * callbacks for the callee.\n\t     *\n\t     *     directConnection.accept({\n\t     *         onOpen: function (evt) {}\n\t     *     });\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.accept\n\t     * @fires respoke.DirectConnection#accept\n\t     * @param {object} params\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen]\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose]\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage]\n\t     */\n\t    that.accept = function (params) {\n\t        params = params || {};\n\t        log.debug('DirectConnection.accept');\n\t        saveParameters(params);\n\t\n\t        log.debug(\"I am \" + (pc.state.caller ? '' : 'not ') + \"the caller.\");\n\t\n\t        if (pc.state.caller === true) {\n\t            createDataChannel();\n\t        }\n\t        that.call.answer();\n\t\n\t        /**\n\t         * The request to open a direct connection has been accepted.\n\t         * @event respoke.DirectConnection#accept\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('accept');\n\t    };\n\t\n\t    /**\n\t     * Tear down the connection.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.close\n\t     * @fires respoke.DirectConnection#close\n\t     */\n\t    that.close = function (params) {\n\t        params = params || {};\n\t        log.debug(\"DirectConnection.close\");\n\t\n\t        if (that.call && that.call.remoteEndpoint) {\n\t            that.call.remoteEndpoint.directConnection = null;\n\t        }\n\t\n\t        if (dataChannel) {\n\t            dataChannel.close();\n\t        }\n\t\n\t        /**\n\t         * The direct connection has been closed.\n\t         * @event respoke.DirectConnection#close\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.DirectConnection} target\n\t         */\n\t        that.fire('close');\n\t\n\t        that.ignore();\n\t\n\t        if (that.call && params.skipRemove !== true) {\n\t            that.call.removeDirectConnection();\n\t        }\n\t\n\t        dataChannel = null;\n\t        that.call = null;\n\t        pc = null;\n\t    };\n\t\n\t    /**\n\t     * Send a message over the datachannel in the form of a JSON-encoded plain old JavaScript object. Only one\n\t     * attribute may be given: either a string 'message' or an object 'object'.\n\t     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n\t     *\n\t     *     directConnection.sendMessage({\n\t     *         message: \"And they say HTTP is stateless!\"\n\t     *     });\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.sendMessage\n\t     * @param {object} params\n\t     * @param {string} [params.message] - The message to send.\n\t     * @param {object} [params.object] - An object to send.\n\t     * @param {respoke.DirectConnection.sendHandler} [params.onSuccess] - Success handler for this invocation\n\t     * of this method only.\n\t     * @param {respoke.DirectConnection.errorHandler} [params.onError] - Error handler for this invocation\n\t     * of this method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.sendMessage = function (params) {\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t        if (that.isActive()) {\n\t            dataChannel.send(JSON.stringify(params.object || {\n\t                message: params.message\n\t            }));\n\t            deferred.resolve();\n\t        } else {\n\t            deferred.reject(new Error(\"dataChannel not in an open state.\"));\n\t        }\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Expose close as reject for approve/reject workflow.\n\t     *\n\t     *     client.listen('direct-connection, function (evt) {\n\t     *         if (iDontLikeThisPerson()) {\n\t     *             evt.directConnection.reject();\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.reject\n\t     * @param {boolean} signal - Optional flag to indicate whether to send or suppress sending\n\t     * a hangup signal to the remote side.\n\t     */\n\t    that.reject = that.close;\n\t\n\t    /**\n\t     * Indicate whether a datachannel is being setup or is in progress.\n\t     * @memberof! respoke.DirectConnection\n\t     * @method respoke.DirectConnection.isActive\n\t     * @returns {boolean}\n\t     */\n\t    that.isActive = function () {\n\t        // Why does pc.iceConnectionState not transition into 'connected' even though media is flowing?\n\t        //return (pc && pc.isActive() && dataChannel && dataChannel.readyState === 'open');\n\t        return (dataChannel && dataChannel.readyState === 'open');\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.DirectConnection\n\t\n\t/**\n\t * Called when the direct connection is closed.  This callback is called every time respoke.DirectConnection#close\n\t * fires.\n\t * @callback respoke.DirectConnection.onClose\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Called when the setup of the direct connection has begun. The direct connection will not be open yet. This\n\t * callback is called every time respoke.DirectConnection#start fires.\n\t * @callback respoke.DirectConnection.onStart\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Called when the direct connection is opened.  This callback is called every time respoke.DirectConnection#open\n\t * fires.\n\t * @callback respoke.DirectConnection.onOpen\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Called when a message is received over the direct connection.  This callback is called every time\n\t * respoke.DirectConnection#message fires.\n\t * @callback respoke.DirectConnection.onMessage\n\t * @param {respoke.Event} evt\n\t * @param {object} evt.message\n\t * @param {respoke.Endpoint} evt.endpoint\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Handle an error that resulted from a specific method call. This handler will not fire more than once.\n\t * @callback respoke.DirectConnection.errorHandler\n\t * @param {Error} err\n\t */\n\t/**\n\t * When a call is in setup or media renegotiation happens. This callback will be called every time\n\t * respoke.DirectConnection#error.\n\t * @callback respoke.DirectConnection.onError\n\t * @param {respoke.Event} evt\n\t * @param {boolean} evt.reason - A human-readable description of the error.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Called when the callee accepts the direct connection. This callback is called every time\n\t * respoke.DirectConnection#accept is fired.\n\t * @callback respoke.DirectConnection.onAccept\n\t * @param {respoke.Event} evt\n\t * @param {respoke.DirectConnection} evt.target\n\t */\n\t/**\n\t * Handle the successful kick-off of stats on a call.\n\t * @callback respoke.DirectConnection.statsSuccessHandler\n\t * @param {respoke.Event} evt\n\t * @param {object} evt.stats - an object with stats in it.\n\t * @param {respoke.DirectConnection} evt.target\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * Handle sending successfully.\n\t * @callback respoke.DirectConnection.sendHandler\n\t */\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(8);\n\tvar respoke = __webpack_require__(1);\n\tvar log = respoke.log;\n\tvar Statechart = __webpack_require__(19);\n\t\n\t/**\n\t * WebRTC PeerConnection. This class handles all the state and connectivity for Call and DirectConnection.\n\t * This class cannot be used alone, but is instantiated by and must be given media by either Call, DirectConnection,\n\t * or the not-yet-implemented ScreenShare.\n\t * @class respoke.PeerConnection\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId - client id\n\t * @param {boolean} [params.forceTurn] - If true, delete all 'host' and 'srvflx' candidates and send only 'relay'\n\t * candidates.\n\t * @param {boolean} [params.disableTurn] - If true, delete all 'relay' candidates and send only 'host' and 'srvflx'\n\t * candidates.\n\t * @param {respoke.Call} params.call\n\t * @param {string} params.connectionId - The connection ID of the remoteEndpoint.\n\t * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n\t * @param {function} params.signalModify - Signaling action from SignalingChannel.\n\t * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n\t * @param {function} params.signalReport - Signaling action from SignalingChannel.\n\t * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n\t * @param {respoke.Call.onHangup} [params.onHangup] - Callback for the developer to be notified about hangup.\n\t * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for the developer to receive\n\t * statistics about the call. This is only used if call.getStats() is called and the stats module is loaded.\n\t * @param {object} [params.pcOptions]\n\t * @param {object} [params.offerOptions]\n\t * @returns {respoke.PeerConnection}\n\t */\n\t\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.PeerConnection';\n\t\n\t    /**\n\t     * Whether or not we will send a 'hangup' signal to the other side during hangup.\n\t     * @memberof! respoke.PeerConnection\n\t     * @name toSendHangup\n\t     * @type {respoke.Endpoint}\n\t     */\n\t    var toSendHangup;\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @private\n\t     * @name pc\n\t     * @type RTCPeerConnection\n\t     * @desc The RTCPeerConnection as provided by the browser API. All internal state, networking functionality, and\n\t     * raw data transfer occurs within the PeerConnection.\n\t     */\n\t    var pc = null;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name defModify\n\t     * @private\n\t     * @type {Promise}\n\t     * @desc Used in the state machine to trigger methods or functions whose execution depends on the reception,\n\t     * handling, or sending of some information.\n\t     */\n\t    var defModify;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name previewLocalMedia\n\t     * @private\n\t     * @type {respoke.Call.previewLocalMedia}\n\t     * @desc A callback provided by the developer that we'll call after receiving local media and before\n\t     * approve() is called.\n\t     */\n\t    var previewLocalMedia = typeof params.previewLocalMedia === 'function' ? params.previewLocalMedia : undefined;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name candidateReceivingQueue\n\t     * @private\n\t     * @type {array}\n\t     * @desc An array to save candidates between offer and answer so that both parties can process them simultaneously.\n\t     */\n\t    var candidateReceivingQueue = respoke.queueFactory();\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name client\n\t     * @private\n\t     * @type {respoke.Client}\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalOffer\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalOffer = params.signalOffer;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalConnected\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalConnected = params.signalConnected;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalModify\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalModify = params.signalModify;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalAnswer\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalAnswer = params.signalAnswer;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalHangup\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalHangup = respoke.callOnce(params.signalHangup);\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalReport\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed by the signaling channel.\n\t     */\n\t    var signalReport = params.signalReport;\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalCandidateOrig\n\t     * @private\n\t     * @type {function}\n\t     * @desc A temporary function saved from params in order to construct the candidate signaling function.\n\t     */\n\t    var signalCandidateOrig = params.signalCandidate;\n\t\n\t    /**\n\t     * The RTCDTMFSender as provided by the browser API.\n\t     * @memberof! respoke.PeerConnection\n\t     * @private\n\t     * @name digitSender\n\t     * @type RTCDigitSender\n\t     */\n\t\n\t    var digitSender = null;\n\t\n\t    /**\n\t     * A temporary variable to define if we're in the middle of cancelling any tones on a peer connection\n\t     * @memberof! respoke.PeerConnection\n\t     * @private\n\t     * @name cancellingTones\n\t     * @type boolean\n\t     */\n\t\n\t    var cancellingTones = false;\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name signalCandidates\n\t     * @private\n\t     * @type {function}\n\t     * @desc A signaling function constructed from the one passed to us by the signaling channel with additions\n\t     * to facilitate candidate logging.\n\t     */\n\t\n\t    function signalCandidates(params) {\n\t        if (!pc) {\n\t            return Q.resolve();\n\t        }\n\t\n\t        params.call = that.call;\n\t        that.report.candidatesSent = that.report.candidatesSent.concat(params.iceCandidates);\n\t\n\t        return signalCandidateOrig(params);\n\t    }\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name offerOptions\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var offerOptions = params.offerOptions || {};\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name pcOptions\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var pcOptions = params.pcOptions || {\n\t        optional: [\n\t            { DtlsSrtpKeyAgreement: true },\n\t            { RtpDataChannels: false }\n\t        ]\n\t    };\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name report\n\t     * @type {object}\n\t     */\n\t    that.report = {\n\t        callStarted: 0,\n\t        callStopped: 0,\n\t        callerendpoint: that.call.caller ? client.name : that.call.remoteEndpoint.id,\n\t        callerconnection: that.call.caller ? client.id : that.call.connectionId,\n\t        calleeendpoint: that.call.caller ? that.call.remoteEndpoint.id : client.id,\n\t        calleeconnection: that.call.caller ? that.call.connectionId : client.connectionId,\n\t        sessionId: that.call.id,\n\t        lastSDPString: '',\n\t        sdpsSent: [],\n\t        sdpsReceived: [],\n\t        candidatesSent: [],\n\t        candidatesReceived: [],\n\t        userAgent: navigator.userAgent,\n\t        os: navigator.platform\n\t    };\n\t\n\t    /**\n\t     * Start the process of network and media negotiation. Called after local video approved.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.initOffer\n\t     * @fires respoke.PeerConnection#initOffer\n\t     * @private\n\t     */\n\t    function initOffer() {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        if (that.state.receiveOnly) {\n\t            makeOptionsReceiveOnly(offerOptions);\n\t        }\n\t\n\t        if (that.state.sendOnly) {\n\t            makeOptionsSendOnly(offerOptions);\n\t        }\n\t\n\t        log.info('creating offer', offerOptions);\n\t\n\t        pc.createOffer(function saveOfferAndSend(oSession) {\n\t            oSession.type = 'offer';\n\t            if (!pc) {\n\t                return;\n\t            }\n\t            log.debug('setting and sending offer', oSession);\n\t            that.report.sdpsSent.push(oSession);\n\t\n\t            pc.setLocalDescription(oSession, function successHandler(p) {\n\t                oSession.type = 'offer';\n\t                signalOffer({\n\t                    call: that.call,\n\t                    sessionDescription: oSession,\n\t                    onSuccess: function () {\n\t                        that.state.sentSDP = true;\n\t                        localCandidatesFSM.dispatch('ready');\n\t                    },\n\t                    onError: function (err) {\n\t                        log.error('offer could not be sent', err);\n\t                        that.call.hangup({signal: false});\n\t                    }\n\t                });\n\t            }, function errorHandler(p) {\n\t                var errorMessage = 'Error calling setLocalDescription on offer I created.';\n\t                var err = new Error(errorMessage);\n\t                log.error(errorMessage, p);\n\t                /**\n\t                 * This event is fired on errors that occur during call setup or media negotiation.\n\t                 * @event respoke.Call#error\n\t                 * @type {respoke.Event}\n\t                 * @property {string} reason - A human readable description about the error.\n\t                 * @property {respoke.Call} target\n\t                 * @property {string} name - the event name.\n\t                 */\n\t                that.call.fire('error', {\n\t                    message: err.message\n\t                });\n\t            });\n\t        }, function errorHandler(e) {\n\t            log.error('createOffer failed', e);\n\t        }, offerOptions);\n\t    }\n\t\n\t    function makeOptionsReceiveOnly(options) {\n\t        if (navigator.webkitGetUserMedia) {\n\t            options.mandatory = {\n\t                OfferToReceiveVideo: true,\n\t                OfferToReceiveAudio: true,\n\t                OfferToSendVideo: false,\n\t                OfferToSendAudio: false\n\t            };\n\t        } else {\n\t            options.offerToReceiveVideo = true;\n\t            options.offerToReceiveAudio = true;\n\t            options.offerToSendVideo = false;\n\t            options.offerToSendAudio = false;\n\t        }\n\t    }\n\t\n\t    function makeOptionsSendOnly(options) {\n\t        if (navigator.webkitGetUserMedia) {\n\t            options.mandatory = {\n\t                OfferToSendVideo: true,\n\t                OfferToSendAudio: true,\n\t                OfferToReceiveVideo: false,\n\t                OfferToReceiveAudio: false\n\t            };\n\t        } else {\n\t            options.offerToSendVideo = true;\n\t            options.offerToSendAudio = true;\n\t            options.offerToReceiveVideo = false;\n\t            options.offerToReceiveAudio = false;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name localCandidates\n\t     * @private\n\t     * @type {array}\n\t     * @desc An array to save local candidates, to retransmit for peers that\n\t     *       don't support trickle ice.\n\t     */\n\t    var localCandidates = [];\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name localCandidatesComplete\n\t     * @private\n\t     * @type {boolean}\n\t     * @desc Whether all the local candidates have been received.\n\t     */\n\t    var localCandidatesComplete = false;\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name localCandidatesSent\n\t     * @private\n\t     * @type {number}\n\t     * @desc The number of local candidates that have been sent to the remote.\n\t     */\n\t    var localCandidatesSent = 0;\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name localCandidatesSent\n\t     * @private\n\t     * @type {Statechart}\n\t     * @desc FSM for managing local ICE candidates.\n\t     */\n\t    var localCandidatesFSM;\n\t\n\t    /**\n\t     * @memberof! respoke.PeerConnection\n\t     * @name localCandidatesTimeout\n\t     * @private\n\t     * @type {number}\n\t     * @desc timeoutId for the ice gathering timeout. Fires when no ice candidate\n\t     *  received in a specified period of time, to speed up finalCandidates signal.\n\t     */\n\t    var localCandidatesTimeout;\n\t\n\t    /**\n\t     * The number of local candidates that have not yet been sent.\n\t     * @returns {number}\n\t     * @private\n\t     */\n\t    function localCandidatesRemaining() {\n\t        return localCandidates.length - localCandidatesSent;\n\t    }\n\t\n\t    /**\n\t     * Throw another local ICE candidate on the pile\n\t     * @param params\n\t     * @param params.candidate ICE candidate\n\t     * @private\n\t     */\n\t    function collectLocalIceCandidate(params) {\n\t        if (params && params.candidate) {\n\t            localCandidates.push(params.candidate);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Send the remaining local candidates that have not yet been sent.\n\t     * @private\n\t     */\n\t    function sendRemainingCandidates(params) {\n\t        var remainingCandidates = localCandidates.slice(localCandidatesSent);\n\t        var signalParams = {iceCandidates: remainingCandidates};\n\t\n\t        localCandidatesSent += remainingCandidates.length;\n\t\n\t        if (localCandidatesComplete && !(params && params.suppressFinalCandidates)) {\n\t            signalParams.finalCandidates = localCandidates;\n\t        }\n\t\n\t        if (!signalParams.iceCandidates.length && !signalParams.finalCandidates) {\n\t            // Nothing to send. Happens if we receive the null \"end of ice\" ice candidate\n\t            // after we've already sent the finalCandidates signal.\n\t            return;\n\t        }\n\t\n\t        signalCandidates(signalParams)\n\t            .finally(function () {\n\t                localCandidatesFSM.dispatch('iceSent');\n\t            }).done();\n\t    }\n\t\n\t    localCandidatesFSM = respoke.Class({\n\t        that: Object.create(Statechart),\n\t        initialState: 'buffering',\n\t        states: {\n\t            buffering: {\n\t                localIceCandidate: {action: collectLocalIceCandidate},\n\t                ready: [{\n\t                    guard: function () {\n\t                        return localCandidatesRemaining() === 0 && localCandidatesComplete;\n\t                    },\n\t                    target: 'finished',\n\t                    action: function () {\n\t                        log.error('ice completed without any candidates');\n\t                    }\n\t                }, {\n\t                    guard: function () {\n\t                        return localCandidatesRemaining() === 0 && !localCandidatesComplete;\n\t                    },\n\t                    target: 'waiting'\n\t                }, {\n\t                    guard: function () {\n\t                        return localCandidatesRemaining() !== 0;\n\t                    },\n\t                    target: 'sending',\n\t                    action: sendRemainingCandidates\n\t                }]\n\t            },\n\t            sending: {\n\t                localIceCandidate: {action: collectLocalIceCandidate},\n\t                iceSent: [{\n\t                    guard: function () {\n\t                        return localCandidatesRemaining() === 0 && localCandidatesComplete;\n\t                    },\n\t                    target: 'finished'\n\t                }, {\n\t                    guard: function () {\n\t                        return localCandidatesRemaining() === 0 && !localCandidatesComplete;\n\t                    },\n\t                    target: 'waiting'\n\t                }, {\n\t                    guard: function () {\n\t                        return localCandidatesRemaining() !== 0;\n\t                    },\n\t                    action: sendRemainingCandidates\n\t                }]\n\t            },\n\t            waiting: {\n\t                entry: {\n\t                    action: function () {\n\t                        localCandidatesTimeout = setTimeout(function () {\n\t                            log.debug('ice gathering has timed out. sending final candidate signal.');\n\t                            localCandidatesComplete = true;\n\t                            localCandidatesFSM.dispatch('localIceCandidate');\n\t                        }, 2000);\n\t                    }\n\t                },\n\t                exit: {\n\t                    action: function () {\n\t                        clearTimeout(localCandidatesTimeout);\n\t                    }\n\t                },\n\t                localIceCandidate: {\n\t                    action: function (params) {\n\t                        collectLocalIceCandidate(params);\n\t                        sendRemainingCandidates();\n\t                    },\n\t                    target: 'sending'\n\t                }\n\t            },\n\t            finished: {\n\t                localIceCandidate: {\n\t                    // helps trickleIce-compatible clients\n\t                    action: function (params) {\n\t                        collectLocalIceCandidate(params);\n\t                        sendRemainingCandidates({ suppressFinalCandidates: true });\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    });\n\t\n\t    localCandidatesFSM.run();\n\t\n\t    /**\n\t     * Process a remote offer if we are not the caller. This is necessary because we don't process the offer until\n\t     * the callee has answered the call.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.processOffer\n\t     * @param {RTCSessionDescriptor}\n\t     * @returns {Promise}\n\t     */\n\t    that.processOffer = function (oOffer) {\n\t\n\t        function onSetRemoteDescriptionSuccess() {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            log.debug('set remote desc of offer succeeded');\n\t\n\t            processReceivingQueue();\n\t\n\t            pc.createAnswer(function saveAnswerAndSend(oSession) {\n\t                if (!pc) {\n\t                    return;\n\t                }\n\t\n\t                that.state.processedRemoteSDP = true;\n\t\n\t                if (!that.state.caller) {\n\t                    that.report.callerconnection = that.call.connectionId;\n\t                }\n\t\n\t                oSession.type = 'answer';\n\t                log.debug('setting and sending answer', oSession);\n\t                that.report.sdpsSent.push(oSession);\n\t\n\t                pc.setLocalDescription(oSession, function successHandler(p) {\n\t                    oSession.type = 'answer';\n\t                    signalAnswer({\n\t                        sessionDescription: oSession,\n\t                        call: that.call,\n\t                        onSuccess: function () {\n\t                            localCandidatesFSM.dispatch('ready');\n\t                        }\n\t                    });\n\t                    that.state.sentSDP = true;\n\t                }, function errorHandler(p) {\n\t                    var errorMessage = 'Error calling setLocalDescription on answer I created.';\n\t                    var err = new Error(errorMessage);\n\t                    log.error(errorMessage, p);\n\t                    /**\n\t                     * This event is fired on errors that occur during call setup or media negotiation.\n\t                     * @event respoke.Call#error\n\t                     * @type {respoke.Event}\n\t                     * @property {string} reason - A human readable description about the error.\n\t                     * @property {respoke.Call} target\n\t                     * @property {string} name - the event name.\n\t                     */\n\t                    that.call.fire('error', {\n\t                        message: err.message\n\t                    });\n\t                });\n\t            }, function errorHandler(err) {\n\t                log.error('create answer failed', err);\n\t\n\t                err = new Error(\"Error creating SDP answer. \" + err);\n\t                that.report.callStoppedReason = err.message;\n\t\n\t                /**\n\t                 * This event is fired on errors that occur during call setup or media negotiation.\n\t                 * @event respoke.Call#error\n\t                 * @type {respoke.Event}\n\t                 * @property {string} reason - A human readable description about the error.\n\t                 * @property {respoke.Call} target\n\t                 * @property {string} name - the event name.\n\t                 */\n\t                that.call.fire('error', {\n\t                    message: err.message\n\t                });\n\t                that.report.callStoppedReason = 'setRemoteDescription failed at answer.';\n\t                that.close();\n\t            });\n\t        }\n\t\n\t        function onSetRemoteDescriptionInitialError(err) {\n\t            log.debug('Error calling setRemoteDescription on offer I received.', err);\n\t\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            /*\n\t             * Attempt to remove the dtls transport protocol from the offer sdp. This has been observed\n\t             * to cause setRemoteDescription failures when Chrome 46+ is placing calls to Chrome <= 41.\n\t             * This is a particularly acute issue when using nw.js 0.12.x or lower.\n\t             */\n\t            var alteredSdp = oOffer.sdp.replace(/UDP\\/TLS\\/RTP\\/SAVPF/g, 'RTP/SAVPF');\n\t            if (oOffer.sdp !== alteredSdp) {\n\t                oOffer.sdp = alteredSdp;\n\t                log.debug('Retrying setRemoteDescription with legacy transport in offer sdp', oOffer);\n\t                pc.setRemoteDescription(new RTCSessionDescription(oOffer),\n\t                    onSetRemoteDescriptionSuccess, onSetRemoteDescriptionFinalError);\n\t                return;\n\t            }\n\t\n\t            onSetRemoteDescriptionFinalError(err);\n\t        }\n\t\n\t        function onSetRemoteDescriptionFinalError(p) {\n\t            var errorMessage = 'Error calling setRemoteDescription on offer I received.';\n\t            var err = new Error(errorMessage);\n\t            log.error(errorMessage, p);\n\t            that.report.callStoppedReason = err.message;\n\t\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.call.fire('error', {\n\t                message: err.message\n\t            });\n\t        }\n\t\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        log.debug('processOffer', oOffer);\n\t\n\t        that.report.sdpsReceived.push(oOffer);\n\t        that.report.lastSDPString = oOffer.sdp;\n\t\n\t        //set flags for audio / video being offered\n\t        that.call.hasDataChannel = respoke.sdpHasDataChannel(oOffer.sdp);\n\t\n\t        try {\n\t            pc.setRemoteDescription(new RTCSessionDescription(oOffer),\n\t                onSetRemoteDescriptionSuccess, onSetRemoteDescriptionInitialError);\n\t        } catch (err) {\n\t            var newErr = new Error(\"Exception calling setRemoteDescription on offer I received.\" + err.message);\n\t            that.report.callStoppedReason = newErr.message;\n\t\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.call.fire('error', {\n\t                message: newErr.message\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Return media stats. Since we have to wait for both the answer and offer to be available before starting\n\t     * statistics, we'll return a promise for the stats object.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.getStats\n\t     * @returns {Promise<{respoke.MediaStatsParser}>|undefined}\n\t     * @param {object} params\n\t     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onSuccess] - Success handler for this\n\t     * invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @fires respoke.PeerConnection#stats\n\t     */\n\t    function getStats(params) {\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        if (!respoke.MediaStats) {\n\t            deferred.reject(new Error(\"Statistics module is not loaded.\"));\n\t            return retVal;\n\t        }\n\t\n\t        function onConnect() {\n\t            var stats = respoke.MediaStatsParser({\n\t                peerConnection: pc,\n\t                interval: params.interval,\n\t                onStats: function statsHandler(stats) {\n\t                    if (!pc) {\n\t                        return;\n\t                    }\n\t\n\t                    /**\n\t                     * This event is fired every 5 seconds by default, configurable by the 'interval' property to\n\t                     * `call.startStats` and reports the current state of media statistics.\n\t                     * @event respoke.PeerConnection#stats\n\t                     * @type {respoke.Event}\n\t                     * @property {object} stats - an object with stats in it.\n\t                     * @property {string} name - the event name.\n\t                     * @property {respoke.PeerConnection}\n\t                     */\n\t                    that.fire('stats', {\n\t                        stats: stats\n\t                    });\n\t                }\n\t            });\n\t            that.listen('close', function closeHandler(evt) {\n\t\n\t                stats.stopStats();\n\t            }, true);\n\t            deferred.resolve();\n\t        }\n\t\n\t        if (!pc) {\n\t            that.once('stream-received', onConnect);\n\t        } else {\n\t            onConnect();\n\t        }\n\t\n\t        return retVal;\n\t    }\n\t\n\t    if (respoke.MediaStats) {\n\t        that.getStats = getStats;\n\t    }\n\t\n\t    /**\n\t     * Create the RTCPeerConnection and add handlers. Process any offer we have already received.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.init\n\t     */\n\t    that.init = function init() {\n\t        log.debug('PC.init');\n\t\n\t        if (pc) {\n\t            return;\n\t        }\n\t\n\t        that.report.callStarted = new Date().getTime();\n\t\n\t        pc = new RTCPeerConnection(that.servers, pcOptions);\n\t\n\t        /**\n\t         * Process a local ICE Candidate\n\t         *\n\t         * @param {RTCIceCandidate} oCan\n\t         */\n\t        pc.onicecandidate = function onIceCandidate(oCan) {\n\t                var candidate = oCan.candidate; // {candidate: ..., sdpMLineIndex: ... }\n\t                if (!pc) {\n\t                    return;\n\t                }\n\t\n\t                // From http://www.w3.org/TR/webrtc/#operation\n\t                // If the intent of the ICE Agent is to notify the script that:\n\t                //  [snip]\n\t                //  * The gathering process is done.\n\t                //    Set connection's ice gathering state to completed and let newCandidate be null.\n\t                if (!candidate || !candidate.candidate) {\n\t                    if (pc.iceGatheringState === 'complete') {\n\t                        localCandidatesComplete = true;\n\t                        localCandidatesFSM.dispatch('localIceCandidate');\n\t                    }\n\t                    return;\n\t                }\n\t\n\t                if (that.forceTurn === true && candidate.candidate.indexOf(\"typ relay\") === -1) {\n\t                    log.debug(\"Dropping candidate because forceTurn is on.\");\n\t                    return;\n\t                } else if (that.disableTurn === true && candidate.candidate.indexOf(\"typ relay\") !== -1) {\n\t                    log.debug(\"Dropping candidate because disableTurn is on.\");\n\t                    return;\n\t                }\n\t\n\t                localCandidatesFSM.dispatch('localIceCandidate', {candidate: candidate});\n\t            }\n\t        ;\n\t\n\t        /**\n\t         * Handle ICE state change\n\t         */\n\t        pc.oniceconnectionstatechange = function onIceConnectionStateChange(/* evt */) {\n\t                if (!pc) {\n\t                    return;\n\t                }\n\t\n\t                if (pc.iceConnectionState === 'connected') {\n\t                    /**\n\t                     * Indicate that we've successfully connected to the remote side. This is only helpful for the\n\t                     * outgoing connection.\n\t                     * @event respoke.PeerConnection#connect\n\t                     * @type {respoke.Event}\n\t                     * @property {string} name - the event name.\n\t                     * @property {respoke.PeerConnection}\n\t                     */\n\t                    that.fire('connect');\n\t                }\n\t            }\n\t        ;\n\t\n\t        pc.onaddstream = function onaddstream(evt) {\n\t            /**\n\t             * Indicate the RTCPeerConnection has received remote media.\n\t             * @event respoke.PeerConnection#stream-added\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('stream-added', {\n\t                stream: evt.stream\n\t            });\n\t        };\n\t\n\t        pc.onremovestream = function onremovestream(evt) {\n\t            /**\n\t             * Indicate the remote side has stopped sending media.\n\t             * @event respoke.PeerConnection#stream-removed\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('stream-removed', {\n\t                stream: evt.stream\n\t            });\n\t        };\n\t\n\t        pc.ondatachannel = function ondatachannel(evt) {\n\t            /**\n\t             * CAUTION: This event is only called for the callee because RTCPeerConnection#ondatachannel\n\t             * is only called for the callee.\n\t             * @event respoke.PeerConnection#direct-connection\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('direct-connection', {\n\t                channel: evt.channel\n\t            });\n\t        };\n\t\n\t        that.state.listen('offering:entry', function (evt) {\n\t            if (that.state.caller) {\n\t                initOffer();\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Return an array of remote media streams.\n\t     * @muremberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.getRemoteStreams\n\t     */\n\t    that.getRemoteStreams = function () {\n\t        if (!pc) {\n\t            return [];\n\t        }\n\t        return pc.getRemoteStreams.apply(pc, Array.prototype.slice.call(arguments));\n\t    };\n\t\n\t    /**\n\t     * Return an array of local media streams.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.getLocalStreams\n\t     */\n\t    that.getLocalStreams = function () {\n\t        if (!pc) {\n\t            return [];\n\t        }\n\t        return pc.getLocalStreams.apply(pc, Array.prototype.slice.call(arguments));\n\t    };\n\t\n\t    /**\n\t     * Create a data channel.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.createDataChannel\n\t     */\n\t    that.createDataChannel = function () {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        return pc.createDataChannel.apply(pc, Array.prototype.slice.call(arguments));\n\t    };\n\t\n\t    /**\n\t     * Add any tracks from the provided stream to the peer connection.\n\t     *\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.addLocalTracksFromStream\n\t     */\n\t    that.addLocalTracksFromStream = function (stream) {\n\t        if (!pc) {\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.call.fire('error', {\n\t                message: \"Got local stream in a precall state.\"\n\t            });\n\t            return;\n\t        }\n\t\n\t        if (webrtcDetectedBrowser === 'firefox') {\n\t            stream.getTracks().forEach(function (track) {\n\t                pc.addTrack(track, stream);\n\t            });\n\t        } else {\n\t            pc.addStream(stream);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Remove and stop any local streams that are already added to the peer connection.\n\t     * This releases the resources used by those streams when renegotiating media.\n\t     *\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.removeLocalTracks\n\t     */\n\t    that.removeLocalTracks = function () {\n\t        if (webrtcDetectedBrowser === 'firefox') {\n\t            pc.getLocalStreams().forEach(function (stream) {\n\t                stream.getTracks().forEach(function (track) {\n\t                    track.stop();\n\t                });\n\t            });\n\t            pc.getSenders().forEach(function (sender) {\n\t                pc.removeTrack(sender);\n\t            });\n\t        } else {\n\t            pc.getLocalStreams().forEach(function (stream) {\n\t                stream.getTracks().forEach(function (track) {\n\t                    track.stop();\n\t                });\n\t                pc.removeStream(stream);\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Process any ICE candidates that we received from the other side while we were waiting on the other\n\t     * party's SDP to arrive and be processed.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.processReceivingQueue\n\t     * @private\n\t     */\n\t    function processReceivingQueue() {\n\t        candidateReceivingQueue.trigger(function processIce(can) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            pc.addIceCandidate(new RTCIceCandidate(can.candidate), function onSuccess() {\n\t                log.debug((that.state.caller ? 'caller' : 'callee'), 'got a remote candidate.', can.candidate);\n\t                that.report.candidatesReceived.push(can.candidate);\n\t            }, function onError(e) {\n\t                log.error(\"Couldn't add ICE candidate\", e, can.candidate);\n\t            });\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Send DTMF tones to the first audio track on the call. This allows interaction with a phone system expecting keys\n\t     * to be pressed on a normal phone, such as when calling a company for customer support and having to \"Press 1 for English\".\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.sendTones\n\t     * @param {object} params\n\t     * @param {string} params.tones - The tones to send. Can be any combination of the characters '0123456789ABCD#*', or\n\t     *  a ',' (comma) to insert a 2 second pause before sending the next tone.\n\t     * @param {number} [params.duration] - Optional number in milliseconds to indicate how long to play each tone. This\n\t     *  value needs to be between 40 and 6000. Defaults to 100.\n\t     * @param {number} [params.gap] - Optional number in mlliseconds to indicate the gap between playing the tones.\n\t     *  This value needs to be larger than 30. Defaults to 70.\n\t     * @param {respoke.Call.onSuccess} [params.onSuccess] - Callback called when all requested DTMF tones have been played.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback called when an error occurs while playing back the DTMF\n\t     *  tones, or when the request has been cancelled.\n\t     * @fires respoke.PeerConnection#tone-sent\n\t     * @fires respoke.PeerConnection#tone-sending-complete\n\t     * @returns {Promise|null} Returns a promise if no onSuccess nor onError callbacks are specified. Otherwise, returns null.\n\t     */\n\t    that.sendTones = function (params) {\n\t        var deferred = Q.defer();\n\t\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t\n\t        params = typeof params === 'object' ? params : {};\n\t\n\t        params.duration = params.duration || 100;\n\t        params.gap = params.gap || 50;//chrome says minimum is 50 not 30 like the spec\n\t\n\t        var err;\n\t\n\t        if (!pc) {\n\t            err = new Error('No Peer Connection available');\n\t        }\n\t        if (!params.tones) {\n\t            err = new Error('Unable to send tones as none passed in');\n\t        }\n\t\n\t        if (params.duration > 6000 || params.duration < 40) {\n\t            err = new Error('Unable to send tones as duration needs to be between 40 and 6000 milliseconds');\n\t        }\n\t\n\t        if (params.gap < 50 ) {\n\t            err = new Error('Unable to send tones as gap needs to be greater than 50 milliseconds');\n\t        }\n\t\n\t        if (params.tones && !params.tones.match(/^([A-D0-9,#*])+$/ig)) {\n\t            err = new Error('Unable to send tones as tones passed in were not in correct format');\n\t        }\n\t\n\t        if (pc && !pc.createDTMFSender) {\n\t            err = new Error('Unable to send tones in this browser');\n\t        }\n\t\n\t        if (err) {\n\t            log.warn(err);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        if (digitSender) {\n\t            err = new Error('Unable to queue tones on audio track as a digitSender already exists');\n\t            log.warn(err);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        var audioTracks = that.call.outgoingMedia.getAudioTracks();\n\t        if (!audioTracks || audioTracks.length < 1) {\n\t            err = new Error('Could not send tones \"' + params.tones + '\". No audio track available.');\n\t            log.warn(err);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        digitSender = pc.createDTMFSender(audioTracks[0]);\n\t\n\t        digitSender.ontonechange = function onToneChange(evt) {\n\t            if (evt.tone !== '') {\n\t                /**\n\t                 * Indicate the RTCPeerConnection has sent a tone.\n\t                 * @event respoke.PeerConnection#tone-sent\n\t                 * @type {respoke.Event}\n\t                 * @property {string} evt.tone\n\t                 * @property {number} evt.duration\n\t                 * @property {number} evt.gap\n\t                 */\n\t                that.call.fire('tone-sent', {\n\t                    tone: evt.tone,\n\t                    duration: digitSender.duration,\n\t                    gap: digitSender.interToneGap\n\t                });\n\t                return;\n\t            }\n\t\n\t            /*\n\t             * The tone string is empty, which is how the DTMFSender represents the end\n\t             * of the tone queue. Cleanup our handlers, wrap up the promises, and fire\n\t             * the appropriate events.\n\t             */\n\t            digitSender = null;\n\t\n\t            if (cancellingTones) {\n\t                cancellingTones = false;\n\t                deferred.reject(new Error('Tone playback cancelled'));\n\t                return;\n\t            }\n\t\n\t            /**\n\t             * Indicate the RTCPeerConnection has finished sending tones, unless they were cancelled.\n\t             * @event respoke.PeerConnection#tone-sending-complete\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             */\n\t            deferred.resolve();\n\t            that.call.fire('tone-sending-complete');\n\t        };\n\t\n\t        if (!digitSender.canInsertDTMF) {\n\t            err = new Error('Unable to insert tones into audio track');\n\t            log.warn(err);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        try {\n\t            digitSender.insertDTMF(params.tones, params.duration, params.gap);\n\t        } catch (e) {\n\t            err = new Error('Unable to queue tones on audio track due to an error');\n\t            log.warn(err, params, e);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t        log.debug('successfully queued playback of tones', {\n\t            tones: digitSender.toneBuffer,\n\t            duration: digitSender.duration,\n\t            gap: digitSender.interToneGap\n\t        });\n\t\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Cancel any tones currently being sent via sendTones.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.cancelTones\n\t     * @param {object} params\n\t     * @param {function} [params.onSuccess] - Success handler for this invocation of this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this method only.\n\t     * @fires respoke.PeerConnection#tone-sending-cancelled\n\t     * @returns {Promise|null} Returns a promise if no onSuccess nor onError callbacks are specified. Otherwise, returns null.\n\t     */\n\t    that.cancelTones = function (params) {\n\t        var deferred = Q.defer();\n\t        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t        var err;\n\t\n\t        if (!pc) {\n\t            err = new Error('No Peer Connection available');\n\t            log.warn(err);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        if (!digitSender) {\n\t            err = new Error('Unable to queue tones on audio track as a digitSender does not exist');\n\t            log.warn(err);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        if (!digitSender.canInsertDTMF) {\n\t            err = new Error('Unable to cancel playback of tones as cannot change tones on audio track');\n\t            log.warn(err);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        cancellingTones = true;\n\t        var tonesToCancel = digitSender.toneBuffer;\n\t\n\t        try {\n\t            digitSender.insertDTMF('');\n\t        } catch (e) {\n\t            err = new Error('Unable to cancel playback of tones');\n\t            log.warn(err, e);\n\t            deferred.reject(err);\n\t            return retVal;\n\t        }\n\t\n\t        /**\n\t         * Indicate the RTCPeerConnection has finished cancelling tones.\n\t         * @event respoke.PeerConnection#tone-sending-cancelled\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         */\n\t        deferred.resolve();\n\t        that.call.fire('tone-sending-cancelled', {\n\t            cancelledTones: tonesToCancel\n\t        });\n\t\n\t        return retVal;\n\t    };\n\t\n\t    /**\n\t     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n\t     * signal is not false and we have not received a hangup signal from the remote party.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.close\n\t     * @param {object} params\n\t     * @param {boolean} [params.signal] - Optional flag to indicate whether to send or suppress sending\n\t     *  a hangup signal to the remote side. This is set to false by the library if we're responding to a\n\t     *  hangup signal.\n\t     * @fires respoke.PeerConnection#close\n\t     */\n\t    that.close = function (params) {\n\t        params = params || {};\n\t        toSendHangup = true;\n\t\n\t        if (that.state.caller === true) {\n\t            if (!that.state.sentSDP) {\n\t                // Never send hangup if we are the caller but we haven't sent any other signal yet.\n\t                toSendHangup = false;\n\t            }\n\t        }\n\t\n\t        toSendHangup = (typeof params.signal === 'boolean' ? params.signal : toSendHangup);\n\t        if (toSendHangup) {\n\t            log.info('sending hangup');\n\t            signalHangup({\n\t                call: that.call\n\t            });\n\t        }\n\t\n\t        that.report.callStopped = new Date().getTime();\n\t\n\t        /**\n\t         * Indicate that the RTCPeerConnection is closed.\n\t         * @event respoke.PeerConnection#close\n\t         * @type {respoke.Event}\n\t         * @property {boolean} sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.PeerConnection}\n\t         */\n\t        that.fire('close', {\n\t            sentSignal: toSendHangup\n\t        });\n\t        that.ignore();\n\t\n\t        if (pc && that.report) {\n\t            pc.close();\n\t        }\n\t        pc = null;\n\t\n\t        if (that.call.enableCallDebugReport) {\n\t            signalReport({\n\t                report: that.report\n\t            });\n\t        }\n\t        that.report = null;\n\t    };\n\t    that.close = respoke.callOnce(that.close);\n\t\n\t    /**\n\t     * Indicate whether a call is being setup or is in progress.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.isActive\n\t     * @returns {boolean}\n\t     */\n\t    that.isActive = function () {\n\t        return !!(pc && ['completed', 'connected', 'new', 'checking'].indexOf(pc.iceConnectionState) > -1);\n\t    };\n\t\n\t    /**\n\t     * Send the initiate signal to start the modify process. This method is only called by the caller of the\n\t     * renegotiation.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.startModify\n\t     * @param {object} params\n\t     * @param {object} [params.constraints] - Indicate this is a request for media and what type of media.\n\t     * @param {boolean} [params.directConnection] - Indicate this is a request for a direct connection.\n\t     */\n\t    that.startModify = function (params) {\n\t        defModify = Q.defer();\n\t        signalModify({\n\t            action: 'initiate',\n\t            call: that.call,\n\t            constraints: params.constraints,\n\t            directConnection: params.directConnection\n\t        });\n\t        that.state.dispatch('modify');\n\t    };\n\t\n\t    /**\n\t     * Save the candidate. If we initiated the call, place the candidate into the queue so\n\t     * we can process them after we receive the answer.\n\t     * @memberof! respoke.PeerConnection\n\t     * @method respoke.PeerConnection.addRemoteCandidate\n\t     * @param {object} params\n\t     * @param {RTCIceCandidate} params.candidate\n\t     */\n\t    that.addRemoteCandidate = function (params) {\n\t        if (!pc && (that.state.sentSDP || that.state.receivedSDP)) { // we hung up.\n\t            return;\n\t        }\n\t\n\t        if (!params || !params.candidate || !params.candidate.hasOwnProperty('sdpMLineIndex')) {\n\t            log.warn(\"addRemoteCandidate got wrong format!\", params);\n\t            return;\n\t        }\n\t\n\t        candidateReceivingQueue.push(params);\n\t    };\n\t\n\t    /**\n\t     * Save the answer and tell the browser about it.\n\t     */\n\t    that.call.listen('signal-answer', function handleAnswerSignal(evt) {\n\t        log.debug('PC handleAnswerSignal', evt);\n\t\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        log.debug('got answer', evt.signal);\n\t\n\t        that.report.sdpsReceived.push(evt.signal.sessionDescription);\n\t        that.state.sendOnly = respoke.sdpHasReceiveOnly(evt.signal.sessionDescription.sdp);\n\t        that.report.lastSDPString = evt.signal.sessionDescription.sdp;\n\t\n\t        if (that.state.caller) {\n\t            that.report.calleeconnection = evt.signal.fromConnection;\n\t        }\n\t\n\t        that.call.connectionId = evt.signal.fromConnection;\n\t        // TODO don't signal connected more than once.\n\t        signalConnected({\n\t            call: that.call\n\t        });\n\t\n\t        pc.setRemoteDescription(\n\t            new RTCSessionDescription(evt.signal.sessionDescription),\n\t            function successHandler() {\n\t                processReceivingQueue();\n\t                that.state.dispatch('receiveAnswer');\n\t            }, function errorHandler(p) {\n\t                var errorMessage = 'Exception calling setRemoteDescription on answer I received.';\n\t                var newErr = new Error(errorMessage);\n\t                log.error(errorMessage, p);\n\t                that.report.callStoppedReason = newErr.message;\n\t                /**\n\t                 * This event is fired on errors that occur during call setup or media negotiation.\n\t                 * @event respoke.Call#error\n\t                 * @type {respoke.Event}\n\t                 * @property {string} reason - A human readable description about the error.\n\t                 * @property {respoke.Call} target\n\t                 * @property {string} name - the event name.\n\t                 */\n\t                that.call.fire('error', {\n\t                    message: newErr.message\n\t                });\n\t                log.error('set remote desc of answer failed', evt.signal.sessionDescription, p);\n\t                that.report.callStoppedReason = 'setRemoteDescription failed at answer.';\n\t                that.close();\n\t            }\n\t        );\n\t    }, true);\n\t\n\t    /**\n\t     * Figure out who won the call. This necessary to prevent two connections of\n\t     * the same endpoint from thinking they are both on the same call.\n\t     */\n\t    that.call.listen('signal-connected', function handleConnectedSignal(evt) {\n\t        log.debug('PC handleConnectedSignal', evt);\n\t\n\t        if (evt.signal.connectionId !== client.connectionId) {\n\t            log.debug(\"Hanging up because I didn't win the call.\", evt.signal, client);\n\t            that.call.hangup({signal: false});\n\t        }\n\t    }, true);\n\t\n\t    /**\n\t     * Indicate a desire from the other side to renegotiate media.\n\t     */\n\t    that.call.listen('signal-modify', function handleModifySignal(evt) {\n\t        var err;\n\t        log.debug('PC handleModifySignal', evt);\n\t\n\t        if (evt.signal.action === 'accept') {\n\t            if (defModify.promise.isPending()) {\n\t                defModify.resolve();\n\t                /**\n\t                 * Indicate that the remote party has accepted our invitation to begin renegotiating media.\n\t                 * @event respoke.PeerConnection#modify-accept\n\t                 * @type {respoke.Event}\n\t                 * @property {string} name - the event name.\n\t                 * @property {respoke.PeerConnection}\n\t                 */\n\t\n\t                // reset the ice candidate queue for the renegotiation\n\t                candidateReceivingQueue = respoke.queueFactory();\n\t\n\t                // let the world know we're ready to re-negotiate\n\t                that.fire('modify-accept', {signal: evt.signal});\n\t            }\n\t            return;\n\t        } else if (evt.signal.action === 'reject') {\n\t            if (defModify.promise.isPending()) {\n\t                err = new Error(\"Remote party cannot negotiate.\");\n\t                log.debug(err.message);\n\t                defModify.reject(err);\n\t                /**\n\t                 * Indicate that the remote party has rejected our invitation to begin renegotiating media.\n\t                 * @event respoke.PeerConnection#modify-reject\n\t                 * @type {respoke.Event}\n\t                 * @property {Error} err\n\t                 * @property {string} name - the event name.\n\t                 * @property {respoke.PeerConnection}\n\t                 */\n\t                that.fire('modify-reject', {err: err});\n\t            }\n\t            return;\n\t        }\n\t\n\t        // This code only gets executed if signal.action === 'initiate'\n\t        if (defModify && defModify.promise.isPending()) {\n\t            // TODO compare signal request ID and accept if we have the higher request ID,\n\t            // reject if we have the lower request ID.\n\t            err = new Error(\"Got modify in a negotiating state.\");\n\t            log.debug(err.message);\n\t            defModify.reject(err);\n\t            /**\n\t             * Indicate that the remote party has rejected our invitation to begin renegotiating media.\n\t             * @event respoke.PeerConnection#modify-reject\n\t             * @type {respoke.Event}\n\t             * @property {Error} err\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('modify-reject', {err: err});\n\t            signalModify({\n\t                action: 'reject',\n\t                call: that.call\n\t            });\n\t            return;\n\t        }\n\t\n\t        defModify = Q.defer();\n\t\n\t        if (!that.state.sentSDP || that.state.isState('idle')) {\n\t            err = new Error(\"Got modify in a precall state.\");\n\t            /**\n\t             * Indicate that the remote party has rejected our invitation to begin renegotiating media.\n\t             * @event respoke.PeerConnection#modify-reject\n\t             * @type {respoke.Event}\n\t             * @property {Error} err\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.PeerConnection}\n\t             */\n\t            that.fire('modify-reject', {err: err});\n\t            signalModify({\n\t                action: 'reject',\n\t                call: that.call\n\t            });\n\t            defModify.reject(err);\n\t            return;\n\t        }\n\t\n\t        /*\n\t         * Received an 'initiate' and we are in the correct state to receive it,\n\t         * so send the accept and prepare to receive an offer from the remote endpoint.\n\t         */\n\t\n\t        // reset ice candidate queueing\n\t        candidateReceivingQueue = respoke.queueFactory();\n\t\n\t        // accept the modify to allow re-negotiating media\n\t        signalModify({\n\t            action: 'accept',\n\t            call: that.call\n\t        });\n\t        defModify.resolve();\n\t    }, true);\n\t\n\t    return that;\n\t}; // End respoke.PeerConnection\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright (c) 2010 David Durman\n\t//\n\t// The contents of this file are subject to the MIT License (the \"License\");\n\t// you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\t// http://opensource.org/licenses/MIT.\n\t//\n\t// This hierarchical state machine implementation has been inspired\n\t// by the QP active object framework, see http://www.state-machine.com/\n\t\n\t\n\t(function(root, factory){\n\t    \"use strict\";\n\t\n\t    if (true) {\n\t\n\t        // Node. Does not work with strict CommonJS, but\n\t        // only CommonJS-like enviroments that support module.exports,\n\t        // like Node.\n\t        module.exports = factory();\n\t\n\t    } else if (typeof define === 'function' && define.amd) {\n\t\n\t        // AMD. Register as an anonymous module.\n\t        define(factory);\n\t\n\t    } else {\n\t\n\t        // Browser globals (root is window)\n\t        root.Statechart = factory();\n\t    }\n\t\n\t}(this, function(){\n\t\n\t    \"use strict\";\n\t\n\t    var assert = function(assertion){\n\t        if (!assertion) {\n\t            throw new Error(\"Assertion failed.\");\n\t        }\n\t    };\n\t\n\t\n\t    // Statechart.\n\t    // -----------\n\t\n\t    // `myState` - the current state\n\t    // `mySource` - the source of the current transition\n\t\n\t    var Statechart = {\n\t\n\t        run: function(opt){\n\t            opt = opt || {};\n\t            this.debug = opt.debug ? opt.debug : function(){};\n\t            this.construct(this.initialState);\n\t            this.init(null);\n\t        },\n\t\n\t        construct: function(initialState){\n\t            this.myState = this.top();\n\t            this.mySource = this.state(\"Initial\");\n\t\n\t            // Initial pseudo-state\n\t            this.states.Initial = {\n\t                empty: function(){\n\t                    this.newInitialState(initialState);\n\t                }\n\t            };\n\t            var handled = function(){ return null; };\n\t\n\t            // TOP state\n\t            this.states.TOP = {\n\t                entry: handled,\n\t                exit:  handled,\n\t                init:  handled,\n\t                empty: handled\n\t            };\n\t            this.flatten();\n\t        },\n\t\n\t        // Trigger the initial transition and recursively enter the submachine of the top state.\n\t        // Must be called only once for a given Statechart before dispatching any events to it.\n\t        init: function(anEventOrNull){\n\t            assert(this.myState === this.top() && this.mySource !== null);\n\t            var s = this.myState;    // save top in temp\n\t            this.mySource.trigger(anEventOrNull);    // topmost initial transition\n\t            assert(s.equals(this.myState.superstate()));    // verify that we only went one level deep\n\t            s = this.myState;\n\t            s.enter();\n\t            while (s.init() === null) {    // while init is handled (i.e. till we reach a leaf node)\n\t                assert(s.equals(this.myState.superstate()));    // verify that we only went one level deep\n\t                s = this.myState;\n\t                s.enter();\n\t            }\n\t        },\n\t\n\t        state: function(stateOrName){\n\t            return (stateOrName && stateOrName instanceof QState) ? stateOrName : new QState(this, stateOrName);\n\t        },\n\t\n\t        top: function(stateOrName){\n\t            // create the top state only once and store it to an auxiliary property\n\t            return (this._topState || (this._topState = new QState(this, \"TOP\")));\n\t        },\n\t\n\t        currentState: function(){\n\t            return this.myState;\n\t        },\n\t\n\t        flatten: function(){\n\t            this.statesTable = this.statesTable || {};\n\t            this._flatten(this.states, this.top().name);\n\t        },\n\t\n\t        _flatten: function(states, parent){\n\t            if (!states) {\n\t                return;\n\t            }\n\t\n\t            for (var state in states) {\n\t                if (states.hasOwnProperty(state)) {\n\t                    this.statesTable[state] = states[state];\n\t                    this.statesTable[state].parent = parent;\n\t                    this._flatten(states[state].states, state);\n\t                }\n\t            }\n\t        },\n\t\n\t        selectState: function(stateName){\n\t            return this.statesTable[stateName];\n\t        },\n\t\n\t        dispatchEvent: function(anEvent, state, act){\n\t            act = act || state[anEvent.type];\n\t\n\t            // Action might also be an array in which case it is assumed that evaluating guards decides\n\t            // which target to enter.\n\t            if (act instanceof Array) {\n\t                for (var i = 0; i < act.length; i++) {\n\t                    this.dispatchEvent(anEvent, state, act[i]);\n\t                }\n\t            }\n\t\n\t            // @todo This is terrible edge case used just for more fancy Statechart representation\n\t            // It allows using \"MyState\": { init: \"MySubState\", ... } intead of\n\t            // \"MyState\": { init: function(){ this.newInitialState(\"MySubState\"); }, ... }\n\t            // In some cases the latter form can be useful for better control of the Statechart\n\t            if (anEvent.type === \"init\" && typeof act === \"string\") {\n\t                this.newInitialState(act);\n\t                return null; // handled\n\t            }\n\t\n\t            if (act instanceof Function){\n\t                act.call(this, anEvent.args);\n\t                return null;  // handled\n\t            } else if (act) {\n\t                // no guard at all or the guard condition is met\n\t                if (!act.guard || (act.guard && act.guard.call(this, anEvent.args))){\n\t                    if (act.action) {\n\t                        act.action.call(this, anEvent.args);\n\t                    }\n\t                    if (act.target) {\n\t                        this.newState(act.target);\n\t                    }\n\t                    return null;  // handled\n\t                }\n\t            } else {        // act is undefined (no handler in state for anEvent)\n\t                if (state === this.selectState(\"TOP\")) {\n\t                    this.handleUnhandledEvent(anEvent); // not-handled\n\t                    return null;    // handled (TOP state handles all events)\n\t                }\n\t            }\n\t            return this.state(state.parent); // not-handled\n\t        },\n\t\n\t        // Override this when needed.\n\t        handleUnhandledEvent: function(anEvent){\n\t            this.debug(\"Unhandled event: \" + anEvent.type);\n\t            return null;\n\t        },\n\t\n\t        // Traverse the state hierarchy starting from the currently active state myState.\n\t        // Advance up the state hierarchy (i.e., from substates to superstates), invoking all\n\t        // the state handlers in succession. At each level of state nesting, it intercepts the value\n\t        // returned from a state handler to obtain the superstate needed to advance to the next level.\n\t        dispatch: function(anEvent, args){\n\t            if (!anEvent || !(anEvent instanceof QEvent)) {\n\t                anEvent = new QEvent(anEvent, args);\n\t            }\n\t            this.mySource = this.myState;\n\t            while (this.mySource) {\n\t                this.mySource = this.mySource.trigger(anEvent);\n\t            }\n\t        },\n\t\n\t        // Performs dynamic transition. (macro Q_TRAN_DYN())\n\t        newState: function(aStateName){\n\t            this.transition(this.state(aStateName));\n\t        },\n\t\n\t        // Used by handlers only in response to the #init event. (macro Q_INIT())\n\t        // USAGE: return this.newInitialState(\"whatever\");\n\t        // @return null for convenience\n\t\n\t        newInitialState: function(aStateOrName){\n\t            this.myState = this.state(aStateOrName);\n\t            return null;\n\t        },\n\t\n\t        // Dynamic transition. (Q_TRAN_DYN())\n\t        transition: function(target){\n\t            assert(!target.equals(this.top()));\n\t\n\t            var entry = [];\n\t            var mySource = this.mySource;\n\t            var s = this.myState;\n\t\n\t            // exit all the nested states between myState and mySource\n\t            assert(s !== null);\n\t            assert(mySource !== null);\n\t            while (!s.equals(mySource)) {\n\t                s = s.exit() || s.superstate();\n\t            }\n\t\n\t            // check all seven possible source/target state combinations\n\t\n\t\t    entry.push(target);\n\t\n\t            // (a) mySource == target (self transition)\n\t            if (mySource.equals(target)) {\n\t                mySource.exit();\n\t                return this.enterVia(target, entry);\n\t            }\n\t\n\t            // (b) mySource == target.superstate (one level deep)\n\t            var p = target.superstate();\n\t            if (mySource.equals(p)) {\n\t                return this.enterVia(target, entry);\n\t            }\n\t\n\t            assert(mySource !== null);\n\t\n\t            // (c) mySource.superstate == target.superstate (most common - fsa)\n\t            var q = mySource.superstate();\n\t            if (q.equals(p)) {\n\t                mySource.exit();\n\t                return this.enterVia(target, entry);\n\t            }\n\t\n\t            // (d) mySource.superstate == target (one level up)\n\t            if (q.equals(target)) {\n\t                mySource.exit();\n\t                entry.pop();    // do not enter the LCA\n\t                return this.enterVia(target, entry);\n\t            }\n\t\n\t            // (e) mySource == target.superstate.superstate... hierarchy (many levels deep)\n\t\t    entry.push(p);\n\t            s = p.superstate();\n\t            while (s !== null) {\n\t                if (mySource.equals(s)) {\n\t                    return this.enterVia(target, entry);\n\t                }\n\t\n\t\t\tentry.push(s);\n\t                s = s.superstate();\n\t            }\n\t\n\t            // otherwise we're definitely exiting mySource\n\t            mySource.exit();\n\t\n\t            // entry array is complete, save its length to avoid computing it repeatedly\n\t            var entryLength = entry.length;\n\t\n\t            // (f) mySource.superstate == target.superstate.superstate... hierarchy\n\t            var lca;\n\t            for (lca = entryLength - 1; lca >= 0; lca -= 1) {\n\t                if (q.equals(entry[lca])) {\n\t                    return this.enterVia(target, entry.slice(0, lca)); // do not enter lca\n\t                }\n\t            }\n\t\n\t            // (g) each mySource.superstate.superstate... for each target.superstate.superstate...\n\t            s = q;\n\t            while (s !== null) {\n\t                for (lca = entryLength - 1; lca >= 0; lca -= 1) {\n\t                    if (s.equals(entry[lca])) {\n\t                        return this.enterVia(target, entry.slice(0, lca)); // do not enter lca\n\t                    }\n\t                }\n\t                s.exit();\n\t                s = s.superstate();\n\t            }\n\t        },\n\t\n\t        // tail of transition()\n\t        // We are in the LCA of mySource and target.\n\t        enterVia: function(target, entry){\n\t\n\t            // retrace the entry path in reverse order\n\t            var idx = entry.length;\n\t            while (idx > 0) {\n\t                idx--;\n\t                entry[idx].enter();\n\t            }\n\t\n\t            this.myState = target;\n\t            while (target.init() === null) {\n\t                // initial transition must go one level deep\n\t                assert(target.equals(this.myState.superstate()));\n\t                target = this.myState;\n\t                target.enter();\n\t            }\n\t        }\n\t    };\n\t\n\t    // QState.\n\t    // -------\n\t\n\t    function QState(fsm, name){\n\t        this.fsm = fsm;\n\t        this.name = name;\n\t    }\n\t\n\t    QState.prototype = {\n\t        equals: function(state){\n\t            return (this.name === state.name && this.fsm === state.fsm);\n\t        },\n\t\n\t        dispatchEvent: function(anEvent, state){\n\t            return this.fsm.dispatchEvent(anEvent, state);\n\t        },\n\t\n\t        trigger: function(anEvent){\n\t            var evt = anEvent || QEventEmpty;\n\t            var state = this.fsm.selectState(this.name);\n\t            return this.dispatchEvent(evt, state);\n\t        },\n\t\n\t        enter: function(){\n\t            this.fsm.debug(\"[\" + this.name + \"] enter\");\n\t            return this.trigger(QEventEntry);\n\t        },\n\t\n\t        exit: function(){\n\t            this.fsm.debug(\"[\" + this.name + \"] exit\");\n\t            return this.trigger(QEventExit);\n\t        },\n\t\n\t        init: function(){\n\t            this.fsm.debug(\"[\" + this.name + \"] init\");\n\t            return this.trigger(QEventInit);\n\t        },\n\t\n\t        // Answer my superstate. Default is to return fsm top state.\n\t        superstate: function(){\n\t            var superstate = this.trigger(QEventEmpty);\n\t            if (superstate && superstate instanceof QState) {\n\t                return superstate;\n\t            }\n\t            superstate = this.fsm.top();\n\t            if (this.name === superstate.name) {\n\t                return null;\n\t            }\n\t            return superstate;\n\t        }\n\t    };\n\t\n\t    // QEvent\n\t    // ------\n\t\n\t    function QEvent(type, args){\n\t        this.type = type;\n\t        this.args = args;\n\t    }\n\t\n\t    // these events are static, they do not carry any arguments\n\t    // -> create them only once\n\t    // moreover, they don't have to be exposed to the outer world\n\t    var QEventEntry = new QEvent(\"entry\");\n\t    var QEventExit = new QEvent(\"exit\");\n\t    var QEventInit = new QEvent(\"init\");\n\t    var QEventEmpty = new QEvent(\"empty\");\n\t\n\t\n\t    return Statechart;\n\t}));\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar respoke = __webpack_require__(1);\n\tvar log = respoke.log;\n\tvar Statechart = __webpack_require__(19);\n\t\n\t/**\n\t * State machine for WebRTC calling, data channels, and screen sharing.\n\t * NOTE: All state transitions are synchronous! However,\n\t * listeners to the events this class fires will be called asynchronously.\n\t *\n\t * @class respoke.CallState\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @link https://cdn.respoke.io/respoke.min.js\n\t * @returns {respoke.CallState}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var fsm;\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    that.className = 'respoke.CallState';\n\t    delete that.instanceId;\n\t\n\t    var client = respoke.getClient(instanceId);\n\t    var allTimers = [];\n\t    var answerTimer;\n\t    var answerTimeout = params.answerTimeout || 10000;\n\t    var receiveAnswerTimer;\n\t    var receiveAnswerTimeout = params.receiveAnswerTimeout || 60000;\n\t    var connectionTimer;\n\t    var connectionTimeout = params.connectionTimeout || 10000;\n\t    var modifyTimer;\n\t    var modifyTimeout = params.modifyTimeout || 60000;\n\t    var oldRole;\n\t\n\t    function assert(condition) {\n\t        if (!condition) {\n\t            throw new Error(\"Assertion failed.\");\n\t        }\n\t    }\n\t\n\t    that.hasLocalMediaApproval = false;\n\t    that.hasLocalMedia = false;\n\t    that.receivedBye = false;\n\t    that.isAnswered = false;\n\t    that.sentSDP = false;\n\t    that.receivedSDP = false;\n\t    that.processedRemoteSDP = false;\n\t    that.needDirectConnection = !!that.needDirectConnection;\n\t    that.sendOnly = !!that.sendOnly;\n\t    that.receiveOnly = !!that.receiveOnly;\n\t    that.isModifying = false;\n\t\n\t    // Event\n\t    var rejectEvent = [{\n\t        action: function () {\n\t            [answerTimer, receiveAnswerTimer, connectionTimer, modifyTimer].forEach(function (timer) {\n\t                if (timer) {\n\t                    timer.clear();\n\t                }\n\t            });\n\t\n\t            // we have any media flowing or data channel open\n\t            if (typeof oldRole === 'boolean') {\n\t                // Reset the role if we have aborted a modify.\n\t                that.caller = oldRole;\n\t            }\n\t\n\t            that.isModifying = false;\n\t        }\n\t    }, {\n\t        target: 'connected',\n\t        guard: function () {\n\t            return that.hasMedia();\n\t        }\n\t    }, {\n\t        target: 'terminated',\n\t        guard: function (params) {\n\t            params = params || {};\n\t            // we have no media flowing or data channel open\n\t            that.hangupReason = params.reason || \"no media\";\n\t            return !that.hasMedia();\n\t        }\n\t    }];\n\t\n\t    // Event\n\t    function rejectModify() {\n\t        // reject modification\n\t        if (modifyTimer) {\n\t            modifyTimer.clear();\n\t            that.isModifying = false;\n\t        }\n\t    }\n\t\n\t    // Event\n\t    function clearReceiveAnswerTimer() {\n\t        that.processedRemoteSDP = true;\n\t        if (receiveAnswerTimer) {\n\t            receiveAnswerTimer.clear();\n\t        }\n\t    }\n\t\n\t    // Event\n\t    var hangupEvent = {\n\t        target: 'terminated',\n\t        action: function (params) {\n\t            params = params || {};\n\t            that.signalBye = params.signal;\n\t            that.hangupReason = that.hangupReason || params.reason || \"none\";\n\t        }\n\t    };\n\t\n\t    function needToObtainMedia() {\n\t        return (\n\t            that.needDirectConnection !== true &&\n\t            that.receiveOnly !== true &&\n\t            that.hasLocalMedia !== true\n\t        );\n\t    }\n\t\n\t    function needToApproveDirectConnection(params) {\n\t        return (that.needDirectConnection === true && typeof params.previewLocalMedia === 'function');\n\t    }\n\t\n\t    function automaticOffering(params) {\n\t        if (that.caller !== true) {\n\t            return false;\n\t        }\n\t\n\t        // TODO: this will need to be change with media negotiation\n\t        if ((!that.needDirectConnection && that.receiveOnly) || that.hasLocalMedia) {\n\t            return true;\n\t        }\n\t\n\t        return (that.needDirectConnection === true && typeof params.previewLocalMedia !== 'function');\n\t    }\n\t\n\t    function hasListener() {\n\t        return ((client.hasListeners('call') && !that.needDirectConnection) ||\n\t                (client.hasListeners('direct-connection') && that.needDirectConnection));\n\t    }\n\t\n\t    function createTimer(func, name, time) {\n\t        var id = setTimeout(function () {\n\t            id = null;\n\t            log.error((that.caller ? \"caller's\" : \"callee's\"), name, \"timer expired.\");\n\t            func();\n\t        }, time);\n\t        log.debug('setting timer', name, 'for', time / 1000, 'secs');\n\t        var timer  = {\n\t            name: name,\n\t            clear: function () {\n\t                if (id === null) {\n\t                    return;\n\t                }\n\t                log.debug('clearing', (that.caller ? \"caller's\" : \"callee's\"), 'timer', name);\n\t                clearTimeout(id);\n\t                id = null;\n\t            }\n\t        };\n\t        allTimers.push(timer);\n\t        return timer;\n\t    }\n\t\n\t    var stateParams = {\n\t        initialState: 'idle',\n\t        states: {\n\t            // State\n\t            idle: {\n\t                // Event\n\t                exit: function () {\n\t                    that.fire('idle:exit');\n\t                },\n\t                // Event\n\t                initiate: [{\n\t                    target: 'negotiatingContainer',\n\t                    guard: function (params) {\n\t                        assert(typeof params.caller === 'boolean');\n\t                        return (params.caller === true || hasListener());\n\t                    }\n\t                }, {\n\t                    target: 'terminated',\n\t                    guard: function (params) {\n\t                        return (params.caller !== true && !hasListener());\n\t                    }\n\t                }],\n\t                receiveLocalMedia: function () {\n\t                    that.hasLocalMedia = true;\n\t                },\n\t                // Event\n\t                receiveOffer: {\n\t                    action: function (params) {\n\t                        that.receivedSDP = true;\n\t                    }\n\t                },\n\t                // Event\n\t                hangup: hangupEvent\n\t            },\n\t            // State\n\t            negotiatingContainer: {\n\t                init: \"preparing\",\n\t                // Event\n\t                hangup: hangupEvent,\n\t                // Event\n\t                modify: rejectModify,\n\t                // Event\n\t                receiveLocalMedia: function () {\n\t                    that.hasLocalMedia = true;\n\t                },\n\t                states: {\n\t                    preparing: {\n\t                        // Event\n\t                        entry: {\n\t                            action: function () {\n\t                                that.hasLocalMediaApproval = false;\n\t                                that.hasLocalMedia = false;\n\t                                that.sentSDP = false;\n\t                                that.receivedSDP = false;\n\t                                that.processedRemoteSDP = false;\n\t                                that.isAnswered = false;\n\t                                if (!that.isModifying) {\n\t                                    answerTimer = createTimer(function () {\n\t                                        that.dispatch('reject', {reason: \"answer own call timer \" + that.caller});\n\t                                    }, 'answer own call', (that.caller ? answerTimeout : receiveAnswerTimeout));\n\t                                }\n\t                                that.fire('preparing:entry');\n\t                            }\n\t                        },\n\t                        // Event\n\t                        exit: function () {\n\t                            if (answerTimer) {\n\t                                answerTimer.clear();\n\t                            }\n\t                        },\n\t                        // Event\n\t                        reject: rejectEvent,\n\t                        // Event\n\t                        receiveOffer: [{\n\t                            action: function (params) {\n\t                                that.receivedSDP = true;\n\t                                if (that.isAnswered) {\n\t                                    // If we get here, we are the callee and we've answered the call before the call\n\t                                    // creation/receive offer promise chain completed.\n\t                                    setTimeout(function () {\n\t                                        that.dispatch('answer', params);\n\t                                    });\n\t                                }\n\t                            }\n\t                        }, {\n\t                            target: 'connecting',\n\t                            guard: function () {\n\t                                return that.isModifying;\n\t                            }\n\t                        }],\n\t                        // Event\n\t                        answer: [{\n\t                            action: function (params) {\n\t                                assert(!params.previewLocalMedia || typeof params.previewLocalMedia === 'function');\n\t                                that.isAnswered = true;\n\t                                if (typeof params.previewLocalMedia !== 'function') {\n\t                                    that.hasLocalMediaApproval = true;\n\t                                }\n\t                            }\n\t                        }, {\n\t                            // we are going to send media\n\t                            target: 'approvingDeviceAccess',\n\t                            guard: needToObtainMedia\n\t                        }, {\n\t                            // we are sending a direct connection & developer wants to approve\n\t                            target: 'approvingContent',\n\t                            guard: needToApproveDirectConnection\n\t                        }, {\n\t                            target: 'offering',\n\t                            guard: automaticOffering\n\t                        }, {\n\t                            // we are not sending anything or developer does not want to approve media.\n\t                            target: 'connecting',\n\t                            guard: function (params) {\n\t                                // caller will always answer before sending offer.\n\t                                // callee will usually answer after receiving offer if media is requested.\n\t                                if (!that.receivedSDP) {\n\t                                    return false;\n\t                                }\n\t\n\t                                if (needToObtainMedia() || needToApproveDirectConnection(params) ||\n\t                                        automaticOffering(params)) {\n\t                                    return false;\n\t                                }\n\t\n\t                                if (!params.previewLocalMedia || that.receiveOnly) {\n\t                                    setTimeout(function () {\n\t                                        params.approve();\n\t                                    });\n\t                                }\n\t                                return (that.receiveOnly === true || that.needDirectConnection === true);\n\t                            }\n\t                        }]\n\t                    },\n\t                    // State\n\t                    gettingMedia: {\n\t                        reject: rejectEvent,\n\t                        // Event\n\t                        receiveLocalMedia: [{\n\t                            action: function () {\n\t                                that.hasLocalMedia = true;\n\t                            }\n\t                        }, {\n\t                            target: 'offering',\n\t                            guard: function (params) {\n\t                                return (that.caller === true && that.hasLocalMediaApproval === true &&\n\t                                    that.hasLocalMedia === true);\n\t                            }\n\t                        }, {\n\t                            target: 'connecting',\n\t                            guard: function (params) {\n\t                                return (that.caller === false && that.hasLocalMediaApproval === true &&\n\t                                    that.hasLocalMedia === true);\n\t                            }\n\t                        }],\n\t                        states: {\n\t                            // State\n\t                            approvingDeviceAccess: {\n\t                                // Event\n\t                                approve: [{\n\t                                    target: 'approvingContent',\n\t                                    guard: function (params) {\n\t                                        return (typeof params.previewLocalMedia === 'function');\n\t                                    }\n\t                                }, {\n\t                                    target: 'connecting',\n\t                                    guard: function (params) {\n\t                                        return (that.caller === false &&\n\t                                            (that.hasLocalMedia === true || that.needDirectConnection === true) &&\n\t                                            typeof params.previewLocalMedia !== 'function');\n\t                                    }\n\t                                }, {\n\t                                    target: 'offering',\n\t                                    guard: function (params) {\n\t                                        return (that.caller === true && that.hasLocalMedia === true &&\n\t                                            typeof params.previewLocalMedia !== 'function');\n\t                                    }\n\t                                }]\n\t                            },\n\t                            // State\n\t                            approvingContent: {\n\t                                // Event\n\t                                approve: [function (params) {\n\t                                    that.hasLocalMediaApproval = true;\n\t                                }, {\n\t                                    target: 'offering',\n\t                                    guard: function (params) {\n\t                                        return (that.caller === true && that.hasLocalMedia === true);\n\t                                    }\n\t                                }, {\n\t                                    target: 'connecting',\n\t                                    guard: function (params) {\n\t                                        return (that.caller === false && that.hasLocalMedia === true);\n\t                                    }\n\t                                }]\n\t                            }\n\t                        }\n\t                    },\n\t                    // State\n\t                    offeringContainer: {\n\t                        init: 'offering',\n\t                        reject: rejectEvent,\n\t                        sentOffer: function () {\n\t                            // start answer timer\n\t                            receiveAnswerTimer = createTimer(function () {\n\t                                that.dispatch('reject', {reason: \"receive answer timer\"});\n\t                            }, 'receive answer', receiveAnswerTimeout);\n\t                        },\n\t                        states: {\n\t                            offering: {\n\t                                // Event\n\t                                entry: function () {\n\t                                    that.fire('offering:entry');\n\t                                },\n\t                                // Event\n\t                                receiveLocalMedia: [function () {\n\t                                    that.hasLocalMedia = true;\n\t                                }, {\n\t                                    target: 'connected',\n\t                                    guard: function (params) {\n\t                                        // for direct connection, local media is the same as remote media\n\t                                        return (that.needDirectConnection === true);\n\t                                    }\n\t                                }],\n\t                                // Event\n\t                                receiveRemoteMedia: {\n\t                                    target: 'connected'\n\t                                },\n\t                                // Event\n\t                                receiveAnswer: [clearReceiveAnswerTimer, {\n\t                                    target: 'connecting',\n\t                                    guard: function () {\n\t                                        return !that.isModifying;\n\t                                    }\n\t                                }, {\n\t                                    target: 'connected',\n\t                                    guard: function () {\n\t                                        return that.isModifying;\n\t                                    }\n\t                                }]\n\t                            }\n\t                        }\n\t                    },\n\t                    // State\n\t                    connectingContainer: {\n\t                        init: 'connecting',\n\t                        reject: rejectEvent,\n\t                        receiveAnswer: clearReceiveAnswerTimer,\n\t                        states: {\n\t                            connecting: {\n\t                                // Event\n\t                                entry: function () {\n\t                                    that.fire('connecting:entry');\n\t\n\t                                    // set connection timer\n\t                                    connectionTimer = createTimer(function () {\n\t                                        that.dispatch('reject', {reason: \"connection timer\"});\n\t                                    }, 'connection', connectionTimeout);\n\t                                },\n\t                                // Event\n\t                                exit: function () {\n\t                                    if (connectionTimer) {\n\t                                        connectionTimer.clear();\n\t                                    }\n\t                                },\n\t                                // Event\n\t                                receiveLocalMedia: [{\n\t                                    action: function () {\n\t                                        that.hasLocalMedia = true;\n\t                                    }\n\t                                }, {\n\t                                    target: 'connected',\n\t                                    guard: function (params) {\n\t                                        // for direct connection, local media is the same as remote media\n\t                                        return (that.needDirectConnection === true && that.caller === false);\n\t                                    }\n\t                                }],\n\t                                // Event\n\t                                receiveRemoteMedia: {\n\t                                    target: 'connected'\n\t                                },\n\t                                removeRemoteMedia: {\n\t                                    target: 'connected'\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            // State\n\t            // This state is for when we are in limbo between connected and negotiating and we are\n\t            // trying to figure out if the other side will allow us to modify. If we receive modify in\n\t            // this state, we will reject it. If the other party is in connected, we will be able to modify.\n\t            modifyingContainer: {\n\t                init: 'modifying',\n\t                reject: rejectEvent,\n\t                // Event\n\t                modify: rejectModify,\n\t                // Event\n\t                hangup: hangupEvent,\n\t                states: {\n\t                    modifying: {\n\t                        // Event\n\t                        entry: function () {\n\t                            modifyTimer = createTimer(function () {\n\t                                that.dispatch('reject', {reason: \"modify timer\"});\n\t                            }, 'modify for caller', modifyTimeout);\n\t                        },\n\t                        // Event\n\t                        accept: [function () {\n\t                            that.caller = true;\n\t                        }, {\n\t                            target: 'preparing'\n\t                        }]\n\t                    }\n\t                }\n\t            },\n\t            // State\n\t            connectedContainer: {\n\t                init: 'connected',\n\t                reject: {\n\t                    target: 'terminated',\n\t                    action: function (params) {\n\t                        that.hangupReason = params.reason || \"got reject while connected\";\n\t                    }\n\t                },\n\t                receiveAnswer: clearReceiveAnswerTimer,\n\t                // Event\n\t                hangup: hangupEvent,\n\t                states: {\n\t                    connected: {\n\t                        // Event\n\t                        entry: function () {\n\t                            oldRole = that.caller;\n\t                            that.needDirectConnection = false;\n\t                            that.isModifying = false;\n\t                            that.sendOnly = false;\n\t                            that.receiveOnly = false;\n\t\n\t                            if (modifyTimer) {\n\t                                modifyTimer.clear();\n\t                            }\n\t                        },\n\t                        // Event\n\t                        modify: [{\n\t                            action: function () {\n\t                                that.isModifying = true;\n\t                            }\n\t                        }, {\n\t                            // be notified that the other side would like modification\n\t                            target: 'preparing',\n\t                            guard: function (params) {\n\t                                params = params || {};\n\t                                if (params.receive === true) {\n\t                                    that.caller = false;\n\t                                    modifyTimer = createTimer(function () {\n\t                                        // If modify gets interrupted, go back to previous roles.\n\t                                        that.dispatch('reject', {reason: \"modify timer\"});\n\t                                    }, 'modify', modifyTimeout);\n\t                                    return true;\n\t                                }\n\t                            }\n\t                        }, {\n\t                            // request to begin modification\n\t                            target: 'modifying',\n\t                            guard: function (params) {\n\t                                params = params || {};\n\t                                return (params.receive !== true);\n\t                            }\n\t                        }]\n\t                    }\n\t                }\n\t            },\n\t            // State\n\t            terminatedContainer: {\n\t                init: 'terminated',\n\t                states: {\n\t                    terminated: {\n\t                        // Event\n\t                        entry: {\n\t                            action: function () {\n\t                                that.fire('terminated:entry');\n\t                                allTimers.forEach(function (timer) {\n\t                                    timer.clear();\n\t                                });\n\t                                setTimeout(function () {\n\t                                    fsm = null;\n\t                                    that.ignore();\n\t                                });\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    stateParams.that = Object.create(Statechart);\n\t    fsm = respoke.Class(stateParams);\n\t    fsm.run({\n\t        // rename to 'debug' to enable\n\t        debugOff: function () {\n\t            // So we can print the caller. Debug most often used when testing & tests run in the same tab.\n\t            var args = Array.prototype.slice.call(arguments);\n\t            args.unshift(\"state change:\");\n\t            log.debug.apply(log, args);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Return the name of the current state.\n\t     * @memberof! respoke.CallState\n\t     * @method respoke.Call.getState\n\t     * @returns {string}\n\t     */\n\t    that.getState = function () {\n\t        if (!fsm) {\n\t            return 'terminated';\n\t        }\n\t        return fsm.currentState().name;\n\t    };\n\t\n\t    /**\n\t     * Synchronously dispatch an event, which may or may not change the state.\n\t     * @memberof! respoke.CallState\n\t     * @method respoke.Call.dispatch\n\t     */\n\t    that.dispatch = function (evt, args) {\n\t        var oldState;\n\t        var newState;\n\t\n\t        /*\n\t         * These can quite often result in a condition in which they do not\n\t         * cause a transition to occur. There is at least one \"universal\" (air quotes)\n\t         * event which probably? shouldn't? but may result in a non-transition error\n\t         * when it's OK, and that is the 'reject' event.\n\t         */\n\t        var nontransitionEvents = ['receiveLocalMedia', 'receiveRemoteMedia', 'removeRemoteMedia',\n\t            'approve', 'answer', 'sentOffer', 'receiveAnswer'];\n\t\n\t        if (!fsm) {\n\t            return;\n\t        }\n\t\n\t        oldState = that.getState();\n\t        log.debug(\"dispatching '\" + evt + \"', from '\" + oldState + \"'. caller?\", that.caller, \"args:\", args);\n\t\n\t        try {\n\t            fsm.dispatch(evt, args);\n\t        } catch (err) {\n\t            log.debug(\"error dispatching '\" + evt + \"' from '\" + oldState + \"'.\", { args: args, error: err });\n\t            throw err;\n\t        }\n\t\n\t        newState = that.getState();\n\t\n\t        if (oldState === newState && nontransitionEvents.indexOf(evt) === -1) {\n\t            log.debug(\"Possible bad event '\" + evt + \"', no transition occurred. caller?\", that.caller);\n\t        } else {\n\t            log.debug(\"dispatch complete. new state: '\" + newState + \"'.\");\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Helper for testing state name\n\t     * @memberof! respoke.CallState\n\t     * @method respoke.Call.isState\n\t     * @param {string} name\n\t     * @returns {boolean}\n\t     */\n\t    that.isState = function (name) {\n\t        return (that.getState() === name);\n\t    };\n\t\n\t    assert(typeof that.hasMedia === 'function');\n\t    assert(typeof that.caller === 'boolean');\n\t    return that;\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(8);\n\tvar respoke = __webpack_require__(1);\n\tvar log = respoke.log;\n\t\n\t/**\n\t * A `respoke.Call` is Respoke's interface into a WebRTC call, including getUserMedia,\n\t * path and codec negotation, and call state.\n\t * There are several methods on an instance of `respoke.Client` which return a `respoke.Call`.\n\t *\n\t * ```\n\t * var jim = client.getEndpoint({ id: 'jim' });\n\t * var call = jim.startAudioCall();\n\t * ```\n\t *\n\t * @class respoke.Call\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.instanceId - client id\n\t * @param {boolean} params.caller - whether or not we initiated the call\n\t * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t * @param {boolean} [params.sendOnly] - whether or not we send media\n\t * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t * relay servers. If it cannot flow through relay servers, the call will fail.\n\t * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t * required to flow peer-to-peer. If it cannot, the call will fail.\n\t * @param {respoke.Endpoint} params.remoteEndpoint - The endpoint who is being called.\n\t * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint.\n\t * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t * wants to perform an action between local media becoming available and calling approve().\n\t * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n\t * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n\t * @param {function} params.signalReport - Signaling action from SignalingChannel.\n\t * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n\t * @param {Array<RTCConstraints>} params.constraints - Array of WebRTC constraints. This is ignored when\n\t * `params.outgoingMedia` is passed into the Call object.\n\t * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t * media renegotiation.\n\t * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t * element with the local audio and/or video attached.\n\t * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n\t * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n\t * it was ended in a graceful manner.\n\t * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t * This callback will be called when media is muted or unmuted.\n\t * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t * for the user to give permission to start getting audio or video.\n\t * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t * the approval was automatic.\n\t * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n\t * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n\t * granted by the browser without asking the user to approve it.\n\t * @param {respoke.Call.onToneSent} [params.onToneSent] - Callback for when a DTMF tone gets sent from the client.\n\t * @param {respoke.Call.onToneSendingStarted} [params.onToneSendingStarted] - Callback for when DTMF tones\n\t * have started sending.\n\t * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local\n\t * video attached to it.\n\t * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote\n\t * @param {respoke.LocalMedia} params.outgoingMedia - Pass in an optional LocalMedia object to override the one that is\n\t * built automatically when establishing the call. When this is defined then any constraints passed to the\n\t * call are ignored since the media object already exists.\n\t * video attached to it.\n\t * @returns {respoke.Call}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var that = respoke.EventEmitter(params);\n\t    delete that.instanceId;\n\t    delete that.outgoingMedia;\n\t\n\t    /**\n\t     * A name to identify the type of object.\n\t     * @memberof! respoke.Call\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Call';\n\t\n\t    /**\n\t     * Whether or not the client is the caller of the call.\n\t     * @memberof! respoke.Call\n\t     * @name caller\n\t     * @type {boolean}\n\t     */\n\t    that.caller = !!that.caller;\n\t    Object.defineProperty(that, \"initiator\", {\n\t        configurable: true,\n\t        enumerable: true,\n\t        get: function () {\n\t            log.warn(\"The call.initiator flag is deprecated. Please use call.caller instead.\");\n\t            return that.caller;\n\t        },\n\t        set: function () {\n\t            // ignore\n\t        }\n\t    });\n\t\n\t    if (!that.caller) {\n\t        // Don't let Respoke.js pass any default constraints if we're accepting the call. We have no freaking clue\n\t        // what kind of media we are expected to provide at this point.\n\t        delete params.constraints;\n\t        that.constraints = [];\n\t    }\n\t\n\t    /**\n\t     * The call ID.\n\t     * @memberof! respoke.Call\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = that.caller ? respoke.makeGUID() : that.id;\n\t\n\t    // log the call id to the console for debugging purposes. Do not change this to `respoke.log`!\n\t    console.log(\"[Respoke] Creating call. id='\" + that.id + \"'\");\n\t\n\t    if (!that.id) {\n\t        throw new Error(\"Can't start a new call without a call id.\");\n\t    }\n\t\n\t    /**\n\t     * Promise used to trigger actions dependant upon having received media or a datachannel.\n\t     * @memberof! respoke.Call\n\t     * @name defMedia\n\t     * @private\n\t     * @type {Promise}\n\t     */\n\t    var defMedia = Q.defer();\n\t    /**\n\t     * Promise used to trigger notification of a request for renegotiating media. For the caller of the\n\t     * renegotiation (which doesn't have to be the same as the caller of the call), this is resolved\n\t     * or rejected as soon as the 'accept' or 'reject' signal is received. For the callee, it is\n\t     * resolved or rejected only after the developer or user approves or rejects the modify.\n\t     * @memberof! respoke.Call\n\t     * @name defModify\n\t     * @private\n\t     * @type {Promise}\n\t     */\n\t    var defModify;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name previewLocalMedia\n\t     * @private\n\t     * @type {respoke.Call.previewLocalMedia}\n\t     */\n\t    var previewLocalMedia = params.previewLocalMedia;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name client\n\t     * @private\n\t     * @type {respoke.getClient}\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name signalingChannel\n\t     * @private\n\t     * @type {respoke.signalingChannel}\n\t     */\n\t    var signalingChannel = params.signalingChannel;\n\t\n\t    /**\n\t     * Informational property. Whether call debugs were enabled on the client during creation.\n\t     * Changing this value will do nothing.\n\t     * @name enableCallDebugReport\n\t     * @type {boolean}\n\t     */\n\t    that.enableCallDebugReport = params.signalingChannel.isSendingReport();\n\t\n\t    /**\n\t     * Informational property indicating if this call has fired the public 'connect' event\n\t     * inside receiveRemoteMedia.\n\t     * @name hasReceivedRemoteMedia\n\t     * @type {boolean}\n\t     * @private\n\t     */\n\t    var hasReceivedRemoteMedia = false;\n\t\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name pc\n\t     * @private\n\t     * @type {respoke.PeerConnection}\n\t     */\n\t    var pc = respoke.PeerConnection({\n\t        instanceId: instanceId,\n\t        state: respoke.CallState({\n\t            instanceId: instanceId,\n\t            caller: that.caller,\n\t            needDirectConnection: params.needDirectConnection,\n\t            sendOnly: params.sendOnly,\n\t            receiveOnly: params.receiveOnly,\n\t            // hasMedia is not defined yet.\n\t            hasMedia: function () {\n\t                return that.hasMedia();\n\t            }\n\t        }),\n\t        forceTurn: !!params.forceTurn,\n\t        call: that,\n\t        pcOptions: {\n\t            optional: [\n\t                { DtlsSrtpKeyAgreement: true },\n\t                { RtpDataChannels: false }\n\t            ]\n\t        },\n\t        offerOptions: params.offerOptions || null,\n\t        signalOffer: function (args) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            params.signalOffer(args);\n\t            pc.state.dispatch('sentOffer');\n\t        },\n\t        signalConnected: params.signalConnected,\n\t        signalAnswer: params.signalAnswer,\n\t        signalModify: params.signalModify,\n\t        signalHangup: params.signalHangup,\n\t        signalReport: params.signalReport,\n\t        signalCandidate: params.signalCandidate\n\t    });\n\t\n\t    /**\n\t     * Array of streams of local media that we are sending to the remote party.\n\t     * @name outgoingMediaStreams\n\t     * @type {Array<respoke.LocalMedia>}\n\t     */\n\t    that.outgoingMediaStreams = [];\n\t    that.outgoingMediaStreams.hasAudio = function () {\n\t        if (that.outgoingMediaStreams.length === 0) {\n\t            return false;\n\t        }\n\t\n\t        return !that.outgoingMediaStreams.every(function (stream) {\n\t            return stream.getAudioTracks().length === 0;\n\t        });\n\t    };\n\t\n\t    that.outgoingMediaStreams.hasVideo = function () {\n\t        if (that.outgoingMediaStreams.length === 0) {\n\t            return false;\n\t        }\n\t\n\t        return !that.outgoingMediaStreams.every(function (stream) {\n\t            return stream.getVideoTracks().length === 0;\n\t        });\n\t    };\n\t\n\t    if (params.outgoingMedia) {\n\t        that.outgoingMediaStreams.push(params.outgoingMedia);\n\t    }\n\t\n\t    /**\n\t     * Local media that we are sending to the remote party. This will be undefined if we are sending no media.\n\t     * This property is just the first item in the `outgoingMediaStreams` array. If multiple streams are present,\n\t     * use that array to find the stream you need instead of relying on this property.\n\t     * @name outgoingMedia\n\t     * @type {respoke.LocalMedia}\n\t     */\n\t    Object.defineProperty(that, \"outgoingMedia\", {\n\t        configurable: false,\n\t        enumerable: true,\n\t        get: function () {\n\t            return that.outgoingMediaStreams[0];\n\t        },\n\t        set: function () {\n\t            // ignore\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Array of streams of remote media that we are receiving from the remote party.\n\t     * @name incomingMediaStreams\n\t     * @type {Array<respoke.RemoteMedia>}\n\t     */\n\t    that.incomingMediaStreams = [];\n\t    that.incomingMediaStreams.hasAudio = function () {\n\t        if (that.incomingMediaStreams.length === 0) {\n\t            return false;\n\t        }\n\t\n\t        return !that.incomingMediaStreams.every(function (stream) {\n\t            return stream.getAudioTracks().length === 0;\n\t        });\n\t    };\n\t\n\t    that.incomingMediaStreams.hasVideo = function () {\n\t        if (that.incomingMediaStreams.length === 0) {\n\t            return false;\n\t        }\n\t\n\t        return !that.incomingMediaStreams.every(function (stream) {\n\t            return stream.getVideoTracks().length === 0;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Remote media that we are receiving from the remote party.  This will be undefined if we\n\t     * are receiving no media. This property is just the first item in the `incomingMediaStreams` array. If multiple\n\t     * streams are present, use that array to find the stream you need instead of relying on this property.\n\t     * @name incomingMedia\n\t     * @type {respoke.RemoteMedia}\n\t     */\n\t    Object.defineProperty(that, \"incomingMedia\", {\n\t        configurable: false,\n\t        enumerable: true,\n\t        get: function () {\n\t            return that.incomingMediaStreams[0];\n\t        },\n\t        set: function () {\n\t            // ignore\n\t        }\n\t    });\n\t\n\t    /**\n\t     * A flag indicating whether this call has audio or is expected to have audio coming in from the other side.\n\t     *\n\t     * @name hasAudio\n\t     * @type {boolean}\n\t     */\n\t    Object.defineProperty(that, \"hasAudio\", {\n\t        configurable: false,\n\t        enumerable: true,\n\t        get: that.incomingMediaStreams.hasAudio,\n\t        set: function () {\n\t            // ignore\n\t        }\n\t    });\n\t\n\t    /**\n\t     * A flag indicating whether this call has video or is expected to have video coming in from the other side.\n\t     *\n\t     * @name hasVideo\n\t     * @type {boolean}\n\t     */\n\t    Object.defineProperty(that, \"hasVideo\", {\n\t        configurable: false,\n\t        enumerable: true,\n\t        get: that.incomingMediaStreams.hasVideo,\n\t        set: function () {\n\t            // ignore\n\t        }\n\t    });\n\t\n\t    delete params.signalingChannel;\n\t    delete that.signalingChannel;\n\t\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name videoIsMuted\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var videoIsMuted = false;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name audioIsMuted\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var audioIsMuted = false;\n\t    /**\n\t     * @memberof! respoke.Call\n\t     * @name directConnection\n\t     * @private\n\t     * @type {respoke.DirectConnection}\n\t     */\n\t    var directConnection = null;\n\t\n\t    /**\n\t     * Register any event listeners passed in as callbacks, save other params to answer() and accept().\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.saveParameters\n\t     * @param {object} params\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n\t     * it was ended in a graceful manner.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will fire even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n\t     * user's media.  This event gets fired even if the allow process is automatic, i. e., permission and media is\n\t     * granted by the browser without asking the user to approve it.\n\t     * @param {respoke.Call.onToneSent} [params.onToneSent] - Callback for when a DTMF tone gets sent from the client.\n\t     * @param {Array<RTCConstraints>} [params.constraints]\n\t     * @param {boolean} [params.forceTurn]\n\t     * @param {boolean} [params.receiveOnly]\n\t     * @param {boolean} [params.sendOnly]\n\t     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t     * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local\n\t     * video attached to it.\n\t     * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote\n\t     * video attached to it.\n\t     * @private\n\t     * @fires respoke.Call#stats\n\t     */\n\t    function saveParameters(params) {\n\t        if (!pc) {\n\t            /* This happens when the call is hung up automatically, for instance due to the lack of an onCall\n\t             * handler. In this case, pc has been set to null in hangup. The call has already failed, and the\n\t             * invocation of this function is an artifact of async code not being finished yet, so we can just\n\t             * skip all of this setup.\n\t             */\n\t            return;\n\t        }\n\t\n\t        that.listen('local-stream-received', params.onLocalMedia);\n\t        that.listen('remote-stream-received', params.onRemoteMedia);\n\t        that.listen('connect', params.onConnect);\n\t        that.listen('hangup', params.onHangup);\n\t        that.listen('allow', params.onAllow);\n\t        that.listen('answer', params.onAnswer);\n\t        that.listen('approve', params.onApprove);\n\t        that.listen('mute', params.onMute);\n\t        that.listen('requesting-media', params.onRequestingMedia);\n\t        that.listen('tone-sent', params.onToneSent);\n\t        that.listen('tone-sending-started', params.onToneSendingStarted);\n\t        that.listen('tone-sending-cancelled', params.onToneSendingCancelled);\n\t\n\t        previewLocalMedia = typeof params.previewLocalMedia === 'function' ?\n\t            params.previewLocalMedia : previewLocalMedia;\n\t\n\t        pc.state.receiveOnly = typeof params.receiveOnly === 'boolean' ? params.receiveOnly : pc.state.receiveOnly;\n\t        pc.state.sendOnly = typeof params.sendOnly === 'boolean' ? params.sendOnly : pc.state.sendOnly;\n\t        pc.state.needDirectConnection = typeof params.needDirectConnection === 'boolean' ?\n\t            params.needDirectConnection : pc.state.needDirectConnection;\n\t        pc.disableTurn = typeof params.disableTurn === 'boolean' ? params.disableTurn : !!pc.disableTurn;\n\t        pc.forceTurn = typeof params.forceTurn === 'boolean' ? params.forceTurn : !!pc.forceTurn;\n\t\n\t        that.videoLocalElement = params.videoLocalElement ? params.videoLocalElement : that.videoLocalElement;\n\t        that.videoRemoteElement = params.videoRemoteElement ? params.videoRemoteElement : that.videoRemoteElement;\n\t\n\t        if (pc.state.receiveOnly) {\n\t            that.outgoingMediaStreams.length = 0;\n\t            that.constraints = [];\n\t        } else if (params.constraints) {\n\t            that.constraints = respoke.convertConstraints(params.constraints);\n\t            updateOutgoingMediaEstimate({constraints: that.constraints[0], source: params.source});\n\t        }\n\t\n\t        if (pc.state.sendOnly) {\n\t            that.incomingMediaStreams.length = 0;\n\t        } else if (params.constraints && pc.state.caller === true && that.incomingMediaStreams.length === 0) {\n\t            // TODO above condition is not good enough for media renegotiation.\n\t            // Only the person who initiated this round of media negotiation needs to estimate remote\n\t            // media based on what constraints local media is using.\n\t            // Also don't try to guess what media they'll send back if we're sending more than one stream.\n\t            that.constraints = respoke.convertConstraints(params.constraints);\n\t            updateIncomingMediaEstimate({constraints: params.constraints[0]});\n\t        }\n\t\n\t        pc.listen('stats', function fireStats(evt) {\n\t            /**\n\t             * This event is fired every time statistical information about audio and/or video on a call\n\t             * becomes available.\n\t             * @event respoke.Call#stats\n\t             * @type {respoke.Event}\n\t             * @property {respoke.MediaStats} stats - an object with stats in it.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.fire('stats', {stats: evt.stats});\n\t        }, true);\n\t\n\t        delete that.signalOffer;\n\t        delete that.signalConnected;\n\t        delete that.signalAnswer;\n\t        delete that.signalHangup;\n\t        delete that.signalReport;\n\t        delete that.signalCandidate;\n\t    }\n\t\n\t    /**\n\t     * Build respoke.LocalMedia after the call is answered.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.buildLocalMedia\n\t     * @param {RTCConstraint} constraint\n\t     * @private\n\t     */\n\t    function buildLocalMedia(constraint) {\n\t        var localMedia;\n\t\n\t        if (pc.state.receiveOnly) {\n\t            return Q.reject(new Error(\"Shouldn't have requested local media when receiveOnly is true.\"));\n\t        }\n\t\n\t        if (constraint.className === 'respoke.LocalMedia') {\n\t            localMedia = constraint;\n\t        } else {\n\t            localMedia = respoke.LocalMedia({\n\t                hasScreenShare: respoke.constraintsHasScreenShare(constraint),\n\t                constraints: constraint,\n\t                source: params.source\n\t            });\n\t            that.outgoingMediaStreams.push(localMedia);\n\t        }\n\t\n\t        // use passed video element if localMedia constraints contain video\n\t        if (respoke.constraintsHasVideo(localMedia.constraints)) {\n\t            localMedia.element = that.videoLocalElement;\n\t        }\n\t\n\t        localMedia.listen('requesting-media', function waitAllowHandler(evt) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            /**\n\t             * The browser is asking for permission to access the User's media. This would be an ideal time\n\t             * to modify the UI of the application so that the user notices the request for permissions\n\t             * and approves it.\n\t             * @event respoke.Call#requesting-media\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.fire('requesting-media');\n\t        }, true);\n\t\n\t        localMedia.listen('allow', function allowHandler(evt) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t\n\t            /**\n\t             * The user has approved the request for media. Any UI changes made to remind the user to click Allow\n\t             * should be canceled now. This event is the same as the `onAllow` callback.  This event gets fired\n\t             * even if the allow process is automatic, i. e., permission and media is granted by the browser\n\t             * without asking the user to approve it.\n\t             * @event respoke.Call#allow\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.fire('allow');\n\t            pc.state.dispatch('approve', {\n\t                previewLocalMedia: previewLocalMedia\n\t            });\n\t        }, true);\n\t\n\t        return localMedia.start().then(function () {\n\t            streamReceivedHandler(localMedia);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Answer the call and start the process of obtaining media. This method is called automatically on the caller's\n\t     * side. This method must be called on the callee's side to indicate that the endpoint does wish to accept the\n\t     * call. The app will have a later opportunity, by passing a callback named previewLocalMedia, to approve or\n\t     * reject the call based on whether audio and/or video is working and is working at an acceptable level.\n\t     *\n\t     *     client.listen('call', function (evt) {\n\t     *         if (!evt.call.caller) {\n\t     *             evt.call.answer();\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.answer\n\t     * @fires respoke.Call#answer\n\t     * @param {object} [params]\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached. Corresponds to 'local-stream-received' event.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback indicating that the call is connected.\n\t     * This is fired once. Corresponds to 'connect' event.\n\t     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n\t     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n\t     * it was ended in a graceful manner. Corresponds to 'hangup' event.\n\t     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t     * This callback will be called when media is muted or unmuted.\n\t     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t     * for the user to give permission to start getting audio or video.\n\t     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t     * the approval was automatic.\n\t     * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n\t     * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n\t     * granted by the browser without asking the user to approve it.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {boolean} [params.receiveOnly] - Whether or not we accept media.\n\t     * @param {boolean} [params.sendOnly] - Whether or not we send media.\n\t     * @param {Array<RTCConstraints>} [params.constraints] - Pass in media constraints to specialize\n\t     * the media requested from the user.\n\t     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an html video element to have local\n\t     * video attached to it, instead of having a video element created.\n\t     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an html video element to have remote\n\t     * video attached to it, instead of having a video element created.\n\t     */\n\t    that.answer = function (params) {\n\t        log.debug('Call.answer', params);\n\t        params = params || {};\n\t\n\t        saveParameters(params);\n\t\n\t        pc.listen('stream-added', onRemoteStreamAdded, true);\n\t        pc.listen('stream-removed', onRemoteStreamRemoved, true);\n\t\n\t        pc.state.dispatch('answer', {\n\t            previewLocalMedia: previewLocalMedia,\n\t            approve: that.approve\n\t        });\n\t\n\t        /**\n\t         * The call was answered.\n\t         * @event respoke.Call#answer\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('answer');\n\t    };\n\t\n\t    /**\n\t     * Accept a request to modify the media on the call. This method should be called within the Call#modify\n\t     * event listener, which gives the developer or website user a chance to see what changes are proposed and\n\t     * to accept or reject them.\n\t     *\n\t     *     call.listen('modify', function (evt) {\n\t     *         evt.call.accept();\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.accept\n\t     * @fires respoke.Call#accept\n\t     * @private\n\t     * @param {object} [params]\n\t     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t     * wants to perform an action between local media becoming available and calling approve().\n\t     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t     * element with the local audio and/or video attached.\n\t     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the developer to receive the\n\t     * remote video element.\n\t     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for the developer to be notified about hangup.\n\t     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t     * required to flow peer-to-peer. If it cannot, the call will fail.\n\t     * @param {boolean} [params.receiveOnly] - Whether or not we accept media.\n\t     * @param {boolean} [params.sendOnly] - Whether or not we send media.\n\t     * @param {Array<RTCConstraints>} [params.constraints] - Information about the media for this call.\n\t     */\n\t    that.accept = that.answer;\n\t\n\t    /**\n\t     * Start the process of network and media negotiation. If the app passes in a callback named previewLocalMedia\n\t     * in order to allow the logged-in person a chance to base their decision to continue the call on whether\n\t     * audio and/or video is working correctly,\n\t     * this method must be called on both sides in order to begin the call. If call.approve() is called, the call\n\t     * will progress as expected. If call.reject() is called, the call will be aborted.\n\t     *\n\t     *     call.listen('local-stream-received', function (evt) {\n\t     *         if (userLikesVideo()) {\n\t     *             evt.call.approve();\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.approve\n\t     * @fires respoke.Call#approve\n\t     */\n\t    that.approve = function () {\n\t        log.debug('Call.approve');\n\t        /**\n\t         * Fired when the local media access is approved.\n\t         * @event respoke.Call#approve\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('approve');\n\t        pc.state.dispatch('approve', {\n\t            previewLocalMedia: previewLocalMedia\n\t        });\n\t\n\t        if (defModify && defModify.promise.isPending()) {\n\t            defModify.resolve(true);\n\t            defModify = undefined;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Listen for the remote side to remove media in the middle of the call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.onRemoteStreamRemoved\n\t     * @private\n\t     * @param {object}\n\t     */\n\t    function onRemoteStreamRemoved(evt) {\n\t        log.debug('pc event: remote stream removed');\n\t        pc.state.dispatch('removeRemoteMedia');\n\t    }\n\t\n\t    /**\n\t     * Listen for the remote side to add additional media in the middle of the call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.onRemoteStreamAdded\n\t     * @private\n\t     * @param {object}\n\t     * @fires respoke.Call#connect\n\t     */\n\t    function onRemoteStreamAdded(evt) {\n\t        var hasAudio = false;\n\t        var hasVideo = false;\n\t        var hasScreenShare = false;\n\t        var remoteMedia;\n\t\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        log.debug('received remote media', evt);\n\t\n\t        // This is the first remote media we have received. The one we currently have is a guess. Rip it\n\t        // out and replace it with reality.\n\t        if (that.incomingMediaStreams.length === 1 && that.incomingMediaStreams[0].temporary === true) {\n\t            // have to do it this way because assigning a blank array to that.incomingMediaStreams will\n\t            // clobber the methods like hasAudio that we have added to the array.\n\t            that.incomingMediaStreams.length = 0;\n\t        }\n\t        if (that.incomingMediaStreams.length) {\n\t            while (that.incomingMediaStreams.length) {\n\t                log.debug('onRemoteStreamAdded removing incoming stream', that.incomingMediaStreams[0]);\n\t                that.incomingMediaStreams.shift().stop();\n\t            }\n\t        }\n\t        hasAudio = evt.stream.getAudioTracks().length > 0;\n\t        hasVideo = evt.stream.getVideoTracks().length > 0;\n\t        // TODO this is not good enough long term.\n\t        hasScreenShare = hasVideo && that.target === 'screenshare';\n\t\n\t        remoteMedia = respoke.RemoteMedia({\n\t            element: that.videoRemoteElement,\n\t            stream: evt.stream,\n\t            hasScreenShare: hasScreenShare,\n\t            constraints: {\n\t                audio: hasAudio,\n\t                video: hasVideo\n\t            }\n\t        });\n\t        that.incomingMediaStreams.push(remoteMedia);\n\t\n\t        pc.state.dispatch('receiveRemoteMedia');\n\t\n\t        if (!hasReceivedRemoteMedia) {\n\t            hasReceivedRemoteMedia = true;\n\t            /**\n\t             * Indicates that either remote media stream has been added to the call or if no\n\t             * media is expected, the other side is receiving our media. This will fire once,\n\t             * when the remote media becomes available.\n\t             * @event respoke.Call#connect\n\t             * @type {respoke.Event}\n\t             * @property {Element} element - The HTML5 Video element with the remote stream attached.\n\t             * @property {respoke.RemoteMedia} stream - The incomingMedia property on the call.\n\t             * @property {string} name - The event name.\n\t             * @property {respoke.Call} target\n\t             */\n\t            that.fire('connect', {\n\t                stream: remoteMedia.stream,\n\t                element: remoteMedia.element\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Fires every time a new remote media stream is added to the call.\n\t         * @event respoke.Call#onRemoteMedia\n\t         * @type {respoke.Event}\n\t         * @property {Element} element - The HTML5 Video element with the remote stream attached.\n\t         * @property {respoke.RemoteMedia} stream - The incomingMedia property on the call.\n\t         * @property {string} name - The event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('remote-stream-received', {\n\t            stream: remoteMedia.stream,\n\t            element: remoteMedia.element\n\t        });\n\t    }\n\t\n\t    /**\n\t     * ## The plugin `respoke.MediaStats` must be loaded before using this method.\n\t     *\n\t     * Start the process of listening for a continuous stream of statistics about the flow of audio and/or video.\n\t     * Since we have to wait for both the answer and offer to be available before starting\n\t     * statistics, the library returns a promise for the stats object. The statistics object does not contain the\n\t     * statistics; rather it contains methods of interacting with the actions of obtaining statistics. To obtain\n\t     * the actual statistics one time, use stats.getStats(); use the onStats callback to obtain a continuous\n\t     * stream of statistics every `interval` seconds.  Returns null if stats module is not loaded.\n\t     *\n\t     *     call.getStats({\n\t     *         onStats: function (evt) {\n\t     *             console.log('Stats', evt.stats);\n\t     *         }\n\t     *     }).done(function () {\n\t     *         console.log('Stats started');\n\t     *     }, function (err) {\n\t     *         console.log('Call is already hung up.');\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.getStats\n\t     * @param {object} params\n\t     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive\n\t     * the stats. If no callback is provided, the call's report will contain stats but the developer will not\n\t     * receive them on the client-side.\n\t     * @param {respoke.Call.statsSuccessHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Call.errorHandler} [params.onError] - Error handler for this invocation of this method only.\n\t     * @returns {Promise<object>|null}\n\t     */\n\t    function getStats(params) {\n\t        if (pc && pc.getStats) {\n\t            that.listen('stats', params.onStats);\n\t            return pc.getStats(params);\n\t        }\n\t        return null;\n\t    }\n\t    if (respoke.MediaStats) {\n\t        that.getStats = getStats;\n\t    }\n\t\n\t    /**\n\t     * Return local video element with the logged-in endpoint's audio and/or video streams attached to it.\n\t     *\n\t     *     var el = call.getLocalElement();\n\t     *     container.append(el);\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.getLocalElement\n\t     * @returns {Video} An HTML5 video element.\n\t     */\n\t    that.getLocalElement = function () {\n\t        return that.outgoingMediaStreams[0] ? that.outgoingMediaStreams[0].element : undefined;\n\t    };\n\t\n\t    /**\n\t     * Return remote video element with the remote endpoint's audio and/or video streams attached to it.\n\t     *\n\t     *     var el = call.getRemoteElement();\n\t     *     container.append(el);\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.getRemoteElement\n\t     * @returns {Video} An HTML5 video element.\n\t     */\n\t    that.getRemoteElement = function () {\n\t        return that.incomingMediaStreams[0] ? that.incomingMediaStreams[0].element : undefined;\n\t    };\n\t\n\t    /**\n\t     * Set up the local media.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.streamReceivedHandler\n\t     * @param {respoke.LocalMedia} localMedia\n\t     * @private\n\t     */\n\t    function streamReceivedHandler(localMedia) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        pc.addLocalTracksFromStream(localMedia.stream);\n\t        if (typeof previewLocalMedia === 'function' && localMedia.element) {\n\t            previewLocalMedia(localMedia.element, that);\n\t        }\n\t\n\t        localMedia.listen('stop', function stopHandler(/* evt */) {\n\t            // remove the media from the call's outgoing streams\n\t\n\t            var idx = that.outgoingMediaStreams.indexOf(localMedia);\n\t            if (idx > -1) {\n\t                that.outgoingMediaStreams.splice(idx, 1);\n\t            }\n\t\n\t            // TODO: See about adding this back\n\t            // if (!that.outgoingMediaStreams.length && !that.incomingMediaStreams.length) {\n\t            //     that.hangup({ reason: 'last stream ended' });\n\t            // }\n\t        }, true);\n\t\n\t        /**\n\t         * Indicate that the call has received local media from the browser.\n\t         * @event respoke.Call#local-stream-received\n\t         * @type {respoke.Event}\n\t         * @property {Element} element\n\t         * @property {respoke.LocalMedia} stream\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('local-stream-received', {\n\t            element: localMedia.element,\n\t            stream: localMedia\n\t        });\n\t\n\t        /**\n\t         * This event indicates that local video has been unmuted.\n\t         * @event respoke.Call#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        localMedia.listen('mute', function (evt) {\n\t            that.fire('mute', {\n\t                type: evt.type,\n\t                muted: evt.muted\n\t            });\n\t        }, true);\n\t    }\n\t\n\t    /**\n\t     * Retrieve the constraints that describe the currently flowing outgoing media.\n\t     * TODO: we can probably use that.constraints instead\n\t     * @returns { audio, video }\n\t     * @private\n\t     */\n\t    function getOutgoingConstraints() {\n\t        return that.outgoingMediaStreams.reduce(function (constraints, localMedia) {\n\t            if (localMedia.temporary) {\n\t                return constraints;\n\t            }\n\t            localMedia.stream.getTracks().forEach(function (track) {\n\t                if (track.kind === 'audio') {\n\t                    constraints.audio = true;\n\t                } else {\n\t                    constraints.video = true;\n\t                }\n\t            });\n\t\n\t            return constraints;\n\t        }, { audio: false, video: false });\n\t    }\n\t\n\t    /**\n\t     * Renegotiate the call to have media that matches the passed constraints.\n\t     *\n\t     * @param {object} params\n\t     * @param {object|Array} params.constraints The constraints to renegotiate to\n\t     * @returns {Promise}\n\t     * @private\n\t     */\n\t    that.changeMedia = function changeMedia(params) {\n\t        log.debug('Call.changeMedia', params);\n\t        params = params || {};\n\t\n\t        if (!params.constraints || !params.constraints.length) {\n\t            return Q.reject(new Error('at least one set of constraints is required to change media'));\n\t        }\n\t\n\t        params.instanceId = instanceId;\n\t\n\t        pc.startModify({\n\t            constraints: params.constraints\n\t        });\n\t\n\t        defModify = Q.defer();\n\t        defModify.promise.then(function modifyAccepted() {\n\t            saveParameters(params);\n\t        });\n\t\n\t        return defModify.promise;\n\t    };\n\t\n\t    /**\n\t     * Renegotiate the call to add video. If a video track is already present\n\t     * on the call, no action will be taken and the promise will immediately resolve.\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.addVideo\n\t     * @returns {Promise}\n\t     * @private\n\t     */\n\t    that.addVideo = function () {\n\t        log.debug('Call.addVideo');\n\t        var outgoingConstraints = getOutgoingConstraints();\n\t\n\t        if (outgoingConstraints.video) {\n\t            log.debug('Call already contains an outgoing video track');\n\t            return Q.resolve();\n\t        }\n\t\n\t        return that.changeMedia({\n\t            constraints: [{\n\t                audio: outgoingConstraints.audio,\n\t                video: true\n\t            }]\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Renegotiate the call to remove video. If a video track is not already present\n\t     * on the call, no action will be taken and the promise will immediately resolve.\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.addVideo\n\t     * @returns {Promise}\n\t     * @private\n\t     */\n\t    that.removeVideo = function () {\n\t        log.debug('Call.removeVideo');\n\t        var outgoingConstraints = getOutgoingConstraints();\n\t\n\t        if (!outgoingConstraints.video) {\n\t            log.debug('Call does not contain an outgoing video track');\n\t            return Q.resolve();\n\t        }\n\t\n\t        return that.changeMedia({\n\t            constraints: [{\n\t                audio: outgoingConstraints.audio,\n\t                video: false\n\t            }]\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Renegotiate the call to add audio. If an audio track is already present\n\t     * on the call, no action will be taken and the promise will immediately resolve.\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.addVideo\n\t     * @returns {Promise}\n\t     * @private\n\t     */\n\t    that.addAudio = function () {\n\t        log.debug('Call.addAudio');\n\t        var outgoingConstraints = getOutgoingConstraints();\n\t\n\t        if (outgoingConstraints.audio) {\n\t            log.debug('Call already contains an outgoing audio track');\n\t            return Q.resolve();\n\t        }\n\t\n\t        return that.changeMedia({\n\t            constraints: [{\n\t                audio: true,\n\t                video: outgoingConstraints.video\n\t            }]\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Renegotiate the call to remove audio. If an audio track is not already present\n\t     * on the call, no action will be taken and the promise will immediately resolve.\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.addVideo\n\t     * @returns {Promise}\n\t     * @private\n\t     */\n\t    that.removeAudio = function () {\n\t        log.debug('Call.removeAudio');\n\t        var outgoingConstraints = getOutgoingConstraints();\n\t\n\t        if (!outgoingConstraints.audio) {\n\t            log.debug('Call does not contain an outgoing audio track');\n\t            return Q.resolve();\n\t        }\n\t\n\t        return that.changeMedia({\n\t            constraints: [{\n\t                audio: false,\n\t                video: outgoingConstraints.video\n\t            }]\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Get the direct connection on this call, if it exists.\n\t     *\n\t     *     var dc = call.getDirectConnection();\n\t     *     if (!dc) {\n\t     *         console.log(\"No direct connection has been started.\");\n\t     *     } else {\n\t     *         dc.sendMessage({message: 'hi'});\n\t     *     }\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.getDirectConnection\n\t     * @returns {respoke.DirectConnection}\n\t     */\n\t    that.getDirectConnection = function () {\n\t        return directConnection || null;\n\t    };\n\t\n\t    /**\n\t     * Remove a direct connection from the existing call. If there is no other media, this will hang up the call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.removeDirectConnection\n\t     * @private\n\t     * @param {object} params\n\t     * @arg {boolean} [params.skipModify] Do not restart media negotiation.\n\t     */\n\t    that.removeDirectConnection = function (params) {\n\t        params = params || {};\n\t        log.debug('Call.removeDirectConnection');\n\t\n\t        if (directConnection) {\n\t            directConnection.close({skipRemove: true});\n\t        }\n\t\n\t        if (!that.hasMedia()) {\n\t            log.debug('Hanging up because there are no local streams.');\n\t            that.hangup();\n\t            return;\n\t        }\n\t\n\t        if (params.skipModify === true) {\n\t            return;\n\t        }\n\t\n\t        pc.startModify({\n\t            directConnection: false\n\t        });\n\t        defModify = Q.defer();\n\t        defModify.promise.done(function onModifySuccess() {\n\t            defMedia.resolve();\n\t            defModify = undefined;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Add a direct connection to the existing call.\n\t     *\n\t     *     call.addDirectConnection({\n\t     *         onOpen: function (evt) {\n\t     *             console.log(\"Direct connection open!\");\n\t     *         }\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.addDirectConnection\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for the developer to be notified about\n\t     * closing the connection.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for the developer to be notified about\n\t     * opening the connection.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for the developer to be notified\n\t     * about incoming messages. Not usually necessary to listen to this event if you are already listening to\n\t     * respoke.Endpoint#message.\n\t     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess]\n\t     * @param {respoke.Client.errorHandler} [params.onError]\n\t     * @returns {Promise<respoke.DirectConnection>}\n\t     */\n\t    that.addDirectConnection = function (params) {\n\t        log.debug('Call.addDirectConnection');\n\t        pc.startModify({\n\t            directConnection: true\n\t        });\n\t        defModify = Q.defer();\n\t        return defModify.promise.then(function onModifySuccess() {\n\t            return actuallyAddDirectConnection(params);\n\t        }, function onModifyError(err) {\n\t            throw err;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Add a direct connection to the existing call.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.actuallyAddDirectConnection\n\t     * @private\n\t     * @param {object} params\n\t     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for the developer to be notified about\n\t     * closing the connection.\n\t     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for the developer to be notified about\n\t     * opening the connection.\n\t     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for the developer to be notified\n\t     * about incoming messages. Not usually necessary to listen to this event if you are already listening to\n\t     * respoke.Endpoint#message.\n\t     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess]\n\t     * @param {respoke.Client.errorHandler} [params.onError]\n\t     * @returns {Promise<respoke.DirectConnection>}\n\t     * @fires respoke.Client#direct-connection\n\t     * @fires respoke.Call#direct-connection\n\t     */\n\t    function actuallyAddDirectConnection(params) {\n\t        log.debug('Call.actuallyAddDirectConnection', params);\n\t        params = params || {};\n\t        defMedia.promise.then(params.onSuccess, params.onError);\n\t\n\t        if (directConnection && directConnection.isActive()) {\n\t            if (defMedia.promise.isPending()) {\n\t                defMedia.resolve(directConnection);\n\t            } else {\n\t                log.warn(\"Not creating a new direct connection.\");\n\t            }\n\t            return defMedia.promise;\n\t        }\n\t\n\t        params.instanceId = instanceId;\n\t        params.pc = pc;\n\t        params.call = that;\n\t\n\t        directConnection = respoke.DirectConnection(params);\n\t\n\t        directConnection.listen('close', function handleDirectConnectionClose() {\n\t            if (!that.hasMedia()) {\n\t                log.debug('Hanging up because there are no local streams.');\n\t                that.hangup();\n\t            } else {\n\t                that.removeDirectConnection({skipModify: true});\n\t            }\n\t        }, true);\n\t\n\t        directConnection.listen('accept', function handleDirectConnectionAccept() {\n\t            if (pc.state.caller === false) {\n\t                log.debug('Answering as a result of approval.');\n\t            } else {\n\t                defMedia.resolve(directConnection);\n\t            }\n\t        }, true);\n\t\n\t        directConnection.listen('open', function handleDirectConnectionOpen() {\n\t            pc.state.dispatch('receiveRemoteMedia');\n\t        }, true);\n\t\n\t        directConnection.listen('error', function handleDirectionConnectionError(err) {\n\t            defMedia.reject(new Error(err));\n\t        }, true);\n\t\n\t        that.remoteEndpoint.directConnection = directConnection;\n\t\n\t        /**\n\t         * This event is fired when the local end of the directConnection is available. It still will not be\n\t         * ready to send and receive messages until the 'open' event fires.\n\t         * @event respoke.Call#direct-connection\n\t         * @type {respoke.Event}\n\t         * @property {respoke.DirectConnection} directConnection\n\t         * @property {respoke.Endpoint} endpoint\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('direct-connection', {\n\t            directConnection: directConnection,\n\t            endpoint: that.remoteEndpoint\n\t        });\n\t\n\t        /**\n\t         * This event is fired when the logged-in endpoint is receiving a request to open a direct connection\n\t         * to another endpoint.  If the user wishes to allow the direct connection, calling\n\t         * evt.directConnection.accept() will allow the connection to be set up.\n\t         * @event respoke.Client#direct-connection\n\t         * @type {respoke.Event}\n\t         * @property {respoke.DirectConnection} directConnection\n\t         * @property {respoke.Endpoint} endpoint\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         * @private\n\t         */\n\t        client.fire('direct-connection', {\n\t            directConnection: directConnection,\n\t            endpoint: that.remoteEndpoint\n\t        });\n\t\n\t        if (pc.state.caller === true) {\n\t            directConnection.accept();\n\t        }\n\t\n\t        return defMedia.promise;\n\t    }\n\t\n\t    /**\n\t     * Close the direct connection.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.closeDirectConnection\n\t     */\n\t    that.closeDirectConnection = function () {\n\t        if (directConnection) {\n\t            directConnection.close();\n\t            directConnection = null;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n\t     * signal is not false and we have not received a hangup signal from the remote party.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.hangup\n\t     * @fires respoke.Call#hangup\n\t     * @param {object} params\n\t     * @arg {boolean} params.signal Optional flag to indicate whether to send or suppress sending\n\t     * a hangup signal to the remote side.\n\t     */\n\t    that.hangup = respoke.callOnce(function hangup(params) {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        params = params || {};\n\t        params.reason = params.reason || \"hangup method called.\";\n\t        pc.state.dispatch('hangup', params);\n\t    });\n\t\n\t    /**\n\t     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n\t     * signal is not false and we have not received a hangup signal from the remote party. This is an event\n\t     * handler added to the state machine via `once`.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.hangup\n\t     * @fires respoke.Call#hangup\n\t     * @private\n\t     */\n\t    var doHangup = respoke.callOnce(function doHangup() {\n\t        log.debug('hangup', that.caller);\n\t\n\t        that.outgoingMediaStreams.forEach(function (localMediaInstance) {\n\t            // only call stop on the localMediaInstance if it was constructed explicitly for the call\n\t            if (localMediaInstance !== params.outgoingMedia) {\n\t                localMediaInstance.stop();\n\t            }\n\t        });\n\t\n\t        if (directConnection) {\n\t            directConnection.close();\n\t            directConnection = null;\n\t        }\n\t\n\t        if (pc) {\n\t            pc.close({signal: (pc.state.receivedBye ? false : pc.state.signalBye)});\n\t        }\n\t\n\t        /**\n\t         * This event is fired when the call has hung up.\n\t         * @event respoke.Call#hangup\n\t         * @type {respoke.Event}\n\t         * @property {boolean} sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.Call} target\n\t         */\n\t        that.fire('hangup', {\n\t            reason: pc.state.hangupReason || \"No reason specified.\"\n\t        });\n\t\n\t        pc.state.ignore();\n\t        pc.ignore();\n\t        that.ignore();\n\t        pc = null;\n\t    });\n\t\n\t    /**\n\t     * Expose hangup as reject for approve/reject workflow.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.reject\n\t     * @param {object} params\n\t     */\n\t    that.reject = function () {\n\t        if (!pc) {\n\t            return;\n\t        }\n\t        pc.state.dispatch('reject', {reason: 'call.reject() called'});\n\t    };\n\t\n\t    /**\n\t     * Indicate whether a call is being setup or is in progress.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.isActive\n\t     * @returns {boolean}\n\t     */\n\t    that.isActive = function () {\n\t        return !!(pc && pc.isActive() && (\n\t            that.outgoingMediaStreams.length > 0 ||\n\t            that.incomingMediaStreams.length > 0 ||\n\t            (directConnection && directConnection.isActive())\n\t        ));\n\t    };\n\t\n\t    /**\n\t     * Set the estimated media status on incoming media.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.updateIncomingMediaEstimate\n\t     * @param {object} params\n\t     * @param {RTCSessionDescriptor} [params.sdp] - optional sdp to use to estimate media\n\t     * @param {RTCConstraints} [params.constraints] - optional constraints to use to estimate media\n\t     * @private\n\t     */\n\t    function updateIncomingMediaEstimate(params) {\n\t        if (pc.state.sendOnly) {\n\t            that.incomingMediaStreams.length = 0;\n\t            return;\n\t        }\n\t\n\t        if (!params.sdp && !params.constraints) {\n\t            throw new Error(\"Can't estimate incoming media without sdp or constraints\");\n\t        }\n\t\n\t        if (that.incomingMediaStreams.length === 0) {\n\t            that.incomingMediaStreams.push(respoke.RemoteMedia({\n\t                hasScreenShare: (that.target === 'screenshare'),\n\t                temporary: true\n\t            }));\n\t        }\n\t\n\t        if (params.sdp) {\n\t            if (that.incomingMediaStreams[0] && that.incomingMediaStreams[0].temporary) {\n\t                that.incomingMediaStreams[0].setSDP(params.sdp);\n\t            }\n\t        }\n\t\n\t        if (params.constraints) {\n\t            if (that.incomingMediaStreams[0] && that.incomingMediaStreams[0].temporary) {\n\t                that.incomingMediaStreams[0].setConstraints(params.constraints);\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Set the estimated media status on outgoing media. For this method, by the time we have constraints, we're\n\t     * already calling getUserMedia so we will have exactly the right information. No need to use constraints\n\t     * to estimate.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.updateOutgoingMediaEstimate\n\t     * @param {object} params\n\t     * @param {RTCSessionDescriptor} [params.sdp] - optional sdp to use to estimate media\n\t     * @param {RTCConstraints} [params.constraints] - optional constraints to use to estimate media\n\t     * @private\n\t     */\n\t    function updateOutgoingMediaEstimate(params) {\n\t        if (pc.state.receiveOnly) {\n\t            that.outgoingMediaStreams.length = 0;\n\t            that.constraints = [];\n\t            return;\n\t        }\n\t\n\t        if (!params.sdp && !params.constraints) {\n\t            throw new Error(\"Can't estimate outgoing media without sdp or constraints\");\n\t        }\n\t\n\t        if (that.outgoingMediaStreams.length === 0) {\n\t            that.outgoingMediaStreams.push(respoke.LocalMedia({\n\t                instanceId: instanceId,\n\t                temporary: true,\n\t                source: params.source\n\t            }));\n\t        }\n\t\n\t        if (params.sdp) {\n\t            if (that.outgoingMediaStreams[0] && that.outgoingMediaStreams[0].temporary) {\n\t                that.outgoingMediaStreams[0].setSDP(params.sdp);\n\t            }\n\t        }\n\t\n\t        if (params.constraints) {\n\t            if (that.outgoingMediaStreams[0] && that.outgoingMediaStreams[0].temporary) {\n\t                that.outgoingMediaStreams[0].setConstraints(params.constraints);\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Save the offer so we can tell the browser about it after the PeerConnection is ready.\n\t     * Set the estimated media status on incoming and outgoing media.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.listenOffer\n\t     * @param {object} evt\n\t     * @param {object} evt.signal - The offer signal including the sdp\n\t     * @private\n\t     * @fires respoke.Call#modify\n\t     */\n\t    function listenOffer(evt) {\n\t        log.debug('listenOffer', evt.signal);\n\t\n\t        that.sessionId = evt.signal.sessionId;\n\t        pc.state.receiveOnly = respoke.sdpHasSendOnly(evt.signal.sessionDescription.sdp);\n\t        pc.state.sendOnly = respoke.sdpHasReceiveOnly(evt.signal.sessionDescription.sdp);\n\t        pc.state.once('connecting:entry', function () {\n\t            if (!pc.state.caller) {\n\t                pc.processOffer(evt.signal.sessionDescription);\n\t            }\n\t        });\n\t\n\t        // Only do this if we're still trying to guess what media is coming in.\n\t        // TODO not good enough for media renegotiation\n\t        updateIncomingMediaEstimate({sdp: evt.signal.sessionDescription});\n\t\n\t        /*\n\t         * Always overwrite constraints for callee on every offer, since answer() and accept() will\n\t         * always be called after parsing the SDP. However, if the caller isn't sending any media,\n\t         * use audio & video as our estimate.\n\t         * TODO not good enough for media renegotiation\n\t         */\n\t        // If sendOnly, we can't rely on the offer for media estimate. It doesn't have any media in it!\n\t        if (pc.state.sendOnly) {\n\t            updateOutgoingMediaEstimate({constraints: {\n\t                audio: true,\n\t                video: true\n\t            }});\n\t        } else {\n\t            updateOutgoingMediaEstimate({sdp: evt.signal.sessionDescription});\n\t        }\n\t\n\t        if (that.outgoingMedia) {\n\t            log.info(\"Default outgoingMedia constraints\", that.outgoingMedia.constraints);\n\t        }\n\t\n\t        pc.state.dispatch('receiveOffer', {\n\t            previewLocalMedia: previewLocalMedia,\n\t            approve: that.approve\n\t        });\n\t    }\n\t\n\t    /**\n\t     * If video is muted, unmute. If not muted, mute.\n\t     * @deprecated\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.toggleVideo\n\t     */\n\t    that.toggleVideo = function () {\n\t        if (that.isActive()) {\n\t            if (!videoIsMuted) {\n\t                that.muteVideo();\n\t            } else {\n\t                that.unmuteVideo();\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * If audio is muted, unmute. If not muted, mute.\n\t     * @deprecated\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.toggleAudio\n\t     */\n\t    that.toggleAudio = function () {\n\t        if (that.isActive()) {\n\t            if (!audioIsMuted) {\n\t                that.muteAudio();\n\t            } else {\n\t                that.unmuteAudio();\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Indicate whether the call has media of any type flowing in either direction.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.hasMedia\n\t     * @returns {boolean}\n\t     */\n\t    that.hasMedia = function () {\n\t        var local;\n\t        var remote;\n\t\n\t        if (!pc || !pc.getLocalStreams) {\n\t            // PeerConnection.init() has not been called yet\n\t            return false;\n\t        }\n\t\n\t        local = pc.getLocalStreams();\n\t        remote = pc.getRemoteStreams();\n\t\n\t        if (directConnection && directConnection.isActive()) {\n\t            return true;\n\t        }\n\t\n\t        return (local.length > 0 || remote.length > 0);\n\t    };\n\t\n\t    /**\n\t     * Mute all local video streams.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.muteVideo\n\t     * @fires respoke.Call#mute\n\t     */\n\t    that.muteVideo = function () {\n\t        if (videoIsMuted) {\n\t            return;\n\t        }\n\t        that.outgoingMedia.muteVideo();\n\t        videoIsMuted = true;\n\t    };\n\t\n\t    /**\n\t     * Unmute all local video streams.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.unmuteVideo\n\t     * @fires respoke.Call#mute\n\t     */\n\t    that.unmuteVideo = function () {\n\t        if (!videoIsMuted) {\n\t            return;\n\t        }\n\t        that.outgoingMedia.unmuteVideo();\n\t        videoIsMuted = false;\n\t    };\n\t\n\t    /**\n\t     * Mute all local audio streams.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.muteAudio\n\t     * @fires respoke.Call#mute\n\t     */\n\t    that.muteAudio = function () {\n\t        if (audioIsMuted) {\n\t            return;\n\t        }\n\t        that.outgoingMedia.muteAudio();\n\t        audioIsMuted = true;\n\t    };\n\t\n\t    /**\n\t     * Unmute all local audio streams.\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.unmuteAudio\n\t     * @fires respoke.Call#mute\n\t     */\n\t    that.unmuteAudio = function () {\n\t        if (!audioIsMuted) {\n\t            return;\n\t        }\n\t\n\t        that.outgoingMedia.unmuteAudio();\n\t        audioIsMuted = false;\n\t    };\n\t\n\t    /**\n\t     * Send DTMF tones to the first audio track on the call. This allows interaction with a phone system expecting keys\n\t     * to be pressed on a normal phone, such as when calling a company for customer support and having to \"Press 1 for English\".\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.sendTones\n\t     * @param {object} params\n\t     * @param {string} params.tones - The tones to send. Can be any combination of the characters '0123456789ABCD#*', or\n\t     *  a ',' (comma) to insert a 2 second pause before sending the next tone.\n\t     * @param {number} [params.duration] - Optional number in milliseconds to indicate how long to play each tone. This\n\t     *  value needs to be between 40 and 6000. Defaults to 100.\n\t     * @param {number} [params.gap] - Optional number in mlliseconds to indicate the gap between playing the tones.\n\t     *  This value needs to be larger than 30. Defaults to 70.\n\t     * @param {respoke.Call.onSuccess} [params.onSuccess] - Callback called when all requested DTMF tones have been played.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback called when an error occurs while playing back the DTMF\n\t     *  tones, or when the request has been cancelled.\n\t     * @fires respoke.Call#tone-sent\n\t     * @fires respoke.Call#tone-sending-complete\n\t     * @returns {Promise}\n\t     */\n\t    that.sendTones = function (params) {\n\t        return pc.sendTones(params);\n\t    };\n\t\n\t    /**\n\t     * Cancels playback of all queued tones on the first audio track in a stream\n\t     * @memberof! respoke.Call\n\t     * @method respoke.Call.cancelTones\n\t     * @param {respoke.Call.onSuccess} [params.onSuccess] - Callback called when all the outstanding DTMF tones that\n\t     *  have not yet been played have been cancelled.\n\t     * @param {respoke.Call.onError} [params.onError] - Callback called when an error occurs while attempting to cancel\n\t     *  outstanding DTMF tones.\n\t     * @fires respoke.Call#tone-sending-cancelled\n\t     * @returns {Promise}\n\t     */\n\t    that.cancelTones = function (params) {\n\t        return pc.cancelTones(params);\n\t    };\n\t\n\t    pc.state.once('terminated:entry', function (evt) {\n\t        doHangup();\n\t    }, true);\n\t\n\t    /**\n\t     * Set the estimated media status on incoming media.\n\t     */\n\t    that.listen('signal-answer', function handleAnswerSignal(evt) {\n\t        log.debug('Call handleAnswerSignal', evt);\n\t\n\t        that.hasDataChannel = respoke.sdpHasDataChannel(evt.signal.sessionDescription.sdp);\n\t        updateIncomingMediaEstimate({sdp: evt.signal.sessionDescription});\n\t    });\n\t\n\t    that.listen('signal-offer', function handleOfferSignal(evt) {\n\t        log.debug('Call handleOfferSignal', evt);\n\t\n\t        if (pc.state.getState() === 'idle') {\n\t            pc.state.once('preparing:entry', function () {\n\t                listenOffer(evt);\n\t            });\n\t        } else {\n\t            listenOffer(evt);\n\t        }\n\t    }, true);\n\t\n\t    /**\n\t     * Save the hangup reason and hang up.\n\t     */\n\t    that.listen('signal-hangup', function handleHangupSignal(evt) {\n\t        log.debug('Call handleHangupSignal', evt);\n\t\n\t        if (!pc) {\n\t            return;\n\t        }\n\t\n\t        pc.report.callStoppedReason = evt.signal.reason || \"Remote side hung up\";\n\t        pc.state.receivedBye = true;\n\t        pc.state.dispatch('hangup', {signal: false, reason: pc.report.callStoppedReason});\n\t    }, true);\n\t\n\t    /**\n\t     * Save the answer and tell the browser about it.\n\t     */\n\t    that.listen('signal-modify', function handleModifySignal(evt) {\n\t        log.debug('Call handleModifySignal', evt);\n\t\n\t        if (evt.signal.action === 'initiate') {\n\t            defModify = Q.defer();\n\t            pc.state.dispatch('modify', {receive: true});\n\t        }\n\t    }, true);\n\t\n\t    /**\n\t     * Ignore the modify.\n\t     */\n\t    pc.listen('modify-reject', function handlePeerConnectModifyReject(evt) {\n\t        log.debug('Call handlePeerConnectModifyReject', evt);\n\t\n\t        if (evt.signal.action !== 'initiate') {\n\t            defMedia.reject(evt.err);\n\t            defModify.reject(evt.err);\n\t            defModify = undefined;\n\t        }\n\t    }, true);\n\t\n\t    /**\n\t     * Set up state and media for the modify.\n\t     */\n\t    pc.listen('modify-accept', function handlePeerConnectionModifyAccept(evt) {\n\t        log.debug('Call handlePeerConnectionModifyAccept', evt);\n\t\n\t        pc.state.dispatch('accept');\n\t\n\t        if (evt.signal.action !== 'initiate') {\n\t            defModify.resolve(); // resolved later for callee\n\t            defModify = undefined;\n\t            return;\n\t        }\n\t\n\t        // callee only from here down\n\t\n\t        // init the directConnection if necessary. We don't need to do anything with\n\t        // audio or video right now.\n\t        if (evt.signal.directConnection === true) {\n\t            actuallyAddDirectConnection().done(function successHandler(dc) {\n\t                directConnection = dc;\n\t                directConnection.accept();\n\t            });\n\t        } else if (evt.signal.directConnection === false) {\n\t            if (directConnection) {\n\t                that.removeDirectConnection({skipModify: true});\n\t                defMedia.resolve(false);\n\t            }\n\t        }\n\t        pc.state.needDirectConnection = typeof evt.signal.directConnection === 'boolean' ?\n\t            evt.signal.directConnection : null;\n\t        that.outgoingMedia.constraints = evt.signal.constraints || that.outgoingMedia.constraints;\n\t    }, true);\n\t\n\t    /**\n\t     * Send received ice candidates to the peer connection for processing\n\t     */\n\t    that.listen('signal-icecandidates', function handleIceCandidatesSignal(evt) {\n\t        log.debug('Call handleIceCandidatesSignal', evt);\n\t\n\t        if (!pc || !evt.signal.iceCandidates || !evt.signal.iceCandidates.length) {\n\t            return;\n\t        }\n\t        evt.signal.iceCandidates.forEach(function processCandidate(candidate) {\n\t            if (!pc) {\n\t                return;\n\t            }\n\t            pc.addRemoteCandidate({candidate: candidate});\n\t        });\n\t    }, true);\n\t\n\t    that.listen('answer', function handleAnswer(evt) {\n\t        log.debug('Call handleAnswer', evt);\n\t\n\t        var mediaPromises = [];\n\t\n\t        if (pc.state.receiveOnly || pc.state.needDirectConnection) {\n\t            that.outgoingMediaStreams.length = 0;\n\t            return;\n\t        }\n\t\n\t        /*\n\t         * By the time we get to here, we could be in a couple of states.\n\t         *\n\t         * If receiveOnly is set to true, we could possibly have constraints (if the developer used the API wrong)\n\t         * but we will not have any media in that.outgoingMediaStreams. We should unset that.constraints and skip\n\t         * building any local media.\n\t         *\n\t         * If we have never received any constraints, and receiveOnly is NOT set to true, we will have an estimate\n\t         * at that.outgoingMediaStreams[0] with temporary set to true. This estimate was set by parsing the SDP.\n\t         *\n\t         * If we have received one or more constraints, that.constraints array will contain the most recent set\n\t         * AND we will have an estimate at that.outgoingMediaStreams[0] with temporary set to true. We must completely\n\t         * rebuild that.outgoingMediaStreams from that.constraints.\n\t         */\n\t        if (pc.state.receiveOnly) {\n\t            that.outgoingMediaStreams.length = 0;\n\t            that.constraints = [];\n\t            return;\n\t        }\n\t\n\t        if (that.constraints.length === 0) {\n\t            // We didn't get told what to do by constraints; use our guess.\n\t            that.outgoingMediaStreams[0].temporary = undefined;\n\t        } else if (that.outgoingMediaStreams.length > 0 && that.outgoingMediaStreams[0].temporary) {\n\t            // We got told what to do. Discard our guess. It's OK for that.outgoingMediaStreams to be empty now.\n\t            that.outgoingMediaStreams.shift();\n\t        }\n\t\n\t        // If outgoingMedia is passed into the Call then there is no need to build the LocalMedia here\n\t        if (params.outgoingMedia) {\n\t            return;\n\t        }\n\t\n\t        if (that.constraints.length > 0) {\n\t            if (pc.state.isModifying) {\n\t                pc.removeLocalTracks();\n\t            }\n\t            that.outgoingMediaStreams.length = 0;\n\t            that.constraints.forEach(function (constraint) {\n\t                if (!respoke.constraintsHasAudio(constraint) && !respoke.constraintsHasVideo(constraint)) {\n\t                    return;\n\t                }\n\t                mediaPromises.push(buildLocalMedia(constraint));\n\t            });\n\t        } else if (that.outgoingMediaStreams.length > 0) {\n\t            that.outgoingMediaStreams.forEach(function (localMediaInstance) {\n\t                mediaPromises.push(buildLocalMedia(localMediaInstance));\n\t            });\n\t        } else {\n\t            throw new Error(\"I have no idea what type of media I am supposed to build.\");\n\t        }\n\t\n\t        // These errors are handled elsewhere.\n\t        Q.all(mediaPromises).done(function () {\n\t            pc.state.dispatch('receiveLocalMedia');\n\t        }, function (err) {\n\t            pc.state.dispatch('reject', {reason: 'media stream error'});\n\t            pc.report.callStoppedReason = err.message;\n\t            /**\n\t             * This event is fired on errors that occur during call setup or media negotiation.\n\t             * @event respoke.Call#error\n\t             * @type {respoke.Event}\n\t             * @property {string} reason - A human readable description about the error.\n\t             * @property {respoke.Call} target\n\t             * @property {string} name - the event name.\n\t             */\n\t            that.fire('error', {\n\t                reason: err.message\n\t            });\n\t        });\n\t    }, true);\n\t\n\t    if (pc.state.needDirectConnection !== true) {\n\t        pc.state.once('preparing:entry', function () {\n\t            /**\n\t             * This event provides notification for when an incoming call is being received.  If the user wishes\n\t             * to allow the call, the app should call evt.call.answer() to answer the call.\n\t             * @event respoke.Client#call\n\t             * @type {respoke.Event}\n\t             * @property {respoke.Call} call\n\t             * @property {respoke.Endpoint} endpoint\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.Client} target\n\t             */\n\t            client.fire('call', {\n\t                endpoint: that.remoteEndpoint,\n\t                call: that\n\t            });\n\t        }, true);\n\t    }\n\t\n\t    pc.state.listen('idle:exit', function (evt) {\n\t        saveParameters(params);\n\t    });\n\t\n\t    /**\n\t     * Set up promises. If we're not the caller, we need to listen for approval AND\n\t     * the remote SDP to come in before we can act on the call. Save parameters sent\n\t     * in with the constructor, then delete them off the call. If this call was initiated\n\t     * with a DirectConnection, set it up so answer() will be the approval mechanism.\n\t     */\n\t    pc.state.listen('preparing:entry', function (evt) {\n\t        if (defModify !== undefined) {\n\t            defMedia = Q.defer();\n\t        }\n\t\n\t        pc.init(); // instantiates RTCPeerConnection, can't call on modify\n\t        if (defModify === undefined && pc.state.needDirectConnection === true) {\n\t            actuallyAddDirectConnection(params);\n\t        }\n\t\n\t        if (params.outgoingMedia) {\n\t            streamReceivedHandler(params.outgoingMedia);\n\t            pc.state.dispatch('receiveLocalMedia');\n\t        }\n\t\n\t        if (pc.state.caller === true) {\n\t            that.answer();\n\t        }\n\t    }, true);\n\t\n\t    signalingChannel.getTurnCredentials().then(function (result) {\n\t        if (!pc) {\n\t            throw new Error(\"Already hung up.\");\n\t        }\n\t        if (!result) {\n\t            log.warn(\"Relay service not available.\");\n\t            pc.servers = {iceServers: []};\n\t        } else {\n\t            pc.servers = {iceServers: result};\n\t        }\n\t    }).fin(function () {\n\t        if (!pc) {\n\t            throw new Error(\"Already hung up.\");\n\t        }\n\t        pc.state.dispatch('initiate', {\n\t            caller: that.caller\n\t        });\n\t    }).done(null, function (err) {\n\t        if (err.message !== \"Already hung up.\") {\n\t            log.debug('Unexpected exception', err);\n\t        }\n\t    });\n\t\n\t    return that;\n\t}; // End respoke.Call\n\t\n\t/**\n\t * Handle an error that resulted from a method call.\n\t * @callback respoke.Call.errorHandler\n\t * @param {Error} err\n\t */\n\t/**\n\t * Handle the successful kick-off of stats on a call.\n\t * @callback respoke.Call.statsSuccessHandler\n\t * @param {respoke.MediaStatsParser} statsParser\n\t */\n\t/**\n\t * Handle obtaining media successfully.\n\t * @callback respoke.Call.mediaSuccessHandler\n\t * @param {respoke.LocalMedia} localMedia\n\t */\n\t/**\n\t * When on a call, receive local media when it becomes available. This is what you will need to provide if you want\n\t * to show the user their own video during a call. This callback is called every time\n\t * respoke.Call#local-stream-received is fired.\n\t * @callback respoke.Call.onLocalMedia Callback for receiving an HTML5 Video\n\t * element with the local audio and/or video attached.\n\t * @param {respoke.Event} evt\n\t * @param {Element} evt.element\n\t * @param {respoke.LocalMedia} - The outgoingMedia property on the call.\n\t * @param {string} evt.name - The event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When on a call, receive remote media when it becomes available. This is what you will need to provide if you want\n\t * to show the user the other party's video during a call. This callback is called every time\n\t * respoke.Call#connect is fired.\n\t * @callback respoke.Call.onConnect\n\t * @param {respoke.Event} evt\n\t * @param {Element} evt.element - the HTML5 Video element with the new stream attached.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When a call is in setup or media renegotiation happens. This callback will be called every time\n\t * respoke.Call#error.\n\t * @callback respoke.Call.onError\n\t * @param {respoke.Event} evt\n\t * @param {boolean} evt.reason - A human-readable description of the error.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When on a call, receive notification the call has been hung up. This callback is called every time\n\t * respoke.Call#hangup is fired.\n\t * @callback respoke.Call.onHangup\n\t * @param {respoke.Event} evt\n\t * @param {boolean} evt.sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * Called when changing the mute state on any type of media. This callback will be called when media is muted or\n\t * unmuted. This callback is called every time respoke.Call#mute is fired.\n\t * @callback respoke.Call.onMute\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * Called when the callee answers the call. This callback is called every time respoke.Call#answer is fired.\n\t * @callback respoke.Call.onAnswer\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * Called when the user approves local media. This callback will be called whether or not the approval was based\n\t * on user feedback. I. e., it will be called even if the approval was automatic. This callback is called every time\n\t * respoke.Call#approve is fired.\n\t * @callback respoke.Call.onApprove\n\t * @param {respoke.Event} evt\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When setting up a call, receive notification that the browser has granted access to media.  This callback is\n\t * called every time respoke.Call#allow is fired.\n\t * @callback respoke.Call.onAllow\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * When setting up a call, receive notification that the app has asked the browser for permission to get audio or\n\t * video and is waiting on the browser to grant or reject permission. This callback will be called every time\n\t * respoke.Call#requesting-media is fired.\n\t * @callback respoke.Call.onRequestingMedia\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.name - the event name.\n\t * @param {respoke.Call} evt.target\n\t */\n\t/**\n\t * The use of stats requires an additional module to Respoke. When on a call, receive periodic statistical\n\t * information about the call, including the codec, lost packets, and bandwidth being consumed. This callback is\n\t * called every time respoke.Call#stats is fired.\n\t * @callback respoke.MediaStatsParser.statsHandler\n\t * @param {respoke.Event} evt\n\t * @param {respoke.MediaStats} evt.stats - an object with stats in it.\n\t * @param {respoke.Call} evt.target\n\t * @param {string} evt.name - the event name.\n\t */\n\t/**\n\t * When on a call, receive local media when it becomes available. This is what you will need to provide if you want\n\t * to allow the user to preview and approve or reject their own video before a call. If this callback is provided,\n\t * Respoke will wait for call.answer() to be called before proceeding. If this callback is not provided,\n\t * Respoke will proceed without waiting for user input. This callback is called every time\n\t * respoke.Call#local-stream-received is fired.\n\t * @callback respoke.Call.previewLocalMedia\n\t * @param {object} element - the HTML5 Video element with the new stream attached.\n\t * @param {respoke.Call} call\n\t */\n\t/**\n\t * Called when a tone is sent on an audio track. This callback is called every time respoke.Call#tone-sent is fired.\n\t * @callback respoke.Call.onToneSent\n\t * @param {respoke.Event} evt\n\t * @param {string} evt.tone\n\t * @param {number} evt.duration\n\t * @param {number} evt.gap\n\t */\n\t/**\n\t * Called when the playback queue of tones has started.\n\t * This callback is called every time respoke.Call#tone-sending-started is fired.\n\t * @callback respoke.Call.onToneSendingStarted\n\t * @param {respoke.Event} evt\n\t * @param {object} evt.target\n\t */\n\t/**\n\t * Receive the DirectConnection.\n\t * @callback respoke.Call.directConnectionSuccessHandler\n\t * @param {respoke.DirectConnection} directConnection\n\t */\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar respoke = __webpack_require__(1);\n\tvar log = respoke.log;\n\tvar Q = respoke.Q;\n\t\n\t/**\n\t * A wrapper around the stream from `getUserMedia`,\n\t * which is attached to a call at `call.outgoingMedia`.\n\t *\n\t * @class respoke.LocalMedia\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {object} [params.constraints]\n\t * @param {HTMLVideoElement} params.element - Pass in an optional html video element to have local\n\t * video attached to it.\n\t * @returns {respoke.LocalMedia}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    var that = respoke.EventEmitter(params);\n\t\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.LocalMedia';\n\t    /**\n\t     * Respoke media ID (different from a `MediaStream.id`).\n\t     * @memberof! respoke.LocalMedia\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = respoke.makeGUID();\n\t    /**\n\t     * The HTML element with video attached.\n\t     * @memberof! respoke.LocalMedia\n\t     * @name element\n\t     * @type {HTMLVideoElement}\n\t     */\n\t    that.element = params.element;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name hasScreenShare\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var hasScreenShare = params.hasScreenShare;\n\t    delete params.hasScreenShare;\n\t\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name screenShareSource\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var screenShareSource = params.source;\n\t    delete params.source;\n\t\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name sdpHasAudio\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasAudio = false;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name sdpHasVideo\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasVideo = false;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name sdpHasDataChannel\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasDataChannel = false;\n\t    /**\n\t     * A timer to make sure we only fire {respoke.LocalMedia#requesting-media} if the browser doesn't\n\t     * automatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.\n\t     * @memberof! respoke.LocalMedia\n\t     * @name allowTimer\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var allowTimer = 0;\n\t    /**\n\t     * @memberof! respoke.LocalMedia\n\t     * @name mediaOptions\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var mediaOptions = {\n\t        optional: [\n\t            { DtlsSrtpKeyAgreement: true },\n\t            { RtpDataChannels: false }\n\t        ]\n\t    };\n\t\n\t    /**\n\t     * The local `MediaStream` from `getUserMedia()`.\n\t     * @memberof! respoke.LocalMedia\n\t     * @name stream\n\t     * @type {RTCMediaStream}\n\t     */\n\t    that.stream = null;\n\t\n\t    /**\n\t     * The media deferred whose promise is returned from localMedia.start and resolved with the stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @name deferred\n\t     * @type {object}\n\t     * @private\n\t     */\n\t    var deferred = Q.defer();\n\t\n\t    /**\n\t     * Save the local stream. Kick off SDP creation.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.onReceiveUserMedia\n\t     * @private\n\t     * @param {RTCMediaStream} theStream\n\t     */\n\t    function onReceiveUserMedia(theStream) {\n\t        that.stream = theStream;\n\t        clearTimeout(allowTimer);\n\t        /**\n\t         * The user has approved the request for media. Any UI changes made to remind the user to click Allow\n\t         * should be canceled now. This event is the same as the `onAllow` callback.  This event gets fired\n\t         * even if the allow process is automatic, i. e., permission and media is granted by the browser\n\t         * without asking the user to approve it.\n\t         * @event respoke.LocalMedia#allow\n\t         * @type {respoke.Event}\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         */\n\t        that.fire('allow');\n\t        log.debug('User gave permission to use media.');\n\t        log.debug('onReceiveUserMedia');\n\t\n\t        that.element = that.element || document.createElement('video');\n\t\n\t        that.stream.numPc = 1;\n\t\n\t        attachMediaStream(that.element, that.stream);\n\t        // We won't want our local video outputting audio.\n\t        that.element.muted = true;\n\t        that.element.autoplay = true;\n\t\n\t        // perform cleanup on the LocalMedia instance if the underlying stream has ended\n\t        that.stream.addEventListener('ended', that.stop, false);\n\t        deferred.resolve();\n\t    }\n\t\n\t    /**\n\t     * Expose getAudioTracks.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.getAudioTracks\n\t     */\n\t    that.getAudioTracks = function () {\n\t        if (that.stream) {\n\t            return that.stream.getAudioTracks();\n\t        }\n\t        return [];\n\t    };\n\t\n\t    /**\n\t     * Expose getVideoTracks.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.getVideoTracks\n\t     */\n\t    that.getVideoTracks = function () {\n\t        if (that.stream) {\n\t            return that.stream.getVideoTracks();\n\t        }\n\t        return [];\n\t    };\n\t\n\t    /**\n\t     * Create the RTCPeerConnection and add handlers. Process any offer we have already received.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.requestMedia\n\t     * @private\n\t     */\n\t    function requestMedia() {\n\t        log.debug('LocalMedia.requestMedia', that.constraints);\n\t\n\t        if (!that.constraints) {\n\t            deferred.reject(new Error('No constraints.'));\n\t            return;\n\t        }\n\t\n\t        if (respoke.useFakeMedia === true) {\n\t            that.constraints.fake = true;\n\t        }\n\t\n\t        allowTimer = setTimeout(function delayPermissionsRequest() {\n\t            /**\n\t             * The browser is asking for permission to access the User's media. This would be an ideal time\n\t             * to modify the UI of the application so that the user notices the request for permissions\n\t             * and approves it.\n\t             * @event respoke.LocalMedia#requesting-media\n\t             * @type {respoke.Event}\n\t             * @property {string} name - the event name.\n\t             * @property {respoke.LocalMedia} target\n\t             */\n\t            that.fire('requesting-media');\n\t        }, 500);\n\t\n\t        if (respoke.constraintsHasScreenShare(that.constraints)) {\n\t            if (respoke.isNwjs || (respoke.needsChromeExtension && respoke.hasChromeExtension)) {\n\t                respoke.chooseDesktopMedia({source: screenShareSource}, function (params) {\n\t                    if (!params.sourceId) {\n\t                        deferred.reject(new Error(\"Error trying to get screensharing source: \" + params.error));\n\t                        return;\n\t                    }\n\t                    that.constraints.video.mandatory.chromeMediaSourceId = params.sourceId;\n\t                    log.debug(\"Running getUserMedia with constraints\", that.constraints);\n\t                    getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n\t                });\n\t                return;\n\t            } else if (respoke.needsFirefoxExtension && respoke.hasFirefoxExtension) {\n\t                log.debug(\"Running getUserMedia with constraints\", that.constraints);\n\t                getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n\t                return;\n\t            } else {\n\t                deferred.reject(new Error(\"Screen sharing not implemented on this platform yet.\"));\n\t                return;\n\t            }\n\t        }\n\t        log.debug(\"Running getUserMedia with constraints\", that.constraints);\n\t        getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n\t    }\n\t\n\t    /**\n\t     * Handle any error that comes up during the process of getting user media.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.onUserMediaError\n\t     * @private\n\t     * @param {object}\n\t     */\n\t    function onUserMediaError(p) {\n\t        log.debug('Local media error.', p);\n\t        var errorMessage = p.code === 1 ? \"Permission denied.\" : \"Unknown.\";\n\t        deferred.reject(new Error(\"Error getting user media: \" + errorMessage));\n\t    }\n\t\n\t    /**\n\t     * Whether the video stream is muted, or undefined if no stream of this type exists.\n\t     *\n\t     * All video tracks must be muted for this to return `false`.\n\t     * @returns boolean\n\t     */\n\t    that.isVideoMuted = function () {\n\t        if (!that.stream || !that.stream.getVideoTracks().length) {\n\t            return undefined;\n\t        }\n\t\n\t        return that.stream.getVideoTracks().every(function (track) {\n\t            return !track.enabled;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Mute local video stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.muteVideo\n\t     * @fires respoke.LocalMedia#mute\n\t     */\n\t    that.muteVideo = function () {\n\t        if (that.isVideoMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n\t            track.enabled = false;\n\t        });\n\t        /**\n\t         * Indicate that the mute status of local audio or video has changed.\n\t         * @event respoke.LocalMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'video',\n\t            muted: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Unmute local video stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.unmuteVideo\n\t     * @fires respoke.LocalMedia#mute\n\t     */\n\t    that.unmuteVideo = function () {\n\t        if (!that.isVideoMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n\t            track.enabled = true;\n\t        });\n\t        /**\n\t         * Indicate that the mute status of local audio or video has changed.\n\t         * @event respoke.LocalMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'video',\n\t            muted: false\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Whether the audio stream is muted, or undefined if no track of this type exists.\n\t     *\n\t     * All audio tracks must be muted for this to return `false`.\n\t     * @returns boolean\n\t     */\n\t    that.isAudioMuted = function () {\n\t        if (!that.stream || !that.stream.getAudioTracks().length) {\n\t            return undefined;\n\t        }\n\t        return that.stream.getAudioTracks().every(function (track) {\n\t            return !track.enabled;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Mute local audio stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.muteAudio\n\t     * @fires respoke.LocalMedia#mute\n\t     */\n\t    that.muteAudio = function () {\n\t        if (that.isAudioMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n\t            track.enabled = false;\n\t        });\n\t        /**\n\t         * Indicate that the mute status of local audio or video has changed.\n\t         * @event respoke.LocalMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'audio',\n\t            muted: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Unmute local audio stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.unmuteAudio\n\t     * @fires respoke.LocalMedia#mute\n\t     */\n\t    that.unmuteAudio = function () {\n\t        if (!that.isAudioMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n\t            track.enabled = true;\n\t        });\n\t        /**\n\t         * Indicate that the mute status of local audio or video has changed.\n\t         * @event respoke.LocalMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'audio',\n\t            muted: false\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Stop the stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.stop\n\t     * @fires respoke.LocalMedia#stop\n\t     */\n\t    that.stop = function () {\n\t        if (!that.stream) {\n\t            return;\n\t        }\n\t\n\t        that.stream.numPc -= 1;\n\t        if (that.stream.numPc === 0) {\n\t            that.stream.getTracks().forEach(function (track) {\n\t                track.stop();\n\t            });\n\t        }\n\t        that.stream = null;\n\t        /**\n\t         * Indicate that local media has stopped.\n\t         * @event respoke.LocalMedia#stop\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.LocalMedia} target\n\t         */\n\t        that.fire('stop');\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we are sending a screenshare.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.hasScreenShare\n\t     * @return {boolean}\n\t     */\n\t    that.hasScreenShare = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getVideoTracks().length > 0 && hasScreenShare);\n\t        }\n\t        return hasScreenShare;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we are sending video.\n\t     *\n\t     * Note: This method will return true when the video is a screenshare.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.hasVideo\n\t     * @return {boolean}\n\t     */\n\t    that.hasVideo = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getVideoTracks().length > 0);\n\t        }\n\t        return sdpHasVideo;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we are sending audio.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.hasAudio\n\t     * @return {boolean}\n\t     */\n\t    that.hasAudio = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getAudioTracks().length > 0);\n\t        }\n\t        return sdpHasAudio;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we have media yet.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.hasMedia\n\t     * @return {boolean}\n\t     */\n\t    that.hasMedia = function () {\n\t        return !!that.stream;\n\t    };\n\t\n\t    /**\n\t     * Save and parse the SDP.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.setSDP\n\t     * @param {RTCSessionDescription} oSession\n\t     * @private\n\t     */\n\t    that.setSDP = function (oSession) {\n\t        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n\t        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n\t        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n\t\n\t        // We don't have media yet & this can still be changed so create the defaults based on what the sdp says.\n\t        if (that.temporary) {\n\t            that.constraints = {\n\t                video: sdpHasVideo,\n\t                audio: sdpHasAudio,\n\t                mandatory: {},\n\t                optional: []\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Parse the constraints.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.setConstraints\n\t     * @param {MediaConstraints} constraints\n\t     * @private\n\t     */\n\t    that.setConstraints = function (constraints) {\n\t        that.constraints = constraints;\n\t        sdpHasVideo = respoke.constraintsHasVideo(that.constraints);\n\t        sdpHasAudio = respoke.constraintsHasAudio(that.constraints);\n\t    };\n\t\n\t    /**\n\t     * Start the stream.\n\t     * @memberof! respoke.LocalMedia\n\t     * @method respoke.LocalMedia.start\n\t     * @fires respoke.LocalMedia#start\n\t     * @param {object} [params]\n\t     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n\t     * method only.\n\t     * @returns {Promise|undefined}\n\t     */\n\t    that.start = function (params) {\n\t        var retVal;\n\t        params = params || {};\n\t\n\t        if (that.temporary) {\n\t            deferred.reject(new Error(\"Temporary local media started!\"));\n\t        } else {\n\t            requestMedia();\n\t        }\n\t\n\t        retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\t        return retVal;\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.LocalMedia\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * Class for managing the remote media stream,\n\t * which is attached to a call at `call.outgoingMedia`.\n\t *\n\t * @class respoke.RemoteMedia\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {object} params.constraints\n\t * @param {boolean} params.temporary - whether this instance represents our best guess of future media. If so,\n\t * this object will be deleted when real media comes in. It will be replaced by different instance of\n\t * respoke.RemoteMedia representing the actual state of media.\n\t * @param {HTMLVideoElement} params.element - Pass in an optional html video element to have remote\n\t * video attached to it.\n\t * @returns {respoke.RemoteMedia}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var that = respoke.EventEmitter(params);\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.RemoteMedia';\n\t    /**\n\t     * Respoke media ID (different from a `MediaStream.id`).\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name id\n\t     * @type {string}\n\t     */\n\t    that.id = respoke.makeGUID();\n\t    /**\n\t     * The HTML element with attached video.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name element\n\t     * @type {HTMLVideoElement}\n\t     */\n\t    that.element = params.element || document.createElement('video');\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name hasScreenShare\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var hasScreenShare = params.hasScreenShare;\n\t    delete params.hasScreenShare;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name sdpHasAudio\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasAudio = false;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name sdpHasVideo\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasVideo = false;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name sdpHasDataChannel\n\t     * @private\n\t     * @type {boolean}\n\t     */\n\t    var sdpHasDataChannel = false;\n\t    /**\n\t     * A timer to make sure we only fire {respoke.RemoteMedia#requesting-media} if the browser doesn't\n\t     * automatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name allowTimer\n\t     * @private\n\t     * @type {number}\n\t     */\n\t    var allowTimer = 0;\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name mediaOptions\n\t     * @private\n\t     * @type {object}\n\t     */\n\t    var mediaOptions = {\n\t        optional: [\n\t            { DtlsSrtpKeyAgreement: true },\n\t            { RtpDataChannels: false }\n\t        ]\n\t    };\n\t    /**\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name pc\n\t     * @private\n\t     * @type {respoke.PeerConnection}\n\t     */\n\t    var pc = params.pc;\n\t    delete that.pc;\n\t    /**\n\t     * The remote `MediaStream`.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @name stream\n\t     * @type {RTCMediaStream}\n\t     */\n\t    that.stream = params.stream;\n\t\n\t    if (!that.temporary && that.stream) {\n\t        attachMediaStream(that.element, that.stream);\n\t        that.element.autoplay = true;\n\t        setTimeout(that.element.play.bind(that.element)); // stupid Firefox requires this.\n\t    }\n\t\n\t    /**\n\t     * Indicate whether we are receiving a screenshare.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.hasScreenShare\n\t     * @return {boolean}\n\t     */\n\t    that.hasScreenShare = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getVideoTracks().length > 0 && hasScreenShare);\n\t        }\n\t        return hasScreenShare;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we are receiving video.\n\t     *\n\t     * Note: This method will return true when the video is a screenshare.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.hasVideo\n\t     * @return {boolean}\n\t     */\n\t    that.hasVideo = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getVideoTracks().length > 0);\n\t        }\n\t        return sdpHasVideo;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we are receiving audio.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.hasAudio\n\t     * @return {boolean}\n\t     */\n\t    that.hasAudio = function () {\n\t        if (that.stream) {\n\t            return (that.stream.getAudioTracks().length > 0);\n\t        }\n\t        return sdpHasAudio;\n\t    };\n\t\n\t    /**\n\t     * Indicate whether we have media yet.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.hasMedia\n\t     * @return {boolean}\n\t     */\n\t    that.hasMedia = function () {\n\t        return !!that.stream;\n\t    };\n\t\n\t    /**\n\t     * Save and parse the SDP\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.setSDP\n\t     * @param {RTCSessionDescription} oSession\n\t     * @private\n\t     */\n\t    that.setSDP = function (oSession) {\n\t        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n\t        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n\t        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n\t    };\n\t\n\t    /**\n\t     * Parse the constraints.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.setConstraints\n\t     * @param {MediaConstraints} constraints\n\t     * @private\n\t     */\n\t    that.setConstraints = function (constraints) {\n\t        that.constraints = constraints;\n\t        sdpHasVideo = respoke.constraintsHasVideo(that.constraints);\n\t        sdpHasAudio = respoke.constraintsHasAudio(that.constraints);\n\t    };\n\t\n\t    /**\n\t     * Expose getAudioTracks.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.getAudioTracks\n\t     */\n\t    that.getAudioTracks = function () {\n\t        if (that.stream) {\n\t            return that.stream.getAudioTracks();\n\t        }\n\t        return [];\n\t    };\n\t\n\t    /**\n\t     * Expose getVideoTracks.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.getVideoTracks\n\t     */\n\t    that.getVideoTracks = function () {\n\t        if (that.stream) {\n\t            return that.stream.getVideoTracks();\n\t        }\n\t        return [];\n\t    };\n\t\n\t    /**\n\t     * Stop the stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.stop\n\t     * @fires respoke.RemoteMedia#stop\n\t     */\n\t    that.stop = function () {\n\t        if (!that.stream) {\n\t            return;\n\t        }\n\t\n\t        that.stream.numPc -= 1;\n\t        if (that.stream.numPc === 0) {\n\t            that.stream.getTracks().forEach(function (track) {\n\t                track.stop();\n\t            });\n\t        }\n\t        that.stream = null;\n\t        /**\n\t         * Indicate that remote media has stopped.\n\t         * @event respoke.RemoteMedia#stop\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         */\n\t        that.fire('stop');\n\t    };\n\t\n\t    /**\n\t     * Whether the video stream is muted.\n\t     *\n\t     * All video tracks must be muted for this to return `false`.\n\t     * @returns boolean\n\t     */\n\t    that.isVideoMuted = function () {\n\t        if (!that.stream) {\n\t            return false;\n\t        }\n\t        return that.stream.getVideoTracks().every(function (track) {\n\t            return !track.enabled;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Mute remote video stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.muteVideo\n\t     * @fires respoke.RemoteMedia#mute\n\t     */\n\t    that.muteVideo = function () {\n\t        if (that.isVideoMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n\t            track.enabled = false;\n\t        });\n\t        /**\n\t         * Indicate that the muted status of remote video or audio has changed.\n\t         * @event respoke.RemoteMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'video',\n\t            muted: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Unmute remote video stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.unmuteVideo\n\t     * @fires respoke.RemoteMedia#mute\n\t     */\n\t    that.unmuteVideo = function () {\n\t        if (!that.isVideoMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n\t            track.enabled = true;\n\t        });\n\t        /**\n\t         * Indicate that the muted status of remote video or audio has changed.\n\t         * @event respoke.RemoteMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'video',\n\t            muted: false\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Whether the audio stream is muted.\n\t     *\n\t     * All audio tracks must be muted for this to return `false`.\n\t     * @returns boolean\n\t     */\n\t    that.isAudioMuted = function () {\n\t        if (!that.stream) {\n\t            return false;\n\t        }\n\t        return that.stream.getAudioTracks().every(function (track) {\n\t            return !track.enabled;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Mute remote audio stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.muteAudio\n\t     * @fires respoke.RemoteMedia#mute\n\t     */\n\t    that.muteAudio = function () {\n\t        if (that.isAudioMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n\t            track.enabled = false;\n\t        });\n\t        /**\n\t         * Indicate that the muted status of remote video or audio has changed.\n\t         * @event respoke.RemoteMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'audio',\n\t            muted: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Unmute remote audio stream.\n\t     * @memberof! respoke.RemoteMedia\n\t     * @method respoke.RemoteMedia.unmuteAudio\n\t     * @fires respoke.RemoteMedia#mute\n\t     */\n\t    that.unmuteAudio = function () {\n\t        if (!that.isAudioMuted()) {\n\t            return;\n\t        }\n\t        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n\t            track.enabled = true;\n\t        });\n\t        /**\n\t         * Indicate that the muted status of remote video or audio has changed.\n\t         * @event respoke.RemoteMedia#mute\n\t         * @property {string} name - the event name.\n\t         * @property {respoke.RemoteMedia} target\n\t         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n\t         * has been changed.\n\t         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n\t         */\n\t        that.fire('mute', {\n\t            type: 'audio',\n\t            muted: false\n\t        });\n\t    };\n\t\n\t    return that;\n\t}; // End respoke.RemoteMedia\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2015, Digium, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under The MIT License found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * For all details and documentation:  https://www.respoke.io\n\t */\n\t\n\tvar Q = __webpack_require__(8);\n\tvar respoke = __webpack_require__(1);\n\t\n\t/**\n\t * A conference call to one or more people with audio. Eventually this will handle video, too.\n\t * @class respoke.Conference\n\t * @constructor\n\t * @augments respoke.EventEmitter\n\t * @param {object} params\n\t * @param {string} params.id - The id that should be used to create the conference call or the ID\n\t * of the call to join.\n\t * @param {string} params.instanceId - client id\n\t * @param {boolean} params.caller - whether or not we initiated the call\n\t * @param {boolean} [params.receiveOnly] - whether or not we accept media\n\t * @param {boolean} [params.sendOnly] - whether or not we send media\n\t * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n\t * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n\t * relay servers. If it cannot flow through relay servers, the call will fail.\n\t * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n\t * required to flow peer-to-peer. If it cannot, the call will fail.\n\t * @param {respoke.Endpoint} params.remoteEndpoint - The endpoint who is being called.\n\t * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint.\n\t * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n\t * wants to perform an action between local media becoming available and calling approve().\n\t * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n\t * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n\t * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n\t * @param {function} params.signalReport - Signaling action from SignalingChannel.\n\t * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n\t * @param {Array<RTCConstraints>} params.constraints - Array of WebRTC constraints.\n\t * @param {respoke.Conference.onJoin} [params.onJoin] - Callback for when a participant joins the conference.\n\t * @param {respoke.Conference.onLeave} [params.onLeave] - Callback for when a participant leaves the conference.\n\t * @param {respoke.Conference.onMessage} [params.onMessage] - Callback for when a message is sent to the conference.\n\t * @param {respoke.Conference.onMute} [params.onMute] - Callback for when local or remote media is muted or unmuted.\n\t * @param {respoke.Conference.onTopic} [params.onTopic] - Callback for the conference topic changes.\n\t * @param {respoke.Conference.onPresenter} [params.onPresenter] - Callback for when the presenter changes.\n\t * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n\t * media renegotiation.\n\t * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n\t * element with the local audio and/or video attached.\n\t * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n\t * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n\t * it was ended in a graceful manner.\n\t * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n\t * This callback will be called when media is muted or unmuted.\n\t * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n\t * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n\t * for the user to give permission to start getting audio or video.\n\t * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n\t * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n\t * the approval was automatic.\n\t * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n\t * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n\t * granted by the browser without asking the user to approve it.\n\t * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local\n\t * video attached to it.\n\t * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote\n\t * video attached to it.\n\t * @returns {respoke.Conference}\n\t */\n\tmodule.exports = function (params) {\n\t    \"use strict\";\n\t    params = params || {};\n\t    /**\n\t     * @memberof! respoke.Client\n\t     * @name instanceId\n\t     * @private\n\t     * @type {string}\n\t     */\n\t    var instanceId = params.instanceId;\n\t    var signalingChannel = params.signalingChannel;\n\t    var that = respoke.EventEmitter({\n\t        id: params.id\n\t    });\n\t\n\t    that.listen('join', params.onJoin);\n\t    that.listen('leave', params.onLeave);\n\t    that.listen('message', params.onMessage);\n\t    that.listen('mute', params.onMute);\n\t    that.listen('topic', params.onTopic);\n\t    that.listen('presenter', params.onPresenter);\n\t    delete params.onJoin;\n\t    delete params.onLeave;\n\t    delete params.onMessage;\n\t    delete params.onMute;\n\t    delete params.onTopic;\n\t    delete params.onPresenter;\n\t\n\t    params.caller = true;\n\t    params.conferenceId = params.id;\n\t    delete params.id;\n\t    params.remoteEndpoint = that;\n\t    that.call = respoke.Call(params);\n\t\n\t    // Redirect a bunch of events.\n\t    [\n\t        'mute', 'hangup', 'connect', 'stats', 'error', 'local-stream-received',\n\t         'remote-stream-received', 'requesting-media', 'approve', 'allow'\n\t    ].forEach(function (eventName) {\n\t        that.call.listen(eventName, function (evt) {\n\t            evt.call = that.call; // target will be updated to point to this conference object.\n\t            that.fire(eventName, evt);\n\t        });\n\t    });\n\t\n\t    delete that.instanceId;\n\t\n\t    /**\n\t     * A name to identify this class\n\t     * @memberof! respoke.Conference\n\t     * @name className\n\t     * @type {string}\n\t     */\n\t    that.className = 'respoke.Conference';\n\t\n\t    /**\n\t     * @memberof! respoke.Conference\n\t     * @name client\n\t     * @type {respoke.Client}\n\t     * @private\n\t     */\n\t    var client = respoke.getClient(instanceId);\n\t\n\t    /**\n\t     * Leave the conference.\n\t     * @memberof! respoke.Conference\n\t     * @method respoke.Conference.leave\n\t     */\n\t    that.leave = that.call.hangup;\n\t\n\t    /**\n\t     * Mute local user's audio.\n\t     * @memberof! respoke.Conference\n\t     * @method respoke.Conference.muteAudio\n\t     */\n\t    that.muteAudio = that.call.muteAudio;\n\t\n\t    /**\n\t     * ## The plugin `respoke.MediaStats` must be loaded before using this method.\n\t     *\n\t     * Start the process of listening for a continuous stream of statistics about the flow of audio and/or video.\n\t     * Since we have to wait for both the answer and offer to be available before starting\n\t     * statistics, the library returns a promise for the stats object. The statistics object does not contain the\n\t     * statistics; rather it contains methods of interacting with the actions of obtaining statistics. To obtain\n\t     * the actual statistics one time, use stats.getStats(); use the onStats callback to obtain a continuous\n\t     * stream of statistics every `interval` seconds.  Returns null if stats module is not loaded.\n\t     *\n\t     *     conference.getStats({\n\t     *         onStats: function (evt) {\n\t     *             console.log('Stats', evt.stats);\n\t     *         }\n\t     *     }).done(function () {\n\t     *         console.log('Stats started');\n\t     *     }, function (err) {\n\t     *         console.log('Call is already hung up.');\n\t     *     });\n\t     *\n\t     * @memberof! respoke.Conference\n\t     * @method respoke.Conference.getStats\n\t     * @param {object} params\n\t     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n\t     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive\n\t     * the stats. If no callback is provided, the call's report will contain stats but the developer will not\n\t     * receive them on the client-side.\n\t     * @param {respoke.Call.statsSuccessHandler} [params.onSuccess] - Success handler for this invocation of\n\t     * this method only.\n\t     * @param {respoke.Call.errorHandler} [params.onError] - Error handler for this invocation of this method only.\n\t     * @returns {Promise<object>|null}\n\t     */\n\t    if (respoke.MediaStats) {\n\t        that.getStats = that.call.getStats;\n\t    }\n\t\n\t    /**\n\t     * Get an array containing a Connection object for each participant in the conference.\n\t     * @memberof! respoke.Conference\n\t     * @method respoke.Conference.getParticipants\n\t     * @returns {Promise<Array>}\n\t     */\n\t    that.getParticipants = function () {\n\t        return signalingChannel.getConferenceParticipants({\n\t            id: that.id\n\t        });\n\t    };\n\t\n\t    /**\n\t     * If the logged-in endpoint has permission through its Respoke role, forcibly remove another participant\n\t     * from the conference, ending its conference call.\n\t     * @memberof! respoke.Conference\n\t     * @method respoke.Conference.removeParticipant\n\t     * @param {object} params\n\t     * @param {string} [endpointId] - The endpoint id of the endpoint to be removed\n\t     * @param {string} [connectionId] - The connection id of the connection to be removed\n\t     * @returns {Promise}\n\t     */\n\t    that.removeParticipant = function (params) {\n\t        params = params || {};\n\t        params.conferenceId = that.id;\n\t        return signalingChannel.removeConferenceParticipant(params);\n\t    };\n\t\n\t    /**\n\t     * If the logged-in endpoint has permission through its Respoke role, shut down the conference, removing all\n\t     * participants.\n\t     * @memberof! respoke.Conference\n\t     * @method respoke.Conference.destroy\n\t     * @returns {Promise}\n\t     */\n\t    that.destroy = function (params) {\n\t        return signalingChannel.destroyConference({\n\t            conferenceId: that.id\n\t        });\n\t    };\n\t\n\t    return that;\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** build/respoke.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 17546c194ed1f389a3e4\n **/","module.exports = require('./respoke/respoke');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\"use strict\";\n/*jshint bitwise: false*/\n\n// var Airbrake = require('airbrake-js');\nvar log = require('loglevel');\nlog.setLevel(log.levels.WARN);\n\nvar originalFactory = log.methodFactory;\nlog.methodFactory = function logMethodFactory(methodName, logLevel) {\n    var logMethod = originalFactory(methodName, logLevel);\n    var errorReporter;\n\n    // if (!window.skipErrorReporting && methodName === 'error') {\n    //     var airbrake = new Airbrake({\n    //         projectId: '98133',\n    //         projectKey: 'cd3e085acc5e554658ebcdabd112a6f4'\n    //     });\n    //     errorReporter = function (message) {\n    //         airbrake.push({ error: { message: message } });\n    //     };\n    // } else {\n    //     errorReporter = function () { };\n    // }\n    errorReporter = function () { };\n\n    return function (message) {\n        var args = Array.prototype.slice.call(arguments);\n        var reporterMessage = args.join(' ');\n\n        args.unshift('[Respoke]');\n        logMethod.apply(this, args);\n        errorReporter(reporterMessage);\n    };\n};\n\nrequire('./deps/adapter');\n\n/**\n * `respoke` is a global static class.\n *\n *\n * Include the [latest version](https://cdn.respoke.io/respoke.min.js) or\n * [choose a previous release](http://cdn.respoke.io/list.html).\n *\n * Or use `npm install --save respoke`.\n *\n * Interact with Respoke primarily via [`respoke.Client`](respoke.Client.html):\n *\n *      var client = respoke.createClient();\n *\n *\n * **Development mode without brokered auth**\n *\n *      var client = respoke.createClient({\n *          appId: \"XXXXXXX-my-app-id-XXXXXX\",\n *          developmentMode: true,\n *          endpointId: \"daveops\"\n *      });\n *\n *      client.connect({\n *          onSuccess: function () { ... },\n *          onError: function (err) { ... }\n *      });\n *\n *\n * **Production mode with brokered auth**\n *\n *      var client = respoke.createClient();\n *\n *      // Respoke auth token obtained by your server.\n *      // This is how you control who can connect to Respoke app.\n *      // See API docs for POST [base]/tokens\n *      var tokenId = \"XXXX-XXXX-brokered-auth-token-XXXXX\";\n *\n *      // connect to respoke with the token\n *      client.connect({\n *          token: tokenId\n *          onSuccess: function () { ... },\n *          onError: function (err) { ... }\n *      });\n *\n *      // fetch a new token from your server if it expires\n *      client.listen('disconnect', function (evt) {\n *          // fetch another token from your server.\n *          var newTokenId = \"XXXX-XXXX-brokered-auth-token2-XXXXX\";\n *          client.connect({\n *              token: newTokenId\n *          });\n *      });\n *\n *\n *\n * ### Event listeners vs callback handlers\n *\n * There are two ways to attach listeners. It is highly recommended that you choose one pattern\n * and stick to it throughout your app.\n *\n * For every `event-name`, there is a corresponding callback `onEventName`.\n *\n * **With a listener**\n *\n *      var client = respoke.createClient();\n *      client.listen('connect', function () { });\n *\n * **or with a callback**\n *\n *      var client = respoke.createClient({\n *          // other options go here\n *\n *          onConnect: function () { }\n *      });\n *\n *\n * @namespace respoke\n * @class respoke\n * @global\n * @link https://cdn.respoke.io/respoke.min.js\n */\n\nvar EventEmitter = require('./event');\nvar respoke = module.exports = EventEmitter({\n    ridiculous: false, // print every websocket tx/rx\n    buildNumber: 'NO BUILD NUMBER',\n    io: require('socket.io-client'),\n    Q: require('q')\n});\n\nrespoke.Q.longStackSupport = true;\nrespoke.Q.stackJumpLimit = 5;\nrespoke.Q.longStackJumpLimit = 20;\nrespoke.Q.stopUnhandledRejectionTracking();\n\n/**\n * A map of respoke.Client instances available for use. This is useful if you would like to separate some\n * functionality of your app into a separate Respoke app which would require a separate appId.\n * @type {boolean}\n */\nrespoke.instances = {};\n\n/**\n * Indicate whether the user's browser is Chrome and requires the Respoke Chrome extension to do screen sharing.\n * @type {boolean}\n * @private\n */\nrespoke.needsChromeExtension = !!(window.chrome && !window.opera && navigator.webkitGetUserMedia);\n\n/**\n * Indicate whether the user's browser is Firefox and requires the Respoke Firefox extension to do screen sharing.\n * @type {boolean}\n * @private\n */\nrespoke.needsFirefoxExtension = window.webrtcDetectedBrowser === 'firefox';\n\n/**\n * Indicate whether the user has a Respoke Chrome extension installed and running correcty on this domain.\n * @type {boolean}\n * @private\n */\nrespoke.hasChromeExtension = false;\n\n/**\n * Indicate whether the user has a Respoke Firefox extension installed and running correcty on this domain.\n * @type {boolean}\n * @private\n */\nrespoke.hasFirefoxExtension = false;\n\n/**\n * This method will be overridden in the case that an extension or plugin is available for screen sharing.\n *\n * @static\n * @private\n * @memberof respoke\n */\nrespoke.chooseDesktopMedia = function () {\n    log.warn(\"Screen sharing is not implemented for this browser.\");\n};\n\n/**\n * Indicate whether we are dealing with node-webkit, and expose chooseDesktopMedia if so\n * @type {boolean}\n * @private\n */\nrespoke.isNwjs = (function () {\n    var gui;\n    var isNwjs = !!((typeof process !== 'undefined') && (typeof global !== 'undefined') &&\n        global.window && global.window.nwDispatcher);\n\n    if (isNwjs) {\n        // expose native node-webkit chooseDesktopMedia (requires nw.js 0.12+)\n        gui = window.nwDispatcher.requireNwGui();\n        gui.Screen.Init();\n\n        respoke.chooseDesktopMedia = function (data, callback) {\n            // make data param optional\n            if (!callback && (typeof data === 'function')) {\n                callback = data;\n                data = null;\n            }\n\n            /*\n             * mediaSources can be one of 'window', 'screen', or 'tab', or an array with multiples\n             * https://developer.chrome.com/extensions/desktopCapture\n             */\n            var mediaSources = data && data.source ? [data.source] : ['window', 'screen'];\n\n            gui.Screen.chooseDesktopMedia(mediaSources, function (sourceId) {\n                callback({\n                    type: 'respoke-source-id',\n                    sourceId: sourceId\n                });\n            });\n        };\n    }\n\n    return isNwjs;\n})();\n\n/**\n * Create an Event. This is used in the Chrome/Firefox extensions to communicate between the library and extension.\n * @type {function}\n * @private\n */\nrespoke.extEvent = function (type, data) {\n    var evt = document.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(type, true, true, data);\n    return evt;\n};\n\n/**\n * `\"v0.0.0\"`\n *\n * The respoke.min.js version.\n *\n * Past versions can be found at [cdn.respoke.io/list.html](http://cdn.respoke.io/list.html)\n * @type {string}\n */\nrespoke.version = respoke.buildNumber + \"\";\n\nrespoke.log = log;\nrespoke.Class = require('./class');\nrespoke.EventEmitter = EventEmitter;\nrespoke.Client = require('./client');\nrespoke.Connection = require('./connection');\nrespoke.Endpoint = require('./endpoint');\nrespoke.TextMessage = require('./textMessage');\nrespoke.SignalingMessage = require('./signalingMessage');\nrespoke.Group = require('./group');\nrespoke.SignalingChannel = require('./signalingChannel');\nrespoke.DirectConnection = require('./directConnection');\nrespoke.PeerConnection = require('./peerConnection');\nrespoke.CallState = require('./callState');\nrespoke.Call = require('./call');\nrespoke.LocalMedia = require('./localMedia');\nrespoke.RemoteMedia = require('./remoteMedia');\nrespoke.Conference = require('./conference');\n\n/**\n * Get information from the Respoke Screen Sharing Chrome extension if it is installed.\n * @private\n */\nfunction chromeScreenSharingExtensionReady(evt) {\n    var data = evt.detail;\n    if (data.available !== true) {\n        return;\n    }\n\n    respoke.hasChromeExtension = true;\n    respoke.chooseDesktopMedia = function (params, callback) {\n        if (!callback) {\n            throw new Error(\"Can't choose desktop media without callback parameter.\");\n        }\n\n        function sourceIdListener(evt) {\n            var data = evt.detail;\n\n            respoke.screenSourceId = data.sourceId;\n            callback(data);\n            document.removeEventListener(\"respoke-source-id\", sourceIdListener);\n        }\n\n        document.dispatchEvent(respoke.extEvent('ct-respoke-source-id', {\n            source: params.source ? [params.source] : ['screen', 'window']\n        }));\n\n        document.addEventListener(\"respoke-source-id\", sourceIdListener);\n    };\n\n    respoke.fire('extension-loaded', {\n        type: 'screen-sharing'\n    });\n\n    log.info(\"Respoke Screen Share Chrome extension available for use.\");\n}\n\n// TODO: remove 'respoke-available' event listener on next major version bump\ndocument.addEventListener('respoke-available', chromeScreenSharingExtensionReady);\ndocument.addEventListener('respoke-chrome-screen-sharing-available', chromeScreenSharingExtensionReady);\ndocument.addEventListener('respoke-firefox-screen-sharing-available', function (evt) {\n\n    var data = evt.detail;\n    if (data !== 'available') {\n        return;\n    }\n\n    respoke.hasFirefoxExtension = true;\n\n    respoke.fire('extension-loaded', {\n        type: 'screen-sharing'\n    });\n\n    log.info(\"Respoke Screen Share Firefox extension available for use.\");\n});\n\n/**\n * This is one of two possible entry points for interating with the library.\n *\n * This method creates a new Client object\n * which represents your user's connection to your Respoke app.\n *\n * This method **automatically calls client.connect(params)** after the client is created.\n *\n * @static\n * @memberof respoke\n * @param {object} params Parameters to the respoke.Client constructor.\n * @param {string} [params.appId]\n * @param {string} [params.baseURL]\n * @param {string} [params.token]\n * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n * operation and will limit the services you will be able to use.\n * @param {boolean} [params.reconnect=false] - Whether or not to automatically reconnect to the Respoke service\n * when a disconnect occurs.\n * @param {function} [params.onSuccess] - Success handler for this invocation of this method only.\n * @param {function} [params.onError] - Error handler for this invocation of this method only.\n * @param {function} [params.onJoin] - Callback for when this client's endpoint joins a group.\n * @param {function} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n * @param {function} [params.onMessage] - Callback for when any message is received from anywhere on the system.\n * @param {function} [params.onDisconnect] - Callback for Client disconnect.\n * @param {function} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n * @param {function} [params.onCall] - Callback for when this client's user receives a call.\n * @param {function} [params.onDirectConnection] - Callback for when this client's user receives a request for a\n * direct connection.\n * @param {boolean} [params.enableCallDebugReport=true] - Optional flag defaulting to true which allows sending\n * debugging information.\n * @returns {respoke.Client}\n */\nrespoke.connect = function (params) {\n    var client = respoke.Client(params);\n    client.connect(params);\n    return client;\n};\n\n/**\n * Getter for the respoke client.\n *\n * You can have more than one active client, so this method provides a way to retrieve a specific instance.\n *\n * @static\n * @memberof respoke\n * @param {string} id The Client ID.\n * @returns {respoke.Client}\n */\nrespoke.getClient = function (id) {\n    if (id === undefined) {\n        log.debug(\"Can't call getClient with no client ID.\", new Error().stack);\n    }\n    if (!respoke.instances[id]) {\n        log.debug(\"No client instance with id\", id);\n    }\n    return respoke.instances[id];\n};\n\n/**\n * This is one of two possible entry points for interating with the library.\n *\n * This method creates a new Client object which represents your user's connection to your Respoke app.\n *\n * It **does NOT automatically call the client.connect() method** after the client is created.\n *\n * The `params` argument is the same as `respoke.connect(params)`.\n *\n * @static\n * @memberof respoke\n * @param {object} [params] Parameters to respoke.Client - same as respoke.connect()\n * @returns {respoke.Client}\n */\nrespoke.createClient = function (params) {\n    var client;\n    params = params || {};\n    if (params.instanceId) {\n        client = respoke.getClient(params.instanceId);\n        if (client) {\n            return client;\n        }\n    }\n    return respoke.Client(params);\n};\n\n/**\n * Build a closure from a listener that will ensure the listener can only be called once.\n * @static\n * @private\n * @memberof respoke\n * @param {function} func\n * @return {function}\n */\nrespoke.callOnce = function (func) {\n    return (function () {\n        var called = false;\n        return function () {\n            if (called === false) {\n                func.apply(null, arguments);\n                called = true;\n            }\n        };\n    })();\n};\n\n/**\n * @static\n * @private\n * @memberof respoke\n * @returns {number}\n */\nrespoke.makeGUID = function () {\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n    var uuid = new Array(36);\n    var rnd = 0;\n    var r;\n    for (var i = 0; i < 36; i += 1) {\n        if (i === 8 || i === 13 ||  i === 18 || i === 23) {\n            uuid[i] = '-';\n        } else if (i === 14) {\n            uuid[i] = '4';\n        } else {\n            if (rnd <= 0x02) {\n                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\n            }\n            r = rnd & 0xf;\n            rnd = rnd >> 4;\n            uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\n        }\n    }\n    return uuid.join('');\n};\n\n/**\n * This method is used internally to attach handlers to promises that are returned by many methods in the library.\n * It's not recommended that this method be used by developers and apps.\n * @private\n * @static\n * @memberof respoke\n * @param {Promise} promise\n * @param {function} onSuccess\n * @param {function} onError\n * @returns {Promise|undefined}\n */\nrespoke.handlePromise = function (promise, onSuccess, onError) {\n    var returnUndef = false;\n    if (onSuccess || onError) {\n        returnUndef = true;\n    }\n\n    onSuccess = typeof onSuccess === 'function' ? onSuccess : function () {};\n    onError = typeof onError === 'function' ? onError : function () {};\n    promise.done(onSuccess, onError);\n    return (returnUndef ? undefined : promise);\n};\n\n/**\n * Does the browser support `UserMedia`?\n * @static\n * @memberof respoke\n * @returns {boolean}\n */\nrespoke.hasUserMedia = function () {\n    return (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) instanceof Function;\n};\n\n/**\n * Does the browser support `RTCPeerConnection`?\n * @static\n * @memberof respoke\n * @returns {boolean}\n */\nrespoke.hasRTCPeerConnection = function () {\n    return (window.RTCPeerConnection || window.webkitRTCPeerConnection ||\n            window.mozRTCPeerConnection) instanceof Function;\n};\n\n/**\n * Does the browser support `WebSocket`?\n * @static\n * @memberof respoke\n * @returns {boolean}\n */\nrespoke.hasWebsocket = function () {\n    return (window.WebSocket || window.webkitWebSocket || window.MozWebSocket) instanceof Function;\n};\n\n/**\n * Does the browser have Screen Sharing enabled via browser extensions?\n * @static\n * @memberof respoke\n * @returns {boolean}\n */\nrespoke.hasScreenShare = function () {\n    return respoke.hasChromeExtension || respoke.hasFirefoxExtension;\n};\n\n/**\n * Clone an object.\n * @static\n * @memberof respoke\n * @private\n * @param {Object} source - The object to clone\n * @returns {Object}\n */\nrespoke.clone = function (source) {\n    if (source) {\n        return JSON.parse(JSON.stringify(source));\n    }\n    return source;\n};\n\n/**\n * Compares two objects for equality\n * @static\n * @memberof respoke\n * @private\n * @param {Object} a\n * @param {Object} b\n * @returns {boolean}\n */\nrespoke.isEqual = function (a, b) {\n    var aKeys;\n    var i;\n\n    //check if arrays\n    if (a && b && a.hasOwnProperty('length') && b.hasOwnProperty('length') && a.splice && b.splice) {\n        if (a.length !== b.length) {\n            //short circuit if arrays are different length\n            return false;\n        }\n\n        for (i = 0; i < a.length; i += 1) {\n            if (!respoke.isEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    if (typeof a === 'object' && typeof b === 'object' && Object.keys(a).length === Object.keys(b).length) {\n        aKeys = Object.keys(a);\n        for (i = 0; i < aKeys.length; i += 1) {\n            if (!respoke.isEqual(a[aKeys[i]], b[aKeys[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return a === b;\n};\n\n/**\n * Does the sdp indicate an audio stream?\n * @static\n * @memberof respoke\n * @params {string}\n * @returns {boolean}\n * @private\n */\nrespoke.sdpHasAudio = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasAudio called with no parameters.\");\n    }\n    return (sdp.indexOf('m=audio') !== -1 && sdp.indexOf('a=recvonly') === -1);\n};\n\n/**\n * Does the sdp indicate a video stream?\n * @static\n * @memberof respoke\n * @params {string}\n * @returns {boolean}\n * @private\n */\nrespoke.sdpHasVideo = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasVideo called with no parameters.\");\n    }\n    return (sdp.indexOf('m=video') !== -1 && sdp.indexOf('a=recvonly') === -1);\n};\n\n/**\n * Does the sdp indicate a data channel?\n * @static\n * @memberof respoke\n * @params {string}\n * @returns {boolean}\n * @private\n */\nrespoke.sdpHasDataChannel = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasDataChannel called with no parameters.\");\n    }\n    return sdp.indexOf('m=application') !== -1;\n};\n\n/**\n * Does the sdp indicate the creator is sendOnly?\n * @static\n * @memberof respoke\n * @params {string}\n * @returns {boolean}\n * @private\n */\nrespoke.sdpHasSendOnly = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasSendOnly called with no parameters.\");\n    }\n    return sdp.indexOf('a=sendonly') !== -1;\n};\n\n/**\n * Does the sdp indicate the creator is receiveOnly?\n * @static\n * @memberof respoke\n * @params {string}\n * @returns {boolean}\n * @private\n */\nrespoke.sdpHasReceiveOnly = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasReceiveOnly called with no parameters.\");\n    }\n    return sdp.indexOf('a=recvonly') !== -1;\n};\n\n/**\n * Do the constraints indicate an audio stream?\n * @static\n * @memberof respoke\n * @params {RTCConstraints}\n * @returns {boolean}\n * @private\n */\nrespoke.constraintsHasAudio = function (constraints) {\n    if (!constraints) {\n        throw new Error(\"respoke.constraintsHasAudio called with no parameters.\");\n    }\n    return (constraints.audio === true);\n};\n\n/**\n * Does the constraints indicate a video stream?\n * @static\n * @memberof respoke\n * @params {RTCConstraints}\n * @returns {boolean}\n * @private\n */\nrespoke.constraintsHasVideo = function (constraints) {\n    if (!constraints) {\n        throw new Error(\"respoke.constraintsHasVideo called with no parameters.\");\n    }\n    return (constraints.video === true || typeof constraints.video === 'object');\n};\n\n/**\n * Does the constraints indicate a screenshare?\n * @static\n * @memberof respoke\n * @params {RTCConstraints}\n * @returns {boolean}\n * @private\n */\nrespoke.constraintsHasScreenShare = function (constraints) {\n    if (!constraints) {\n        throw new Error(\"respoke.constraintsHasScreenShare called with no parameters.\");\n    }\n\n    return (constraints.video && constraints.video.mandatory &&\n            (constraints.video.mandatory.chromeMediaSource || constraints.video.mediaSource));\n};\n\n/**\n * Convert old-style constraints parameter into a constraints array.\n * @static\n * @memberof respoke\n * @params {Array<RTCConstraints>|RTCConstraints} [constraints]\n * @params {Array<RTCConstraints>} [defaults]\n * @returns {Array<RTCConstraints>}\n * @private\n */\nrespoke.convertConstraints = function (constraints, defaults) {\n    constraints = constraints || [];\n    defaults = defaults || [];\n\n    if (!constraints.splice) {\n        if (typeof constraints === 'object') {\n            constraints = [constraints];\n        } else {\n            constraints = [];\n        }\n    }\n\n    if (constraints.length === 0 && defaults.length > 0) {\n        return defaults;\n    }\n\n    return constraints;\n};\n\n/**\n * Queue items until a trigger is called, then process them all with an action. Before trigger, hold items for\n * processing. After trigger, process new items immediately.\n * @static\n * @memberof respoke\n * @returns {Array}\n * @private\n */\nrespoke.queueFactory = function () {\n    var queue = [];\n    // action replaces Array.push when trigger is called. Thrown errors will be caught and logged.\n    queue.trigger = function (action) {\n        if (!action) {\n            throw new Error(\"Trigger function requires an action parameter.\");\n        }\n\n        function safeAction(item) {\n            try {\n                action(item);\n            } catch (err) {\n                log.error(\"Error calling queue action.\", err);\n            }\n        }\n        queue.forEach(safeAction);\n        queue.length = 0;\n        queue.push = safeAction;\n    };\n\n    return queue;\n};\n\n/**\n * Retrieve browser-specific WebRTC getUserMedia constraints needed to start a screen sharing call. Takes a set of\n * optional override constraints and amends them for screen sharing.\n *\n * @memberof respoke\n * @static\n * @param {object} [params]\n * @param {string} [params.source] The media source name to pass to firefox\n * @param {RTCConstraints} [params.constraints] constraints to use as a base\n * @returns {RTCConstraints}\n * @private\n */\nrespoke.getScreenShareConstraints = function (params) {\n    params = params || {};\n\n    var screenConstraint = params.constraints || {\n        audio: false,\n        video: {\n            mandatory: {},\n            optional: []\n        }\n    };\n    screenConstraint.audio = false;\n    screenConstraint.video = typeof screenConstraint.video === 'object' ? screenConstraint.video : {};\n    screenConstraint.video.optional = Array.isArray(screenConstraint.video.optional) ?\n        screenConstraint.video.optional : [];\n    screenConstraint.video.mandatory = typeof screenConstraint.video.mandatory === 'object' ?\n        screenConstraint.video.mandatory : {};\n\n    if (respoke.needsChromeExtension || respoke.isNwjs) {\n        screenConstraint.audio = false;\n        screenConstraint.video.mandatory.chromeMediaSource = 'desktop';\n        screenConstraint.video.mandatory.maxWidth = typeof screenConstraint.video.mandatory.maxWidth === 'number' ?\n            screenConstraint.video.mandatory.maxWidth : 2000;\n        screenConstraint.video.mandatory.maxHeight = typeof screenConstraint.video.mandatory.maxHeight === 'number' ?\n            screenConstraint.video.mandatory.maxHeight : 2000;\n\n        if (screenConstraint.video.optional.length > 0) {\n            screenConstraint.video.optional.forEach(function (thing) {\n                thing.googTemporalLayeredScreencast = true;\n            });\n        } else {\n            screenConstraint.video.optional[0] = {\n                googTemporalLayeredScreencast: true\n            };\n        }\n    } else {\n        // firefox, et. al.\n        screenConstraint.video.mediaSource = params.source || 'screen';\n    }\n\n    return screenConstraint;\n};\n\n/**\n * Retrieve a started instance of `respoke.LocalMedia` containing a screen share stream. Useful if you\n * want to prepare the stream prior to starting a screen share.\n *\n *     respoke.getScreenShareMedia().then(function (localMedia) {\n *         document.getElementById('#video').appendChild(localMedia.element);\n *         group.listen('join', function (evt) {\n *             evt.connection.startScreenShare({\n *                 outgoingMedia: localMedia\n *             });\n *         });\n *     }).catch(function (err) {\n *         console.log(err);\n *     });\n *\n * @static\n * @memberof respoke\n * @param {object} params\n * @param {string} [params.source] - The source you would like to use for your screen share. Values vary by browser.\n *  In Chrome, acceptable values are one of 'screen', 'window', or 'tab'.\n *  In Firefox, acceptable values are one of 'screen', 'window', or 'application'.\n * @param {RTCConstraints|Array<RTCConstraints>} [params.constraints] - constraints to use as a base\n * @param {HTMLVideoElement} [params.element] - Pass in an optional html video element to have local\n *  video attached to it.\n * @param {function} [params.onSuccess] Upon success, called with instance of `respoke.LocalMedia`\n * @param {function} [params.onError] Upon failure, called with the error that occurred.\n * @returns {Promise|undefined}\n * @private\n */\nrespoke.getScreenShareMedia = function (params) {\n    params = params || {};\n\n    var deferred = respoke.Q.defer();\n    var criteria = {\n        source: params.source,\n        constraints: respoke.clone(params.constraints)\n    };\n    var localMedia = respoke.LocalMedia({\n        hasScreenShare: true,\n        constraints: respoke.getScreenShareConstraints(criteria),\n        source: params.source,\n        element: params.element\n    });\n\n    localMedia.start().done(function () {\n        deferred.resolve(localMedia);\n    }, function (err) {\n        deferred.reject(err);\n    });\n\n    return respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/respoke.js\n ** module id = 1\n ** module chunks = 0\n **/","/*\r\n* loglevel - https://github.com/pimterry/loglevel\r\n*\r\n* Copyright (c) 2013 Tim Perry\r\n* Licensed under the MIT license.\r\n*/\r\n(function (root, definition) {\r\n    \"use strict\";\r\n    if (typeof module === 'object' && module.exports && typeof require === 'function') {\r\n        module.exports = definition();\r\n    } else if (typeof define === 'function' && typeof define.amd === 'object') {\r\n        define(definition);\r\n    } else {\r\n        root.log = definition();\r\n    }\r\n}(this, function () {\r\n    \"use strict\";\r\n    var noop = function() {};\r\n    var undefinedType = \"undefined\";\r\n\r\n    function realMethod(methodName) {\r\n        if (typeof console === undefinedType) {\r\n            return false; // We can't build a real method without a console to log to\r\n        } else if (console[methodName] !== undefined) {\r\n            return bindMethod(console, methodName);\r\n        } else if (console.log !== undefined) {\r\n            return bindMethod(console, 'log');\r\n        } else {\r\n            return noop;\r\n        }\r\n    }\r\n\r\n    function bindMethod(obj, methodName) {\r\n        var method = obj[methodName];\r\n        if (typeof method.bind === 'function') {\r\n            return method.bind(obj);\r\n        } else {\r\n            try {\r\n                return Function.prototype.bind.call(method, obj);\r\n            } catch (e) {\r\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n                return function() {\r\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    // these private functions always need `this` to be set properly\r\n\r\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\r\n        return function () {\r\n            if (typeof console !== undefinedType) {\r\n                replaceLoggingMethods.call(this, level, loggerName);\r\n                this[methodName].apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n\r\n    function replaceLoggingMethods(level, loggerName) {\r\n        /*jshint validthis:true */\r\n        for (var i = 0; i < logMethods.length; i++) {\r\n            var methodName = logMethods[i];\r\n            this[methodName] = (i < level) ?\r\n                noop :\r\n                this.methodFactory(methodName, level, loggerName);\r\n        }\r\n    }\r\n\r\n    function defaultMethodFactory(methodName, level, loggerName) {\r\n        /*jshint validthis:true */\r\n        return realMethod(methodName) ||\r\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n    }\r\n\r\n    var logMethods = [\r\n        \"trace\",\r\n        \"debug\",\r\n        \"info\",\r\n        \"warn\",\r\n        \"error\"\r\n    ];\r\n\r\n    function Logger(name, defaultLevel, factory) {\r\n      var self = this;\r\n      var currentLevel;\r\n      var storageKey = \"loglevel\";\r\n      if (name) {\r\n        storageKey += \":\" + name;\r\n      }\r\n\r\n      function persistLevelIfPossible(levelNum) {\r\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n\r\n          // Use localStorage if available\r\n          try {\r\n              window.localStorage[storageKey] = levelName;\r\n              return;\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n              window.document.cookie =\r\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n          } catch (ignore) {}\r\n      }\r\n\r\n      function getPersistedLevel() {\r\n          var storedLevel;\r\n\r\n          try {\r\n              storedLevel = window.localStorage[storageKey];\r\n          } catch (ignore) {}\r\n\r\n          if (typeof storedLevel === undefinedType) {\r\n              try {\r\n                  var cookie = window.document.cookie;\r\n                  var location = cookie.indexOf(\r\n                      encodeURIComponent(storageKey) + \"=\");\r\n                  if (location) {\r\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\r\n                  }\r\n              } catch (ignore) {}\r\n          }\r\n\r\n          // If the stored level is not valid, treat it as if nothing was stored.\r\n          if (self.levels[storedLevel] === undefined) {\r\n              storedLevel = undefined;\r\n          }\r\n\r\n          return storedLevel;\r\n      }\r\n\r\n      /*\r\n       *\r\n       * Public API\r\n       *\r\n       */\r\n\r\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n          \"ERROR\": 4, \"SILENT\": 5};\r\n\r\n      self.methodFactory = factory || defaultMethodFactory;\r\n\r\n      self.getLevel = function () {\r\n          return currentLevel;\r\n      };\r\n\r\n      self.setLevel = function (level, persist) {\r\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n              level = self.levels[level.toUpperCase()];\r\n          }\r\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n              currentLevel = level;\r\n              if (persist !== false) {  // defaults to true\r\n                  persistLevelIfPossible(level);\r\n              }\r\n              replaceLoggingMethods.call(self, level, name);\r\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\r\n                  return \"No console available for logging\";\r\n              }\r\n          } else {\r\n              throw \"log.setLevel() called with invalid level: \" + level;\r\n          }\r\n      };\r\n\r\n      self.setDefaultLevel = function (level) {\r\n          if (!getPersistedLevel()) {\r\n              self.setLevel(level, false);\r\n          }\r\n      };\r\n\r\n      self.enableAll = function(persist) {\r\n          self.setLevel(self.levels.TRACE, persist);\r\n      };\r\n\r\n      self.disableAll = function(persist) {\r\n          self.setLevel(self.levels.SILENT, persist);\r\n      };\r\n\r\n      // Initialize with the right level\r\n      var initialLevel = getPersistedLevel();\r\n      if (initialLevel == null) {\r\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\r\n      }\r\n      self.setLevel(initialLevel, false);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * Package-level API\r\n     *\r\n     */\r\n\r\n    var defaultLogger = new Logger();\r\n\r\n    var _loggersByName = {};\r\n    defaultLogger.getLogger = function getLogger(name) {\r\n        if (typeof name !== \"string\" || name === \"\") {\r\n          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n        }\r\n\r\n        var logger = _loggersByName[name];\r\n        if (!logger) {\r\n          logger = _loggersByName[name] = new Logger(\r\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\r\n        }\r\n        return logger;\r\n    };\r\n\r\n    // Grab the current global log variable in case of overwrite\r\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\r\n    defaultLogger.noConflict = function() {\r\n        if (typeof window !== undefinedType &&\r\n               window.log === defaultLogger) {\r\n            window.log = _log;\r\n        }\r\n\r\n        return defaultLogger;\r\n    };\r\n\r\n    return defaultLogger;\r\n}));\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/loglevel/lib/loglevel.js\n ** module id = 2\n ** module chunks = 0\n **/","/*!\n *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the same directory as\n *  this source file.\n * @ignore\n */\n\n/* More information about these options at jshint.com/docs/options */\n\n/* jshint browser: true, camelcase: true, curly: true, devel: true,\neqeqeq: true, forin: false, globalstrict: true, quotmark: single,\nundef: true, unused: strict */\n\n/* global mozRTCIceCandidate, mozRTCPeerConnection,\nmozRTCSessionDescription, webkitRTCPeerConnection */\n\n/* exported trace */\n\n'use strict';\n\nvar RTCPeerConnection = null;\nvar getUserMedia = null;\nvar attachMediaStream = null;\nvar reattachMediaStream = null;\nvar webrtcDetectedBrowser = null;\nvar webrtcDetectedVersion = null;\n\nfunction trace(text) {\n  // This function is used for logging.\n  if (text[text.length - 1] === '\\n') {\n    text = text.substring(0, text.length - 1);\n  }\n  console.log((window.performance.now() / 1000).toFixed(3) + ': ' + text);\n}\n\nfunction maybeFixConfiguration(pcConfig) {\n  if (!pcConfig) {\n    return;\n  }\n  for (var i = 0; i < pcConfig.iceServers.length; i++) {\n    if (pcConfig.iceServers[i].hasOwnProperty('urls')) {\n      pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;\n      delete pcConfig.iceServers[i].urls;\n    }\n  }\n}\n\nif (navigator.mozGetUserMedia) {\n  console.log('This appears to be Firefox');\n\n  webrtcDetectedBrowser = 'firefox';\n\n  webrtcDetectedVersion =\n    parseInt(navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1], 10);\n\n  // The RTCPeerConnection object.\n  RTCPeerConnection = function(pcConfig, pcConstraints) {\n    // .urls is not supported in FF yet.\n    maybeFixConfiguration(pcConfig);\n    return new mozRTCPeerConnection(pcConfig, pcConstraints);\n  };\n\n  // The RTCSessionDescription object.\n  window.RTCSessionDescription = mozRTCSessionDescription;\n\n  // The RTCIceCandidate object.\n  window.RTCIceCandidate = mozRTCIceCandidate;\n\n  // getUserMedia shim (only difference is the prefix).\n  // Code from Adam Barth.\n  getUserMedia = navigator.mozGetUserMedia.bind(navigator);\n  navigator.getUserMedia = getUserMedia;\n\n  // Creates ICE server from the URL for FF.\n  window.createIceServer = function(url, username, password) {\n    var iceServer = null;\n    var urlParts = url.split(':');\n    if (urlParts[0].indexOf('stun') === 0) {\n      // Create ICE server with STUN URL.\n      iceServer = {\n        'url': url\n      };\n    } else if (urlParts[0].indexOf('turn') === 0) {\n      if (webrtcDetectedVersion < 27) {\n        // Create iceServer with turn url.\n        // Ignore the transport parameter from TURN url for FF version <=27.\n        var turnUrlParts = url.split('?');\n        // Return null for createIceServer if transport=tcp.\n        if (turnUrlParts.length === 1 ||\n          turnUrlParts[1].indexOf('transport=udp') === 0) {\n          iceServer = {\n            'url': turnUrlParts[0],\n            'credential': password,\n            'username': username\n          };\n        }\n      } else {\n        // FF 27 and above supports transport parameters in TURN url,\n        // So passing in the full url to create iceServer.\n        iceServer = {\n          'url': url,\n          'credential': password,\n          'username': username\n        };\n      }\n    }\n    return iceServer;\n  };\n\n  window.createIceServers = function(urls, username, password) {\n    var iceServers = [];\n    // Use .url for FireFox.\n    for (var i = 0; i < urls.length; i++) {\n      var iceServer =\n        window.createIceServer(urls[i], username, password);\n      if (iceServer !== null) {\n        iceServers.push(iceServer);\n      }\n    }\n    return iceServers;\n  };\n\n  // Attach a media stream to an element.\n  attachMediaStream = function(element, stream) {\n    //console.log('Attaching media stream');\n    element.mozSrcObject = stream;\n    setTimeout(function () {\n      element.play();\n    }, 100);\n  };\n\n  reattachMediaStream = function(to, from) {\n    //console.log('Reattaching media stream');\n    to.mozSrcObject = from.mozSrcObject;\n  };\n\n} else if (navigator.webkitGetUserMedia) {\n  console.log('This appears to be Chrome');\n\n  webrtcDetectedBrowser = 'chrome';\n  // Temporary fix until crbug/374263 is fixed.\n  // Setting Chrome version to 999, if version is unavailable.\n  var result = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n  if (result !== null) {\n    webrtcDetectedVersion = parseInt(result[2], 10);\n  } else {\n    webrtcDetectedVersion = 999;\n  }\n\n  // Creates iceServer from the url for Chrome M33 and earlier.\n  window.createIceServer = function(url, username, password) {\n    var iceServer = null;\n    var urlParts = url.split(':');\n    if (urlParts[0].indexOf('stun') === 0) {\n      // Create iceServer with stun url.\n      iceServer = {\n        'url': url\n      };\n    } else if (urlParts[0].indexOf('turn') === 0) {\n      // Chrome M28 & above uses below TURN format.\n      iceServer = {\n        'url': url,\n        'credential': password,\n        'username': username\n      };\n    }\n    return iceServer;\n  };\n\n  // Creates iceServers from the urls for Chrome M34 and above.\n  window.createIceServers = function(urls, username, password) {\n    var iceServers = [];\n    if (webrtcDetectedVersion >= 34) {\n      // .urls is supported since Chrome M34.\n      iceServers = {\n        'urls': urls,\n        'credential': password,\n        'username': username\n      };\n    } else {\n      for (var i = 0; i < urls.length; i++) {\n        var iceServer =\n          window.createIceServer(urls[i], username, password);\n        if (iceServer !== null) {\n          iceServers.push(iceServer);\n        }\n      }\n    }\n    return iceServers;\n  };\n\n  // The RTCPeerConnection object.\n  RTCPeerConnection = function(pcConfig, pcConstraints) {\n    // .urls is supported since Chrome M34.\n    if (webrtcDetectedVersion < 34) {\n      maybeFixConfiguration(pcConfig);\n    }\n    return new webkitRTCPeerConnection(pcConfig, pcConstraints);\n  };\n\n  // Get UserMedia (only difference is the prefix).\n  // Code from Adam Barth.\n  getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n  navigator.getUserMedia = getUserMedia;\n\n  // Attach a media stream to an element.\n  attachMediaStream = function(element, stream) {\n    if (typeof element.srcObject !== 'undefined') {\n      element.srcObject = stream;\n    } else if (typeof element.mozSrcObject !== 'undefined') {\n      element.mozSrcObject = stream;\n    } else if (typeof element.src !== 'undefined') {\n      element.src = URL.createObjectURL(stream);\n    } else {\n      console.log('Error attaching stream to element.');\n    }\n  };\n\n  reattachMediaStream = function(to, from) {\n    to.src = from.src;\n  };\n} else {\n  console.log('Browser does not appear to be WebRTC-capable');\n}\n\n\nwindow.RTCPeerConnection = RTCPeerConnection;\nwindow.getUserMedia = getUserMedia;\nwindow.attachMediaStream = attachMediaStream;\nwindow.reattachMediaStream = reattachMediaStream;\nwindow.webrtcDetectedBrowser = webrtcDetectedBrowser;\nwindow.webrtcDetectedVersion = webrtcDetectedVersion;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/deps/adapter.js\n ** module id = 3\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar log = require('loglevel');\nvar respokeClass = require('./class');\n\n/**\n * Higher order function to wrap a passed in function. The returned function will only execute\n * the passed in function the first time it is called, then be a no-op any subsequent tries.\n *\n * @private\n */\nvar callOnce = function (func) {\n    \"use strict\";\n    return (function () {\n        var called = false;\n        return function () {\n            if (!called) {\n                func.apply(null, arguments);\n                called = true;\n            }\n        };\n    })();\n};\n\n/**\n * A generic class for emitting and listening to events. This is used internally by respoke.js\n * to provide evented behavior. You can add custom events and inherit your own objects from\n * the EventEmitter.\n *\n * ```\n * // Adding a custom event to a respoke.Client instance\n * client.listen('my-event', function (evt) { });\n * client.fire('my-event', { name: 'my-event', asdf: 'jkl' });\n * ```\n *\n * ```\n * // Custom EventEmitter\n * var MyCustomEmitter = respoke.EventEmitter();\n * var emitterInstance = MyCustomEmitter();\n * emitterInstance.fire('hi', { name: 'hi', message: 'hello' });\n * emitterInstance.listen('hi', function (evt) { });\n * ```\n *\n * @class respoke.EventEmitter\n * @inherits respoke.Class\n * @constructor\n * @param {object} params\n * @param {string} params.instanceId\n * @returns {respoke.EventEmitter}\n */\nvar EventEmitter = module.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = respokeClass(params);\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.EventEmitter\n     * @name className\n     * @type {string}\n     * @private\n     */\n    that.className = 'respoke.EventEmitter';\n\n    /**\n     * @memberof! respoke.EventEmitter\n     * @name eventList\n     * @private\n     * @type {object}\n     */\n    var eventList = {};\n\n    /**\n     * Add a listener that will only be called once to an object.  This method adds the given listener to the given\n     * event in the case that the same\n     * listener is not already registered to this event and the listener is a function.  The third argument 'isInternal'\n     * is used only internally by the library to indicate that this listener is a library-used listener and should not\n     * count when we are trying to determine if an event has listeners placed by the developer.\n     *\n     *     client.once('connect', function (evt) {\n     *         console.log(\"This is the first time we connected.\");\n     *     });\n     *\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.listen\n     * @param {string} eventType - A developer-specified string identifying the event.\n     * @param {respoke.EventEmitter.eventListener} listener - A function to call when the event is fire.\n     * @param {boolean} [isInternal] - A flag to indicate this listener was added by the library. This parameter should\n     * not be used by developers who are using the library, only by developers who are working on the library itself.\n     */\n    that.once = function (eventType, listener, isInternal) {\n        var string = listener.toString();\n        listener = callOnce(listener);\n        listener.toString = function () { return string; };\n        listener.once = true;\n        that.listen(eventType, listener, isInternal);\n    };\n\n    /**\n     * Add a `listener` function to an object.\n     *\n     * This method adds the `listener` to the event `eventName`.\n     *\n     * If an identical listener already registered to this event, it will **not** be added.\n     *\n     * ##### Example of adding an event listener.\n     *\n     *     client.listen('connect', function (evt) {\n     *         console.log(\"We've connected!\", evt);\n     *     });\n     *\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.listen\n     * @param {string} eventType - The name of the event.\n     * @param {respoke.EventEmitter.eventListener} listener - A function to call when the event is\n     * fired.\n     * @arg {boolean} isInternal - Internal use only. A flag to indicate this listener was\n     * added by the library. This parameter should not be used by developers who are using\n     * the library, only by developers who are working on the library itself.\n     */\n    that.listen = function (eventType, listener, isInternal) {\n        if (listener === undefined) {\n            return;\n        }\n        var invalidEventType = typeof eventType !== 'string' || !eventType;\n        var invalidListener = typeof listener !== 'function';\n        if (invalidEventType || invalidListener) {\n            log.error(\"Invalid request to add event listener to\", eventType, listener);\n            return;\n        }\n\n        eventList[eventType] = eventList[eventType] || [];\n        listener.isInternal = !!isInternal; // boolify\n\n        var toString = function (fn) {\n            return fn.toString();\n        };\n        var isNotAlreadyAdded = eventList[eventType].map(toString).indexOf(listener.toString()) === -1;\n\n        if (isNotAlreadyAdded) {\n            eventList[eventType].push(listener);\n        } else {\n            log.warn(\"Not adding duplicate listener to\", eventType, listener);\n        }\n    };\n\n    /**\n     * Remove a listener from an object. If no eventType is specified, all eventTypes will be\n     * cleared. If an eventType is specified but no listener is specified, all listeners will be\n     * removed from the specified eventType.  If a listener is also specified, only that listener\n     * will be removed.\n     *\n     *     client.ignore('connect', connectHandler);\n     *\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.ignore\n     * @param {string} [eventType] - An optional developer-specified string identifying the event.\n     * @param {function} [listener] - An optional function to remove from the specified event.\n     */\n    that.ignore = function (eventType, listener) {\n        // Remove all events from this object\n        if (eventType === undefined) {\n            eventList = {};\n            return;\n        }\n\n        // Remove all listeners from this event.\n        if (listener === undefined || !eventList[eventType]) {\n            eventList[eventType] = [];\n            return;\n        }\n\n        // Remove only one listener from this event.\n        for (var i = eventList[eventType].length - 1; i >= 0; i -= 1) {\n            if (listener === eventList[eventType][i]) {\n                eventList[eventType].splice(i, 1);\n                return;\n            }\n        }\n    };\n\n    /**\n     * Trigger an event on an object. All listeners for the specified eventType will be called.\n     * Listeners will be bound to the object ('this' will refer to the object), and additional\n     * arguments to fire() will be passed into each listener.\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.fire\n     * @param {string} eventType - A developer-specified string identifying the event to fire.\n     * @param {string|number|object|array} evt - Any number of optional parameters to be passed to\n     * the listener\n     * @private\n     */\n    that.fire = function (eventType, evt) {\n        var args = null;\n        var count = 0;\n        var toRemove = [];\n        var i;\n\n        evt = evt || {};\n        evt.name = eventType;\n        evt.target = that;\n\n        if (!eventType) {\n            return;\n        }\n\n        if (!eventList[eventType]) {\n            log.debug(\"fired \" + that.className + \"#\" + eventType + \" 0 listeners called with params\", evt);\n            return;\n        }\n\n        for (i = 0; i < eventList[eventType].length; i += 1) {\n            var listener = eventList[eventType][i];\n            if (typeof listener === 'function') {\n                setTimeout(listenerBuilder(listener, evt, eventType));\n\n                count += 1;\n                if (listener.once === true) {\n                    toRemove.push(i);\n                }\n            }\n        }\n\n        for (i = (toRemove.length - 1); i >= 0; i -= 1) {\n            eventList[eventType].splice(toRemove[i], 1);\n        }\n\n        log.debug(\"fired \" + that.className + \"#\" + eventType + \" \" + count + \" listeners called with params\", evt);\n    };\n\n    function listenerBuilder(listener, evt, eventType) {\n        return function () {\n            try {\n                listener.call(that, evt);\n            } catch (e) {\n                log.error('Error in ' + that.className + \"#\" + eventType, e.message, e.stack);\n            }\n        };\n    }\n\n    /**\n     * Determine if an object has had any listeners registered for a given event outside the library. This method\n     * checks for the isInternal flag on each listener and doesn't count it toward an event being listened to. This\n     * method is used in the library to handle situations where an action is needed if an event won't be acted on.\n     * For instance, if a call comes in for the logged-in user, but the developer isn't listening to\n     * {respoke.Client#call}, we'll need to reject the call immediately.\n     *\n     *     if (client.hasListeners('call')) {\n     *         // already handled!\n     *     }\n     *\n     * @memberof! respoke.EventEmitter\n     * @method respoke.EventEmitter.hasListeners\n     * @param {string} eventType - The name of the event\n     * @returns {boolean} Whether this event has any listeners that are external to this library.\n     */\n    that.hasListeners = function (eventType) {\n        if (eventType === undefined) {\n            throw new Error(\"Missing required parameter event type.\");\n        }\n\n        if (!eventList[eventType]) {\n            return false;\n        }\n\n        return !eventList[eventType].every(function eachListener(listener) {\n            return listener.isInternal;\n        });\n    };\n\n    return that;\n}; // End respoke.EventEmitter\n/**\n * @callback respoke.EventEmitter.eventListener\n * @param {respoke.Event} evt\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/event.js\n ** module id = 4\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\n/**\n * Empty base class. Use params.that (if exists) for the base object, but delete it from the instance.\n * Copy all params that were passed in onto the base object. Add the class name.\n * @class respoke.Class\n * @private\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = params.that || {};\n\n    that.className = 'respoke.Class';\n    delete params.that;\n    delete that.client;\n\n    Object.keys(params).forEach(function copyParam(name) {\n        that[name] = params[name];\n    });\n\n    return that;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/class.js\n ** module id = 5\n ** module chunks = 0\n **/","/*! Socket.IO.js build:0.9.17, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\n\nvar io = ('undefined' === typeof module ? {} : module.exports);\n(function() {\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, global) {\n\n  /**\n   * IO namespace.\n   *\n   * @namespace\n   */\n\n  var io = exports;\n\n  /**\n   * Socket.IO version\n   *\n   * @api public\n   */\n\n  io.version = '0.9.17';\n\n  /**\n   * Protocol implemented.\n   *\n   * @api public\n   */\n\n  io.protocol = 1;\n\n  /**\n   * Available transports, these will be populated with the available transports\n   *\n   * @api public\n   */\n\n  io.transports = [];\n\n  /**\n   * Keep track of jsonp callbacks.\n   *\n   * @api private\n   */\n\n  io.j = [];\n\n  /**\n   * Keep track of our io.Sockets\n   *\n   * @api private\n   */\n  io.sockets = {};\n\n\n  /**\n   * Manages connections to hosts.\n   *\n   * @param {String} uri\n   * @Param {Boolean} force creation of new socket (defaults to false)\n   * @api public\n   */\n\n  io.connect = function (host, details) {\n    var uri = io.util.parseUri(host)\n      , uuri\n      , socket;\n\n    if (global && global.location) {\n      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\n      uri.host = uri.host || (global.document\n        ? global.document.domain : global.location.hostname);\n      uri.port = uri.port || global.location.port;\n    }\n\n    uuri = io.util.uniqueUri(uri);\n\n    var options = {\n        host: uri.host\n      , secure: 'https' == uri.protocol\n      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\n      , query: uri.query || ''\n    };\n\n    io.util.merge(options, details);\n\n    if (options['force new connection'] || !io.sockets[uuri]) {\n      socket = new io.Socket(options);\n    }\n\n    if (!options['force new connection'] && socket) {\n      io.sockets[uuri] = socket;\n    }\n\n    socket = socket || io.sockets[uuri];\n\n    // if path is different from '' or /\n    return socket.of(uri.path.length > 1 ? uri.path : '');\n  };\n\n})('object' === typeof module ? module.exports : (this.io = {}), this);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, global) {\n\n  /**\n   * Utilities namespace.\n   *\n   * @namespace\n   */\n\n  var util = exports.util = {};\n\n  /**\n   * Parses an URI\n   *\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\n   * @api public\n   */\n\n  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\n  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\n               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\n               'anchor'];\n\n  util.parseUri = function (str) {\n    var m = re.exec(str || '')\n      , uri = {}\n      , i = 14;\n\n    while (i--) {\n      uri[parts[i]] = m[i] || '';\n    }\n\n    return uri;\n  };\n\n  /**\n   * Produces a unique url that identifies a Socket.IO connection.\n   *\n   * @param {Object} uri\n   * @api public\n   */\n\n  util.uniqueUri = function (uri) {\n    var protocol = uri.protocol\n      , host = uri.host\n      , port = uri.port;\n\n    if ('document' in global) {\n      host = host || document.domain;\n      port = port || (protocol == 'https'\n        && document.location.protocol !== 'https:' ? 443 : document.location.port);\n    } else {\n      host = host || 'localhost';\n\n      if (!port && protocol == 'https') {\n        port = 443;\n      }\n    }\n\n    return (protocol || 'http') + '://' + host + ':' + (port || 80);\n  };\n\n  /**\n   * Mergest 2 query strings in to once unique query string\n   *\n   * @param {String} base\n   * @param {String} addition\n   * @api public\n   */\n\n  util.query = function (base, addition) {\n    var query = util.chunkQuery(base || '')\n      , components = [];\n\n    util.merge(query, util.chunkQuery(addition || ''));\n    for (var part in query) {\n      if (query.hasOwnProperty(part)) {\n        components.push(part + '=' + query[part]);\n      }\n    }\n\n    return components.length ? '?' + components.join('&') : '';\n  };\n\n  /**\n   * Transforms a querystring in to an object\n   *\n   * @param {String} qs\n   * @api public\n   */\n\n  util.chunkQuery = function (qs) {\n    var query = {}\n      , params = qs.split('&')\n      , i = 0\n      , l = params.length\n      , kv;\n\n    for (; i < l; ++i) {\n      kv = params[i].split('=');\n      if (kv[0]) {\n        query[kv[0]] = kv[1];\n      }\n    }\n\n    return query;\n  };\n\n  /**\n   * Executes the given function when the page is loaded.\n   *\n   *     io.util.load(function () { console.log('page loaded'); });\n   *\n   * @param {Function} fn\n   * @api public\n   */\n\n  var pageLoaded = false;\n\n  util.load = function (fn) {\n    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\n      return fn();\n    }\n\n    util.on(global, 'load', fn, false);\n  };\n\n  /**\n   * Adds an event.\n   *\n   * @api private\n   */\n\n  util.on = function (element, event, fn, capture) {\n    if (element.attachEvent) {\n      element.attachEvent('on' + event, fn);\n    } else if (element.addEventListener) {\n      element.addEventListener(event, fn, capture);\n    }\n  };\n\n  /**\n   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\n   *\n   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\n   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\n   * @api private\n   */\n\n  util.request = function (xdomain) {\n\n    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {\n      return new XDomainRequest();\n    }\n\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\n      return new XMLHttpRequest();\n    }\n\n    if (!xdomain) {\n      try {\n        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');\n      } catch(e) { }\n    }\n\n    return null;\n  };\n\n  /**\n   * XHR based transport constructor.\n   *\n   * @constructor\n   * @api public\n   */\n\n  /**\n   * Change the internal pageLoaded value.\n   */\n\n  if ('undefined' != typeof window) {\n    util.load(function () {\n      pageLoaded = true;\n    });\n  }\n\n  /**\n   * Defers a function to ensure a spinner is not displayed by the browser\n   *\n   * @param {Function} fn\n   * @api public\n   */\n\n  util.defer = function (fn) {\n    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\n      return fn();\n    }\n\n    util.load(function () {\n      setTimeout(fn, 100);\n    });\n  };\n\n  /**\n   * Merges two objects.\n   *\n   * @api public\n   */\n\n  util.merge = function merge (target, additional, deep, lastseen) {\n    var seen = lastseen || []\n      , depth = typeof deep == 'undefined' ? 2 : deep\n      , prop;\n\n    for (prop in additional) {\n      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\n        if (typeof target[prop] !== 'object' || !depth) {\n          target[prop] = additional[prop];\n          seen.push(additional[prop]);\n        } else {\n          util.merge(target[prop], additional[prop], depth - 1, seen);\n        }\n      }\n    }\n\n    return target;\n  };\n\n  /**\n   * Merges prototypes from objects\n   *\n   * @api public\n   */\n\n  util.mixin = function (ctor, ctor2) {\n    util.merge(ctor.prototype, ctor2.prototype);\n  };\n\n  /**\n   * Shortcut for prototypical and static inheritance.\n   *\n   * @api private\n   */\n\n  util.inherit = function (ctor, ctor2) {\n    function f() {};\n    f.prototype = ctor2.prototype;\n    ctor.prototype = new f;\n  };\n\n  /**\n   * Checks if the given object is an Array.\n   *\n   *     io.util.isArray([]); // true\n   *     io.util.isArray({}); // false\n   *\n   * @param Object obj\n   * @api public\n   */\n\n  util.isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  /**\n   * Intersects values of two arrays into a third\n   *\n   * @api public\n   */\n\n  util.intersect = function (arr, arr2) {\n    var ret = []\n      , longest = arr.length > arr2.length ? arr : arr2\n      , shortest = arr.length > arr2.length ? arr2 : arr;\n\n    for (var i = 0, l = shortest.length; i < l; i++) {\n      if (~util.indexOf(longest, shortest[i]))\n        ret.push(shortest[i]);\n    }\n\n    return ret;\n  };\n\n  /**\n   * Array indexOf compatibility.\n   *\n   * @see bit.ly/a5Dxa2\n   * @api public\n   */\n\n  util.indexOf = function (arr, o, i) {\n\n    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;\n         i < j && arr[i] !== o; i++) {}\n\n    return j <= i ? -1 : i;\n  };\n\n  /**\n   * Converts enumerables to array.\n   *\n   * @api public\n   */\n\n  util.toArray = function (enu) {\n    var arr = [];\n\n    for (var i = 0, l = enu.length; i < l; i++)\n      arr.push(enu[i]);\n\n    return arr;\n  };\n\n  /**\n   * UA / engines detection namespace.\n   *\n   * @namespace\n   */\n\n  util.ua = {};\n\n  /**\n   * Whether the UA supports CORS for XHR.\n   *\n   * @api public\n   */\n\n  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\n    try {\n      var a = new XMLHttpRequest();\n    } catch (e) {\n      return false;\n    }\n\n    return a.withCredentials != undefined;\n  })();\n\n  /**\n   * Detect webkit.\n   *\n   * @api public\n   */\n\n  util.ua.webkit = 'undefined' != typeof navigator\n    && /webkit/i.test(navigator.userAgent);\n\n   /**\n   * Detect iPad/iPhone/iPod.\n   *\n   * @api public\n   */\n\n  util.ua.iDevice = 'undefined' != typeof navigator\n      && /iPad|iPhone|iPod/i.test(navigator.userAgent);\n\n})('undefined' != typeof io ? io : module.exports, this);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.EventEmitter = EventEmitter;\n\n  /**\n   * Event emitter constructor.\n   *\n   * @api public.\n   */\n\n  function EventEmitter () {};\n\n  /**\n   * Adds a listener\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.on = function (name, fn) {\n    if (!this.$events) {\n      this.$events = {};\n    }\n\n    if (!this.$events[name]) {\n      this.$events[name] = fn;\n    } else if (io.util.isArray(this.$events[name])) {\n      this.$events[name].push(fn);\n    } else {\n      this.$events[name] = [this.$events[name], fn];\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  /**\n   * Adds a volatile listener.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.once = function (name, fn) {\n    var self = this;\n\n    function on () {\n      self.removeListener(name, on);\n      fn.apply(this, arguments);\n    };\n\n    on.listener = fn;\n    this.on(name, on);\n\n    return this;\n  };\n\n  /**\n   * Removes a listener.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.removeListener = function (name, fn) {\n    if (this.$events && this.$events[name]) {\n      var list = this.$events[name];\n\n      if (io.util.isArray(list)) {\n        var pos = -1;\n\n        for (var i = 0, l = list.length; i < l; i++) {\n          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n            pos = i;\n            break;\n          }\n        }\n\n        if (pos < 0) {\n          return this;\n        }\n\n        list.splice(pos, 1);\n\n        if (!list.length) {\n          delete this.$events[name];\n        }\n      } else if (list === fn || (list.listener && list.listener === fn)) {\n        delete this.$events[name];\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Removes all listeners for an event.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.removeAllListeners = function (name) {\n    if (name === undefined) {\n      this.$events = {};\n      return this;\n    }\n\n    if (this.$events && this.$events[name]) {\n      this.$events[name] = null;\n    }\n\n    return this;\n  };\n\n  /**\n   * Gets all listeners for a certain event.\n   *\n   * @api publci\n   */\n\n  EventEmitter.prototype.listeners = function (name) {\n    if (!this.$events) {\n      this.$events = {};\n    }\n\n    if (!this.$events[name]) {\n      this.$events[name] = [];\n    }\n\n    if (!io.util.isArray(this.$events[name])) {\n      this.$events[name] = [this.$events[name]];\n    }\n\n    return this.$events[name];\n  };\n\n  /**\n   * Emits an event.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.emit = function (name) {\n    if (!this.$events) {\n      return false;\n    }\n\n    var handler = this.$events[name];\n\n    if (!handler) {\n      return false;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if ('function' == typeof handler) {\n      handler.apply(this, args);\n    } else if (io.util.isArray(handler)) {\n      var listeners = handler.slice();\n\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].apply(this, args);\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Based on JSON2 (http://www.JSON.org/js.html).\n */\n\n(function (exports, nativeJSON) {\n  \"use strict\";\n\n  // use native JSON if it's available\n  if (nativeJSON && nativeJSON.parse){\n    return exports.JSON = {\n      parse: nativeJSON.parse\n    , stringify: nativeJSON.stringify\n    };\n  }\n\n  var JSON = exports.JSON = {};\n\n  function f(n) {\n      // Format integers to have at least two digits.\n      return n < 10 ? '0' + n : n;\n  }\n\n  function date(d, key) {\n    return isFinite(d.valueOf()) ?\n        d.getUTCFullYear()     + '-' +\n        f(d.getUTCMonth() + 1) + '-' +\n        f(d.getUTCDate())      + 'T' +\n        f(d.getUTCHours())     + ':' +\n        f(d.getUTCMinutes())   + ':' +\n        f(d.getUTCSeconds())   + 'Z' : null;\n  };\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      gap,\n      indent,\n      meta = {    // table of character substitutions\n          '\\b': '\\\\b',\n          '\\t': '\\\\t',\n          '\\n': '\\\\n',\n          '\\f': '\\\\f',\n          '\\r': '\\\\r',\n          '\"' : '\\\\\"',\n          '\\\\': '\\\\\\\\'\n      },\n      rep;\n\n\n  function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n      escapable.lastIndex = 0;\n      return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n          var c = meta[a];\n          return typeof c === 'string' ? c :\n              '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + string + '\"';\n  }\n\n\n  function str(key, holder) {\n\n// Produce a string from holder[key].\n\n      var i,          // The loop counter.\n          k,          // The member key.\n          v,          // The member value.\n          length,\n          mind = gap,\n          partial,\n          value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n      if (value instanceof Date) {\n          value = date(key);\n      }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n      if (typeof rep === 'function') {\n          value = rep.call(holder, key, value);\n      }\n\n// What happens next depends on the value's type.\n\n      switch (typeof value) {\n      case 'string':\n          return quote(value);\n\n      case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n          return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n      case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n          return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n      case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n          if (!value) {\n              return 'null';\n          }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n          gap += indent;\n          partial = [];\n\n// Is the value an array?\n\n          if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n              length = value.length;\n              for (i = 0; i < length; i += 1) {\n                  partial[i] = str(i, value) || 'null';\n              }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n              v = partial.length === 0 ? '[]' : gap ?\n                  '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                  '[' + partial.join(',') + ']';\n              gap = mind;\n              return v;\n          }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n          if (rep && typeof rep === 'object') {\n              length = rep.length;\n              for (i = 0; i < length; i += 1) {\n                  if (typeof rep[i] === 'string') {\n                      k = rep[i];\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n          v = partial.length === 0 ? '{}' : gap ?\n              '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n              '{' + partial.join(',') + '}';\n          gap = mind;\n          return v;\n      }\n  }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n  JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n      var i;\n      gap = '';\n      indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n      if (typeof space === 'number') {\n          for (i = 0; i < space; i += 1) {\n              indent += ' ';\n          }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n      } else if (typeof space === 'string') {\n          indent = space;\n      }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n      rep = replacer;\n      if (replacer && typeof replacer !== 'function' &&\n              (typeof replacer !== 'object' ||\n              typeof replacer.length !== 'number')) {\n          throw new Error('JSON.stringify');\n      }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n      return str('', {'': value});\n  };\n\n// If the JSON object does not yet have a parse method, give it one.\n\n  JSON.parse = function (text, reviver) {\n  // The parse method takes a text and an optional reviver function, and returns\n  // a JavaScript value if the text is a valid JSON text.\n\n      var j;\n\n      function walk(holder, key) {\n\n  // The walk method is used to recursively walk the resulting structure so\n  // that modifications can be made.\n\n          var k, v, value = holder[key];\n          if (value && typeof value === 'object') {\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = walk(value, k);\n                      if (v !== undefined) {\n                          value[k] = v;\n                      } else {\n                          delete value[k];\n                      }\n                  }\n              }\n          }\n          return reviver.call(holder, key, value);\n      }\n\n\n  // Parsing happens in four stages. In the first stage, we replace certain\n  // Unicode characters with escape sequences. JavaScript handles many characters\n  // incorrectly, either silently deleting them, or treating them as line endings.\n\n      text = String(text);\n      cx.lastIndex = 0;\n      if (cx.test(text)) {\n          text = text.replace(cx, function (a) {\n              return '\\\\u' +\n                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n          });\n      }\n\n  // In the second stage, we run the text against regular expressions that look\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n  // because they can cause invocation, and '=' because it can cause mutation.\n  // But just to be safe, we want to reject all unexpected forms.\n\n  // We split the second stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n      if (/^[\\],:{}\\s]*$/\n              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n  // In the third stage we use the eval function to compile the text into a\n  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n  // in JavaScript: it can begin a block or an object literal. We wrap the text\n  // in parens to eliminate the ambiguity.\n\n          j = eval('(' + text + ')');\n\n  // In the optional fourth stage, we recursively walk the new structure, passing\n  // each name/value pair to a reviver function for possible transformation.\n\n          return typeof reviver === 'function' ?\n              walk({'': j}, '') : j;\n      }\n\n  // If the text is not JSON parseable, then a SyntaxError is thrown.\n\n      throw new SyntaxError('JSON.parse');\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , typeof JSON !== 'undefined' ? JSON : undefined\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Parser namespace.\n   *\n   * @namespace\n   */\n\n  var parser = exports.parser = {};\n\n  /**\n   * Packet types.\n   */\n\n  var packets = parser.packets = [\n      'disconnect'\n    , 'connect'\n    , 'heartbeat'\n    , 'message'\n    , 'json'\n    , 'event'\n    , 'ack'\n    , 'error'\n    , 'noop'\n  ];\n\n  /**\n   * Errors reasons.\n   */\n\n  var reasons = parser.reasons = [\n      'transport not supported'\n    , 'client not handshaken'\n    , 'unauthorized'\n  ];\n\n  /**\n   * Errors advice.\n   */\n\n  var advice = parser.advice = [\n      'reconnect'\n  ];\n\n  /**\n   * Shortcuts.\n   */\n\n  var JSON = io.JSON\n    , indexOf = io.util.indexOf;\n\n  /**\n   * Encodes a packet.\n   *\n   * @api private\n   */\n\n  parser.encodePacket = function (packet) {\n    var type = indexOf(packets, packet.type)\n      , id = packet.id || ''\n      , endpoint = packet.endpoint || ''\n      , ack = packet.ack\n      , data = null;\n\n    switch (packet.type) {\n      case 'error':\n        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\n          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\n\n        if (reason !== '' || adv !== '')\n          data = reason + (adv !== '' ? ('+' + adv) : '');\n\n        break;\n\n      case 'message':\n        if (packet.data !== '')\n          data = packet.data;\n        break;\n\n      case 'event':\n        var ev = { name: packet.name };\n\n        if (packet.args && packet.args.length) {\n          ev.args = packet.args;\n        }\n\n        data = JSON.stringify(ev);\n        break;\n\n      case 'json':\n        data = JSON.stringify(packet.data);\n        break;\n\n      case 'connect':\n        if (packet.qs)\n          data = packet.qs;\n        break;\n\n      case 'ack':\n        data = packet.ackId\n          + (packet.args && packet.args.length\n              ? '+' + JSON.stringify(packet.args) : '');\n        break;\n    }\n\n    // construct packet with required fragments\n    var encoded = [\n        type\n      , id + (ack == 'data' ? '+' : '')\n      , endpoint\n    ];\n\n    // data fragment is optional\n    if (data !== null && data !== undefined)\n      encoded.push(data);\n\n    return encoded.join(':');\n  };\n\n  /**\n   * Encodes multiple messages (payload).\n   *\n   * @param {Array} messages\n   * @api private\n   */\n\n  parser.encodePayload = function (packets) {\n    var decoded = '';\n\n    if (packets.length == 1)\n      return packets[0];\n\n    for (var i = 0, l = packets.length; i < l; i++) {\n      var packet = packets[i];\n      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\n    }\n\n    return decoded;\n  };\n\n  /**\n   * Decodes a packet\n   *\n   * @api private\n   */\n\n  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\n\n  parser.decodePacket = function (data) {\n    var pieces = data.match(regexp);\n\n    if (!pieces) return {};\n\n    var id = pieces[2] || ''\n      , data = pieces[5] || ''\n      , packet = {\n            type: packets[pieces[1]]\n          , endpoint: pieces[4] || ''\n        };\n\n    // whether we need to acknowledge the packet\n    if (id) {\n      packet.id = id;\n      if (pieces[3])\n        packet.ack = 'data';\n      else\n        packet.ack = true;\n    }\n\n    // handle different packet types\n    switch (packet.type) {\n      case 'error':\n        var pieces = data.split('+');\n        packet.reason = reasons[pieces[0]] || '';\n        packet.advice = advice[pieces[1]] || '';\n        break;\n\n      case 'message':\n        packet.data = data || '';\n        break;\n\n      case 'event':\n        try {\n          var opts = JSON.parse(data);\n          packet.name = opts.name;\n          packet.args = opts.args;\n        } catch (e) { }\n\n        packet.args = packet.args || [];\n        break;\n\n      case 'json':\n        try {\n          packet.data = JSON.parse(data);\n        } catch (e) { }\n        break;\n\n      case 'connect':\n        packet.qs = data || '';\n        break;\n\n      case 'ack':\n        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\n        if (pieces) {\n          packet.ackId = pieces[1];\n          packet.args = [];\n\n          if (pieces[3]) {\n            try {\n              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\n            } catch (e) { }\n          }\n        }\n        break;\n\n      case 'disconnect':\n      case 'heartbeat':\n        break;\n    };\n\n    return packet;\n  };\n\n  /**\n   * Decodes data payload. Detects multiple messages\n   *\n   * @return {Array} messages\n   * @api public\n   */\n\n  parser.decodePayload = function (data) {\n    // IE doesn't like data[i] for unicode chars, charAt works fine\n    if (data.charAt(0) == '\\ufffd') {\n      var ret = [];\n\n      for (var i = 1, length = ''; i < data.length; i++) {\n        if (data.charAt(i) == '\\ufffd') {\n          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\n          i += Number(length) + 1;\n          length = '';\n        } else {\n          length += data.charAt(i);\n        }\n      }\n\n      return ret;\n    } else {\n      return [parser.decodePacket(data)];\n    }\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Transport = Transport;\n\n  /**\n   * This is the transport template for all supported transport methods.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function Transport (socket, sessid) {\n    this.socket = socket;\n    this.sessid = sessid;\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Transport, io.EventEmitter);\n\n\n  /**\n   * Indicates whether heartbeats is enabled for this transport\n   *\n   * @api private\n   */\n\n  Transport.prototype.heartbeats = function () {\n    return true;\n  };\n\n  /**\n   * Handles the response from the server. When a new response is received\n   * it will automatically update the timeout, decode the message and\n   * forwards the response to the onMessage function for further processing.\n   *\n   * @param {String} data Response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onData = function (data) {\n    this.clearCloseTimeout();\n\n    // If the connection in currently open (or in a reopening state) reset the close\n    // timeout since we have just received data. This check is necessary so\n    // that we don't reset the timeout on an explicitly disconnected connection.\n    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\n      this.setCloseTimeout();\n    }\n\n    if (data !== '') {\n      // todo: we should only do decodePayload for xhr transports\n      var msgs = io.parser.decodePayload(data);\n\n      if (msgs && msgs.length) {\n        for (var i = 0, l = msgs.length; i < l; i++) {\n          this.onPacket(msgs[i]);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles packets.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onPacket = function (packet) {\n    this.socket.setHeartbeatTimeout();\n\n    if (packet.type == 'heartbeat') {\n      return this.onHeartbeat();\n    }\n\n    if (packet.type == 'connect' && packet.endpoint == '') {\n      this.onConnect();\n    }\n\n    if (packet.type == 'error' && packet.advice == 'reconnect') {\n      this.isOpen = false;\n    }\n\n    this.socket.onPacket(packet);\n\n    return this;\n  };\n\n  /**\n   * Sets close timeout\n   *\n   * @api private\n   */\n\n  Transport.prototype.setCloseTimeout = function () {\n    if (!this.closeTimeout) {\n      var self = this;\n\n      this.closeTimeout = setTimeout(function () {\n        self.onDisconnect();\n      }, this.socket.closeTimeout);\n    }\n  };\n\n  /**\n   * Called when transport disconnects.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onDisconnect = function () {\n    if (this.isOpen) this.close();\n    this.clearTimeouts();\n    this.socket.onDisconnect();\n    return this;\n  };\n\n  /**\n   * Called when transport connects\n   *\n   * @api private\n   */\n\n  Transport.prototype.onConnect = function () {\n    this.socket.onConnect();\n    return this;\n  };\n\n  /**\n   * Clears close timeout\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearCloseTimeout = function () {\n    if (this.closeTimeout) {\n      clearTimeout(this.closeTimeout);\n      this.closeTimeout = null;\n    }\n  };\n\n  /**\n   * Clear timeouts\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearTimeouts = function () {\n    this.clearCloseTimeout();\n\n    if (this.reopenTimeout) {\n      clearTimeout(this.reopenTimeout);\n    }\n  };\n\n  /**\n   * Sends a packet\n   *\n   * @param {Object} packet object.\n   * @api private\n   */\n\n  Transport.prototype.packet = function (packet) {\n    this.send(io.parser.encodePacket(packet));\n  };\n\n  /**\n   * Send the received heartbeat message back to server. So the server\n   * knows we are still connected.\n   *\n   * @param {String} heartbeat Heartbeat response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onHeartbeat = function (heartbeat) {\n    this.packet({ type: 'heartbeat' });\n  };\n\n  /**\n   * Called when the transport opens.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onOpen = function () {\n    this.isOpen = true;\n    this.clearCloseTimeout();\n    this.socket.onOpen();\n  };\n\n  /**\n   * Notifies the base when the connection with the Socket.IO server\n   * has been disconnected.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onClose = function () {\n    var self = this;\n\n    /* FIXME: reopen delay causing a infinit loop\n    this.reopenTimeout = setTimeout(function () {\n      self.open();\n    }, this.socket.options['reopen delay']);*/\n\n    this.isOpen = false;\n    this.socket.onClose();\n    this.onDisconnect();\n  };\n\n  /**\n   * Generates a connection url based on the Socket.IO URL Protocol.\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\n   *\n   * @returns {String} Connection url\n   * @api private\n   */\n\n  Transport.prototype.prepareUrl = function () {\n    var options = this.socket.options;\n\n    return this.scheme() + '://'\n      + options.host + ':' + options.port + '/'\n      + options.resource + '/' + io.protocol\n      + '/' + this.name + '/' + this.sessid;\n  };\n\n  /**\n   * Checks if the transport is ready to start a connection.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Transport.prototype.ready = function (socket, fn) {\n    fn.call(this);\n  };\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Socket = Socket;\n\n  /**\n   * Create a new `Socket.IO client` which can establish a persistent\n   * connection with a Socket.IO enabled server.\n   *\n   * @api public\n   */\n\n  function Socket (options) {\n    this.options = {\n        port: 80\n      , secure: false\n      , document: 'document' in global ? document : false\n      , resource: 'socket.io'\n      , transports: io.transports\n      , 'connect timeout': 10000\n      , 'try multiple transports': true\n      , 'reconnect': true\n      , 'reconnection delay': 500\n      , 'reconnection limit': Infinity\n      , 'reopen delay': 3000\n      , 'max reconnection attempts': 10\n      , 'sync disconnect on unload': false\n      , 'auto connect': true\n      , 'flash policy port': 10843\n      , 'manualFlush': false\n    };\n\n    io.util.merge(this.options, options);\n\n    this.connected = false;\n    this.open = false;\n    this.connecting = false;\n    this.reconnecting = false;\n    this.namespaces = {};\n    this.buffer = [];\n    this.doBuffer = false;\n\n    if (this.options['sync disconnect on unload'] &&\n        (!this.isXDomain() || io.util.ua.hasCORS)) {\n      var self = this;\n      io.util.on(global, 'beforeunload', function () {\n        self.disconnectSync();\n      }, false);\n    }\n\n    if (this.options['auto connect']) {\n      this.connect();\n    }\n};\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Socket, io.EventEmitter);\n\n  /**\n   * Returns a namespace listener/emitter for this socket\n   *\n   * @api public\n   */\n\n  Socket.prototype.of = function (name) {\n    if (!this.namespaces[name]) {\n      this.namespaces[name] = new io.SocketNamespace(this, name);\n\n      if (name !== '') {\n        this.namespaces[name].packet({ type: 'connect' });\n      }\n    }\n\n    return this.namespaces[name];\n  };\n\n  /**\n   * Emits the given event to the Socket and all namespaces\n   *\n   * @api private\n   */\n\n  Socket.prototype.publish = function () {\n    this.emit.apply(this, arguments);\n\n    var nsp;\n\n    for (var i in this.namespaces) {\n      if (this.namespaces.hasOwnProperty(i)) {\n        nsp = this.of(i);\n        nsp.$emit.apply(nsp, arguments);\n      }\n    }\n  };\n\n  /**\n   * Performs the handshake\n   *\n   * @api private\n   */\n\n  function empty () { };\n\n  Socket.prototype.handshake = function (fn) {\n    var self = this\n      , options = this.options;\n\n    function complete (data) {\n      if (data instanceof Error) {\n        self.connecting = false;\n        self.onError(data.message);\n      } else {\n        fn.apply(null, data.split(':'));\n      }\n    };\n\n    var url = [\n          'http' + (options.secure ? 's' : '') + ':/'\n        , options.host + ':' + options.port\n        , options.resource\n        , io.protocol\n        , io.util.query(this.options.query, 't=' + +new Date)\n      ].join('/');\n\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\n      var insertAt = document.getElementsByTagName('script')[0]\n        , script = document.createElement('script');\n\n      script.src = url + '&jsonp=' + io.j.length;\n      insertAt.parentNode.insertBefore(script, insertAt);\n\n      io.j.push(function (data) {\n        complete(data);\n        script.parentNode.removeChild(script);\n      });\n    } else {\n      var xhr = io.util.request();\n\n      xhr.open('GET', url, true);\n      if (this.isXDomain()) {\n        xhr.withCredentials = true;\n      }\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          xhr.onreadystatechange = empty;\n\n          if (xhr.status == 200) {\n            complete(xhr.responseText);\n          } else if (xhr.status == 403) {\n            self.onError(xhr.responseText);\n          } else {\n            self.connecting = false;            \n            !self.reconnecting && self.onError(xhr.responseText);\n          }\n        }\n      };\n      xhr.send(null);\n    }\n  };\n\n  /**\n   * Find an available transport based on the options supplied in the constructor.\n   *\n   * @api private\n   */\n\n  Socket.prototype.getTransport = function (override) {\n    var transports = override || this.transports, match;\n\n    for (var i = 0, transport; transport = transports[i]; i++) {\n      if (io.Transport[transport]\n        && io.Transport[transport].check(this)\n        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {\n        return new io.Transport[transport](this, this.sessionid);\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Connects to the server.\n   *\n   * @param {Function} [fn] Callback.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.connect = function (fn) {\n    if (this.connecting) {\n      return this;\n    }\n\n    var self = this;\n    self.connecting = true;\n    \n    this.handshake(function (sid, heartbeat, close, transports) {\n      self.sessionid = sid;\n      self.closeTimeout = close * 1000;\n      self.heartbeatTimeout = heartbeat * 1000;\n      if(!self.transports)\n          self.transports = self.origTransports = (transports ? io.util.intersect(\n              transports.split(',')\n            , self.options.transports\n          ) : self.options.transports);\n\n      self.setHeartbeatTimeout();\n\n      function connect (transports){\n        if (self.transport) self.transport.clearTimeouts();\n\n        self.transport = self.getTransport(transports);\n        if (!self.transport) return self.publish('connect_failed');\n\n        // once the transport is ready\n        self.transport.ready(self, function () {\n          self.connecting = true;\n          self.publish('connecting', self.transport.name);\n          self.transport.open();\n\n          if (self.options['connect timeout']) {\n            self.connectTimeoutTimer = setTimeout(function () {\n              if (!self.connected) {\n                self.connecting = false;\n\n                if (self.options['try multiple transports']) {\n                  var remaining = self.transports;\n\n                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=\n                         self.transport.name) {}\n\n                    if (remaining.length){\n                      connect(remaining);\n                    } else {\n                      self.publish('connect_failed');\n                    }\n                }\n              }\n            }, self.options['connect timeout']);\n          }\n        });\n      }\n\n      connect(self.transports);\n\n      self.once('connect', function (){\n        clearTimeout(self.connectTimeoutTimer);\n\n        fn && typeof fn == 'function' && fn();\n      });\n    });\n\n    return this;\n  };\n\n  /**\n   * Clears and sets a new heartbeat timeout using the value given by the\n   * server during the handshake.\n   *\n   * @api private\n   */\n\n  Socket.prototype.setHeartbeatTimeout = function () {\n    clearTimeout(this.heartbeatTimeoutTimer);\n    if(this.transport && !this.transport.heartbeats()) return;\n\n    var self = this;\n    this.heartbeatTimeoutTimer = setTimeout(function () {\n      self.transport.onClose();\n    }, this.heartbeatTimeout);\n  };\n\n  /**\n   * Sends a message.\n   *\n   * @param {Object} data packet.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.packet = function (data) {\n    if (this.connected && !this.doBuffer) {\n      this.transport.packet(data);\n    } else {\n      this.buffer.push(data);\n    }\n\n    return this;\n  };\n\n  /**\n   * Sets buffer state\n   *\n   * @api private\n   */\n\n  Socket.prototype.setBuffer = function (v) {\n    this.doBuffer = v;\n\n    if (!v && this.connected && this.buffer.length) {\n      if (!this.options['manualFlush']) {\n        this.flushBuffer();\n      }\n    }\n  };\n\n  /**\n   * Flushes the buffer data over the wire.\n   * To be invoked manually when 'manualFlush' is set to true.\n   *\n   * @api public\n   */\n\n  Socket.prototype.flushBuffer = function() {\n    this.transport.payload(this.buffer);\n    this.buffer = [];\n  };\n  \n\n  /**\n   * Disconnect the established connect.\n   *\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.disconnect = function () {\n    if (this.connected || this.connecting) {\n      if (this.open) {\n        this.of('').packet({ type: 'disconnect' });\n      }\n\n      // handle disconnection immediately\n      this.onDisconnect('booted');\n    }\n\n    return this;\n  };\n\n  /**\n   * Disconnects the socket with a sync XHR.\n   *\n   * @api private\n   */\n\n  Socket.prototype.disconnectSync = function () {\n    // ensure disconnection\n    var xhr = io.util.request();\n    var uri = [\n        'http' + (this.options.secure ? 's' : '') + ':/'\n      , this.options.host + ':' + this.options.port\n      , this.options.resource\n      , io.protocol\n      , ''\n      , this.sessionid\n    ].join('/') + '/?disconnect=1';\n\n    xhr.open('GET', uri, false);\n    xhr.send(null);\n\n    // handle disconnection immediately\n    this.onDisconnect('booted');\n  };\n\n  /**\n   * Check if we need to use cross domain enabled transports. Cross domain would\n   * be a different port or different domain name.\n   *\n   * @returns {Boolean}\n   * @api private\n   */\n\n  Socket.prototype.isXDomain = function () {\n\n    var port = global.location.port ||\n      ('https:' == global.location.protocol ? 443 : 80);\n\n    return this.options.host !== global.location.hostname \n      || this.options.port != port;\n  };\n\n  /**\n   * Called upon handshake.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onConnect = function () {\n    if (!this.connected) {\n      this.connected = true;\n      this.connecting = false;\n      if (!this.doBuffer) {\n        // make sure to flush the buffer\n        this.setBuffer(false);\n      }\n      this.emit('connect');\n    }\n  };\n\n  /**\n   * Called when the transport opens\n   *\n   * @api private\n   */\n\n  Socket.prototype.onOpen = function () {\n    this.open = true;\n  };\n\n  /**\n   * Called when the transport closes.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onClose = function () {\n    this.open = false;\n    clearTimeout(this.heartbeatTimeoutTimer);\n  };\n\n  /**\n   * Called when the transport first opens a connection\n   *\n   * @param text\n   */\n\n  Socket.prototype.onPacket = function (packet) {\n    this.of(packet.endpoint).onPacket(packet);\n  };\n\n  /**\n   * Handles an error.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onError = function (err) {\n    if (err && err.advice) {\n      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\n        this.disconnect();\n        if (this.options.reconnect) {\n          this.reconnect();\n        }\n      }\n    }\n\n    this.publish('error', err && err.reason ? err.reason : err);\n  };\n\n  /**\n   * Called when the transport disconnects.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onDisconnect = function (reason) {\n    var wasConnected = this.connected\n      , wasConnecting = this.connecting;\n\n    this.connected = false;\n    this.connecting = false;\n    this.open = false;\n\n    if (wasConnected || wasConnecting) {\n      this.transport.close();\n      this.transport.clearTimeouts();\n      if (wasConnected) {\n        this.publish('disconnect', reason);\n\n        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\n          this.reconnect();\n        }\n      }\n    }\n  };\n\n  /**\n   * Called upon reconnection.\n   *\n   * @api private\n   */\n\n  Socket.prototype.reconnect = function () {\n    this.reconnecting = true;\n    this.reconnectionAttempts = 0;\n    this.reconnectionDelay = this.options['reconnection delay'];\n\n    var self = this\n      , maxAttempts = this.options['max reconnection attempts']\n      , tryMultiple = this.options['try multiple transports']\n      , limit = this.options['reconnection limit'];\n\n    function reset () {\n      if (self.connected) {\n        for (var i in self.namespaces) {\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\n              self.namespaces[i].packet({ type: 'connect' });\n          }\n        }\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\n      }\n\n      clearTimeout(self.reconnectionTimer);\n\n      self.removeListener('connect_failed', maybeReconnect);\n      self.removeListener('connect', maybeReconnect);\n\n      self.reconnecting = false;\n\n      delete self.reconnectionAttempts;\n      delete self.reconnectionDelay;\n      delete self.reconnectionTimer;\n      delete self.redoTransports;\n\n      self.options['try multiple transports'] = tryMultiple;\n    };\n\n    function maybeReconnect () {\n      if (!self.reconnecting) {\n        return;\n      }\n\n      if (self.connected) {\n        return reset();\n      };\n\n      if (self.connecting && self.reconnecting) {\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\n      }\n\n      if (self.reconnectionAttempts++ >= maxAttempts) {\n        if (!self.redoTransports) {\n          self.on('connect_failed', maybeReconnect);\n          self.options['try multiple transports'] = true;\n          self.transports = self.origTransports;\n          self.transport = self.getTransport();\n          self.redoTransports = true;\n          self.connect();\n        } else {\n          self.publish('reconnect_failed');\n          reset();\n        }\n      } else {\n        if (self.reconnectionDelay < limit) {\n          self.reconnectionDelay *= 2; // exponential back off\n        }\n\n        self.connect();\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\n      }\n    };\n\n    this.options['try multiple transports'] = false;\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\n\n    this.on('connect', maybeReconnect);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.SocketNamespace = SocketNamespace;\n\n  /**\n   * Socket namespace constructor.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function SocketNamespace (socket, name) {\n    this.socket = socket;\n    this.name = name || '';\n    this.flags = {};\n    this.json = new Flag(this, 'json');\n    this.ackPackets = 0;\n    this.acks = {};\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(SocketNamespace, io.EventEmitter);\n\n  /**\n   * Copies emit since we override it\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\n\n  /**\n   * Creates a new namespace, by proxying the request to the socket. This\n   * allows us to use the synax as we do on the server.\n   *\n   * @api public\n   */\n\n  SocketNamespace.prototype.of = function () {\n    return this.socket.of.apply(this.socket, arguments);\n  };\n\n  /**\n   * Sends a packet.\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.packet = function (packet) {\n    packet.endpoint = this.name;\n    this.socket.packet(packet);\n    this.flags = {};\n    return this;\n  };\n\n  /**\n   * Sends a message\n   *\n   * @api public\n   */\n\n  SocketNamespace.prototype.send = function (data, fn) {\n    var packet = {\n        type: this.flags.json ? 'json' : 'message'\n      , data: data\n    };\n\n    if ('function' == typeof fn) {\n      packet.id = ++this.ackPackets;\n      packet.ack = true;\n      this.acks[packet.id] = fn;\n    }\n\n    return this.packet(packet);\n  };\n\n  /**\n   * Emits an event\n   *\n   * @api public\n   */\n  \n  SocketNamespace.prototype.emit = function (name) {\n    var args = Array.prototype.slice.call(arguments, 1)\n      , lastArg = args[args.length - 1]\n      , packet = {\n            type: 'event'\n          , name: name\n        };\n\n    if ('function' == typeof lastArg) {\n      packet.id = ++this.ackPackets;\n      packet.ack = 'data';\n      this.acks[packet.id] = lastArg;\n      args = args.slice(0, args.length - 1);\n    }\n\n    packet.args = args;\n\n    return this.packet(packet);\n  };\n\n  /**\n   * Disconnects the namespace\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.disconnect = function () {\n    if (this.name === '') {\n      this.socket.disconnect();\n    } else {\n      this.packet({ type: 'disconnect' });\n      this.$emit('disconnect');\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles a packet\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.onPacket = function (packet) {\n    var self = this;\n\n    function ack () {\n      self.packet({\n          type: 'ack'\n        , args: io.util.toArray(arguments)\n        , ackId: packet.id\n      });\n    };\n\n    switch (packet.type) {\n      case 'connect':\n        this.$emit('connect');\n        break;\n\n      case 'disconnect':\n        if (this.name === '') {\n          this.socket.onDisconnect(packet.reason || 'booted');\n        } else {\n          this.$emit('disconnect', packet.reason);\n        }\n        break;\n\n      case 'message':\n      case 'json':\n        var params = ['message', packet.data];\n\n        if (packet.ack == 'data') {\n          params.push(ack);\n        } else if (packet.ack) {\n          this.packet({ type: 'ack', ackId: packet.id });\n        }\n\n        this.$emit.apply(this, params);\n        break;\n\n      case 'event':\n        var params = [packet.name].concat(packet.args);\n\n        if (packet.ack == 'data')\n          params.push(ack);\n\n        this.$emit.apply(this, params);\n        break;\n\n      case 'ack':\n        if (this.acks[packet.ackId]) {\n          this.acks[packet.ackId].apply(this, packet.args);\n          delete this.acks[packet.ackId];\n        }\n        break;\n\n      case 'error':\n        if (packet.advice){\n          this.socket.onError(packet);\n        } else {\n          if (packet.reason == 'unauthorized') {\n            this.$emit('connect_failed', packet.reason);\n          } else {\n            this.$emit('error', packet.reason);\n          }\n        }\n        break;\n    }\n  };\n\n  /**\n   * Flag interface.\n   *\n   * @api private\n   */\n\n  function Flag (nsp, name) {\n    this.namespace = nsp;\n    this.name = name;\n  };\n\n  /**\n   * Send a message\n   *\n   * @api public\n   */\n\n  Flag.prototype.send = function () {\n    this.namespace.flags[this.name] = true;\n    this.namespace.send.apply(this.namespace, arguments);\n  };\n\n  /**\n   * Emit an event\n   *\n   * @api public\n   */\n\n  Flag.prototype.emit = function () {\n    this.namespace.flags[this.name] = true;\n    this.namespace.emit.apply(this.namespace, arguments);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.websocket = WS;\n\n  /**\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\n   * persistent connection with the Socket.IO server. This transport will also\n   * be inherited by the FlashSocket fallback as it provides a API compatible\n   * polyfill for the WebSockets.\n   *\n   * @constructor\n   * @extends {io.Transport}\n   * @api public\n   */\n\n  function WS (socket) {\n    io.Transport.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(WS, io.Transport);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  WS.prototype.name = 'websocket';\n\n  /**\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\n   * all the appropriate listeners to handle the responses from the server.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.open = function () {\n    var query = io.util.query(this.socket.options.query)\n      , self = this\n      , Socket\n\n\n    if (!Socket) {\n      Socket = global.MozWebSocket || global.WebSocket;\n    }\n\n    this.websocket = new Socket(this.prepareUrl() + query);\n\n    this.websocket.onopen = function () {\n      self.onOpen();\n      self.socket.setBuffer(false);\n    };\n    this.websocket.onmessage = function (ev) {\n      self.onData(ev.data);\n    };\n    this.websocket.onclose = function () {\n      self.onClose();\n      self.socket.setBuffer(true);\n    };\n    this.websocket.onerror = function (e) {\n      self.onError(e);\n    };\n\n    return this;\n  };\n\n  /**\n   * Send a message to the Socket.IO server. The message will automatically be\n   * encoded in the correct message format.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  // Do to a bug in the current IDevices browser, we need to wrap the send in a \n  // setTimeout, when they resume from sleeping the browser will crash if \n  // we don't allow the browser time to detect the socket has been closed\n  if (io.util.ua.iDevice) {\n    WS.prototype.send = function (data) {\n      var self = this;\n      setTimeout(function() {\n         self.websocket.send(data);\n      },0);\n      return this;\n    };\n  } else {\n    WS.prototype.send = function (data) {\n      this.websocket.send(data);\n      return this;\n    };\n  }\n\n  /**\n   * Payload\n   *\n   * @api private\n   */\n\n  WS.prototype.payload = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      this.packet(arr[i]);\n    }\n    return this;\n  };\n\n  /**\n   * Disconnect the established `WebSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.close = function () {\n    this.websocket.close();\n    return this;\n  };\n\n  /**\n   * Handle the errors that `WebSocket` might be giving when we\n   * are attempting to connect or send messages.\n   *\n   * @param {Error} e The error.\n   * @api private\n   */\n\n  WS.prototype.onError = function (e) {\n    this.socket.onError(e);\n  };\n\n  /**\n   * Returns the appropriate scheme for the URI generation.\n   *\n   * @api private\n   */\n  WS.prototype.scheme = function () {\n    return this.socket.options.secure ? 'wss' : 'ws';\n  };\n\n  /**\n   * Checks if the browser has support for native `WebSockets` and that\n   * it's not the polyfill created for the FlashSocket transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  WS.check = function () {\n    return ('WebSocket' in global && !('__addTask' in WebSocket))\n          || 'MozWebSocket' in global;\n  };\n\n  /**\n   * Check if the `WebSocket` transport support cross domain communications.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  WS.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('websocket');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.flashsocket = Flashsocket;\n\n  /**\n   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\n   * specification. It uses a .swf file to communicate with the server. If you want\n   * to serve the .swf file from a other server than where the Socket.IO script is\n   * coming from you need to use the insecure version of the .swf. More information\n   * about this can be found on the github page.\n   *\n   * @constructor\n   * @extends {io.Transport.websocket}\n   * @api public\n   */\n\n  function Flashsocket () {\n    io.Transport.websocket.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(Flashsocket, io.Transport.websocket);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  Flashsocket.prototype.name = 'flashsocket';\n\n  /**\n   * Disconnect the established `FlashSocket` connection. This is done by adding a \n   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.open = function () {\n    var self = this\n      , args = arguments;\n\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.open.apply(self, args);\n    });\n    return this;\n  };\n  \n  /**\n   * Sends a message to the Socket.IO server. This is done by adding a new\n   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.send = function () {\n    var self = this, args = arguments;\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.send.apply(self, args);\n    });\n    return this;\n  };\n\n  /**\n   * Disconnects the established `FlashSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.close = function () {\n    WebSocket.__tasks.length = 0;\n    io.Transport.websocket.prototype.close.call(this);\n    return this;\n  };\n\n  /**\n   * The WebSocket fall back needs to append the flash container to the body\n   * element, so we need to make sure we have access to it. Or defer the call\n   * until we are sure there is a body element.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Flashsocket.prototype.ready = function (socket, fn) {\n    function init () {\n      var options = socket.options\n        , port = options['flash policy port']\n        , path = [\n              'http' + (options.secure ? 's' : '') + ':/'\n            , options.host + ':' + options.port\n            , options.resource\n            , 'static/flashsocket'\n            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'\n          ];\n\n      // Only start downloading the swf file when the checked that this browser\n      // actually supports it\n      if (!Flashsocket.loaded) {\n        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\n          // Set the correct file based on the XDomain settings\n          WEB_SOCKET_SWF_LOCATION = path.join('/');\n        }\n\n        if (port !== 843) {\n          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\n        }\n\n        WebSocket.__initialize();\n        Flashsocket.loaded = true;\n      }\n\n      fn.call(self);\n    }\n\n    var self = this;\n    if (document.body) return init();\n\n    io.util.load(init);\n  };\n\n  /**\n   * Check if the FlashSocket transport is supported as it requires that the Adobe\n   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\n   * the polyfill is correctly loaded.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.check = function () {\n    if (\n        typeof WebSocket == 'undefined'\n      || !('__initialize' in WebSocket) || !swfobject\n    ) return false;\n\n    return swfobject.getFlashPlayerVersion().major >= 10;\n  };\n\n  /**\n   * Check if the FlashSocket transport can be used as cross domain / cross origin \n   * transport. Because we can't see which type (secure or insecure) of .swf is used\n   * we will just return true.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Disable AUTO_INITIALIZATION\n   */\n\n  if (typeof window != 'undefined') {\n    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n  }\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('flashsocket');\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/*\tSWFObject v2.2 <http://code.google.com/p/swfobject/> \n\tis released under the MIT License <http://www.opensource.org/licenses/mit-license.php> \n*/\nif ('undefined' != typeof window) {\nvar swfobject=function(){var D=\"undefined\",r=\"object\",S=\"Shockwave Flash\",W=\"ShockwaveFlash.ShockwaveFlash\",q=\"application/x-shockwave-flash\",R=\"SWFObjectExprInst\",x=\"onreadystatechange\",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\\/(\\d+(\\.\\d+)?).*$/,\"$1\")):false,X=!+\"\\v1\",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\\s+(\\S+\\s+\\S+$)/,\"$1\");ag[0]=parseInt(ab.replace(/^(.*)\\..*$/,\"$1\"),10);ag[1]=parseInt(ab.replace(/^.*\\.(.*)\\s.*$/,\"$1\"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,\"$1\"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable(\"$version\");if(ab){X=true;ab=ab.split(\" \")[1].split(\",\");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState==\"complete\")||(typeof j.readyState==D&&(j.getElementsByTagName(\"body\")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener(\"DOMContentLoaded\",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState==\"complete\"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll(\"left\")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName(\"body\")[0].appendChild(C(\"span\"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener(\"load\",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener(\"load\",Y,false)}else{if(typeof O.attachEvent!=D){i(O,\"onload\",Y)}else{if(typeof O.onload==\"function\"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName(\"body\")[0];var aa=C(r);aa.setAttribute(\"type\",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable(\"$version\");if(ab){ab=ab.split(\" \")[1].split(\",\");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute(\"width\")||\"0\";ai.height=ae.getAttribute(\"height\")||\"0\";if(ae.getAttribute(\"class\")){ai.styleclass=ae.getAttribute(\"class\")}if(ae.getAttribute(\"align\")){ai.align=ae.getAttribute(\"align\")}var ah={};var X=ae.getElementsByTagName(\"param\");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute(\"name\").toLowerCase()!=\"movie\"){ah[X[ad].getAttribute(\"name\")]=X[ad].getAttribute(\"value\")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName==\"OBJECT\"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F(\"6.0.65\")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName==\"OBJECT\"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width=\"310\"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height=\"137\"}j.title=j.title.slice(0,47)+\" - Flash Player Installation\";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):\"PlugIn\",ac=\"MMredirectURL=\"+O.location.toString().replace(/&/g,\"%26\")+\"&MMplayerType=\"+ad+\"&MMdoctitle=\"+j.title;if(typeof ab.flashvars!=D){ab.flashvars+=\"&\"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C(\"div\");X+=\"SWFObjectNew\";Y.setAttribute(\"id\",X);ae.parentNode.insertBefore(Y,ae);ae.style.display=\"none\";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C(\"div\");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display=\"none\";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C(\"div\");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName==\"PARAM\")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah=\"\";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()==\"data\"){ag.movie=ai[ae]}else{if(ae.toLowerCase()==\"styleclass\"){ah+=' class=\"'+ai[ae]+'\"'}else{if(ae.toLowerCase()!=\"classid\"){ah+=\" \"+ae+'=\"'+ai[ae]+'\"'}}}}}var af=\"\";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name=\"'+ad+'\" value=\"'+ag[ad]+'\" />'}}aa.outerHTML='<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"'+ah+\">\"+af+\"</object>\";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute(\"type\",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()==\"styleclass\"){Z.setAttribute(\"class\",ai[ac])}else{if(ac.toLowerCase()!=\"classid\"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!=\"movie\"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C(\"param\");aa.setAttribute(\"name\",X);aa.setAttribute(\"value\",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName==\"OBJECT\"){if(M.ie&&M.win){X.style.display=\"none\";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]==\"function\"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(\".\");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName(\"head\")[0];if(!aa){return}var X=(ad&&typeof ad==\"string\")?ad:\"screen\";if(ab){n=null;G=null}if(!n||G!=X){var Z=C(\"style\");Z.setAttribute(\"type\",\"text/css\");Z.setAttribute(\"media\",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+\" {\"+Y+\"}\"))}}}function w(Z,X){if(!m){return}var Y=X?\"visible\":\"hidden\";if(J&&c(Z)){c(Z).style.visibility=Y}else{v(\"#\"+Z,\"visibility:\"+Y)}}function L(Y){var Z=/[\\\\\\\"<>\\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent(\"onunload\",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+=\"\";ag+=\"\";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+=\"&\"+ai+\"=\"+Z[ai]}else{am.flashvars=ai+\"=\"+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\\?/.test(Z)){Z=Z.split(\"?\")[1]}if(aa==null){return L(Z)}var Y=Z.split(\"&\");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf(\"=\"))==aa){return L(Y[X].substring((Y[X].indexOf(\"=\")+1)))}}}return\"\"},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display=\"block\"}}if(E){E(B)}}a=false}}}}();\n}\n// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>\n// License: New BSD License\n// Reference: http://dev.w3.org/html5/websockets/\n// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol\n\n(function() {\n  \n  if ('undefined' == typeof window || window.WebSocket) return;\n\n  var console = window.console;\n  if (!console || !console.log || !console.error) {\n    console = {log: function(){ }, error: function(){ }};\n  }\n  \n  if (!swfobject.hasFlashPlayerVersion(\"10.0.0\")) {\n    console.error(\"Flash Player >= 10.0.0 is required.\");\n    return;\n  }\n  if (location.protocol == \"file:\") {\n    console.error(\n      \"WARNING: web-socket-js doesn't work in file:///... URL \" +\n      \"unless you set Flash Security Settings properly. \" +\n      \"Open the page via Web server i.e. http://...\");\n  }\n\n  /**\n   * This class represents a faux web socket.\n   * @param {string} url\n   * @param {array or string} protocols\n   * @param {string} proxyHost\n   * @param {int} proxyPort\n   * @param {string} headers\n   */\n  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {\n    var self = this;\n    self.__id = WebSocket.__nextId++;\n    WebSocket.__instances[self.__id] = self;\n    self.readyState = WebSocket.CONNECTING;\n    self.bufferedAmount = 0;\n    self.__events = {};\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols == \"string\") {\n      protocols = [protocols];\n    }\n    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.\n    // Otherwise, when onopen fires immediately, onopen is called before it is set.\n    setTimeout(function() {\n      WebSocket.__addTask(function() {\n        WebSocket.__flash.create(\n            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);\n      });\n    }, 0);\n  };\n\n  /**\n   * Send data to the web socket.\n   * @param {string} data  The data to send to the socket.\n   * @return {boolean}  True for success, false for failure.\n   */\n  WebSocket.prototype.send = function(data) {\n    if (this.readyState == WebSocket.CONNECTING) {\n      throw \"INVALID_STATE_ERR: Web Socket connection has not been established\";\n    }\n    // We use encodeURIComponent() here, because FABridge doesn't work if\n    // the argument includes some characters. We don't use escape() here\n    // because of this:\n    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions\n    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't\n    // preserve all Unicode characters either e.g. \"\\uffff\" in Firefox.\n    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require\n    // additional testing.\n    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));\n    if (result < 0) { // success\n      return true;\n    } else {\n      this.bufferedAmount += result;\n      return false;\n    }\n  };\n\n  /**\n   * Close this web socket gracefully.\n   */\n  WebSocket.prototype.close = function() {\n    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {\n      return;\n    }\n    this.readyState = WebSocket.CLOSING;\n    WebSocket.__flash.close(this.__id);\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {boolean} useCapture\n   * @return void\n   */\n  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {\n    if (!(type in this.__events)) {\n      this.__events[type] = [];\n    }\n    this.__events[type].push(listener);\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {boolean} useCapture\n   * @return void\n   */\n  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {\n    if (!(type in this.__events)) return;\n    var events = this.__events[type];\n    for (var i = events.length - 1; i >= 0; --i) {\n      if (events[i] === listener) {\n        events.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {Event} event\n   * @return void\n   */\n  WebSocket.prototype.dispatchEvent = function(event) {\n    var events = this.__events[event.type] || [];\n    for (var i = 0; i < events.length; ++i) {\n      events[i](event);\n    }\n    var handler = this[\"on\" + event.type];\n    if (handler) handler(event);\n  };\n\n  /**\n   * Handles an event from Flash.\n   * @param {Object} flashEvent\n   */\n  WebSocket.prototype.__handleEvent = function(flashEvent) {\n    if (\"readyState\" in flashEvent) {\n      this.readyState = flashEvent.readyState;\n    }\n    if (\"protocol\" in flashEvent) {\n      this.protocol = flashEvent.protocol;\n    }\n    \n    var jsEvent;\n    if (flashEvent.type == \"open\" || flashEvent.type == \"error\") {\n      jsEvent = this.__createSimpleEvent(flashEvent.type);\n    } else if (flashEvent.type == \"close\") {\n      // TODO implement jsEvent.wasClean\n      jsEvent = this.__createSimpleEvent(\"close\");\n    } else if (flashEvent.type == \"message\") {\n      var data = decodeURIComponent(flashEvent.message);\n      jsEvent = this.__createMessageEvent(\"message\", data);\n    } else {\n      throw \"unknown event type: \" + flashEvent.type;\n    }\n    \n    this.dispatchEvent(jsEvent);\n  };\n  \n  WebSocket.prototype.__createSimpleEvent = function(type) {\n    if (document.createEvent && window.Event) {\n      var event = document.createEvent(\"Event\");\n      event.initEvent(type, false, false);\n      return event;\n    } else {\n      return {type: type, bubbles: false, cancelable: false};\n    }\n  };\n  \n  WebSocket.prototype.__createMessageEvent = function(type, data) {\n    if (document.createEvent && window.MessageEvent && !window.opera) {\n      var event = document.createEvent(\"MessageEvent\");\n      event.initMessageEvent(\"message\", false, false, data, null, null, window, null);\n      return event;\n    } else {\n      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.\n      return {type: type, data: data, bubbles: false, cancelable: false};\n    }\n  };\n  \n  /**\n   * Define the WebSocket readyState enumeration.\n   */\n  WebSocket.CONNECTING = 0;\n  WebSocket.OPEN = 1;\n  WebSocket.CLOSING = 2;\n  WebSocket.CLOSED = 3;\n\n  WebSocket.__flash = null;\n  WebSocket.__instances = {};\n  WebSocket.__tasks = [];\n  WebSocket.__nextId = 0;\n  \n  /**\n   * Load a new flash security policy file.\n   * @param {string} url\n   */\n  WebSocket.loadFlashPolicyFile = function(url){\n    WebSocket.__addTask(function() {\n      WebSocket.__flash.loadManualPolicyFile(url);\n    });\n  };\n\n  /**\n   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.\n   */\n  WebSocket.__initialize = function() {\n    if (WebSocket.__flash) return;\n    \n    if (WebSocket.__swfLocation) {\n      // For backword compatibility.\n      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;\n    }\n    if (!window.WEB_SOCKET_SWF_LOCATION) {\n      console.error(\"[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf\");\n      return;\n    }\n    var container = document.createElement(\"div\");\n    container.id = \"webSocketContainer\";\n    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents\n    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).\n    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash\n    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is\n    // the best we can do as far as we know now.\n    container.style.position = \"absolute\";\n    if (WebSocket.__isFlashLite()) {\n      container.style.left = \"0px\";\n      container.style.top = \"0px\";\n    } else {\n      container.style.left = \"-100px\";\n      container.style.top = \"-100px\";\n    }\n    var holder = document.createElement(\"div\");\n    holder.id = \"webSocketFlash\";\n    container.appendChild(holder);\n    document.body.appendChild(container);\n    // See this article for hasPriority:\n    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\n    swfobject.embedSWF(\n      WEB_SOCKET_SWF_LOCATION,\n      \"webSocketFlash\",\n      \"1\" /* width */,\n      \"1\" /* height */,\n      \"10.0.0\" /* SWF version */,\n      null,\n      null,\n      {hasPriority: true, swliveconnect : true, allowScriptAccess: \"always\"},\n      null,\n      function(e) {\n        if (!e.success) {\n          console.error(\"[WebSocket] swfobject.embedSWF failed\");\n        }\n      });\n  };\n  \n  /**\n   * Called by Flash to notify JS that it's fully loaded and ready\n   * for communication.\n   */\n  WebSocket.__onFlashInitialized = function() {\n    // We need to set a timeout here to avoid round-trip calls\n    // to flash during the initialization process.\n    setTimeout(function() {\n      WebSocket.__flash = document.getElementById(\"webSocketFlash\");\n      WebSocket.__flash.setCallerUrl(location.href);\n      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);\n      for (var i = 0; i < WebSocket.__tasks.length; ++i) {\n        WebSocket.__tasks[i]();\n      }\n      WebSocket.__tasks = [];\n    }, 0);\n  };\n  \n  /**\n   * Called by Flash to notify WebSockets events are fired.\n   */\n  WebSocket.__onFlashEvent = function() {\n    setTimeout(function() {\n      try {\n        // Gets events using receiveEvents() instead of getting it from event object\n        // of Flash event. This is to make sure to keep message order.\n        // It seems sometimes Flash events don't arrive in the same order as they are sent.\n        var events = WebSocket.__flash.receiveEvents();\n        for (var i = 0; i < events.length; ++i) {\n          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }, 0);\n    return true;\n  };\n  \n  // Called by Flash.\n  WebSocket.__log = function(message) {\n    console.log(decodeURIComponent(message));\n  };\n  \n  // Called by Flash.\n  WebSocket.__error = function(message) {\n    console.error(decodeURIComponent(message));\n  };\n  \n  WebSocket.__addTask = function(task) {\n    if (WebSocket.__flash) {\n      task();\n    } else {\n      WebSocket.__tasks.push(task);\n    }\n  };\n  \n  /**\n   * Test if the browser is running flash lite.\n   * @return {boolean} True if flash lite is running, false otherwise.\n   */\n  WebSocket.__isFlashLite = function() {\n    if (!window.navigator || !window.navigator.mimeTypes) {\n      return false;\n    }\n    var mimeType = window.navigator.mimeTypes[\"application/x-shockwave-flash\"];\n    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {\n      return false;\n    }\n    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;\n  };\n  \n  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {\n    if (window.addEventListener) {\n      window.addEventListener(\"load\", function(){\n        WebSocket.__initialize();\n      }, false);\n    } else {\n      window.attachEvent(\"onload\", function(){\n        WebSocket.__initialize();\n      });\n    }\n  }\n  \n})();\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   *\n   * @api public\n   */\n\n  exports.XHR = XHR;\n\n  /**\n   * XHR constructor\n   *\n   * @costructor\n   * @api public\n   */\n\n  function XHR (socket) {\n    if (!socket) return;\n\n    io.Transport.apply(this, arguments);\n    this.sendBuffer = [];\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(XHR, io.Transport);\n\n  /**\n   * Establish a connection\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.open = function () {\n    this.socket.setBuffer(false);\n    this.onOpen();\n    this.get();\n\n    // we need to make sure the request succeeds since we have no indication\n    // whether the request opened or not until it succeeded.\n    this.setCloseTimeout();\n\n    return this;\n  };\n\n  /**\n   * Check if we need to send data to the Socket.IO server, if we have data in our\n   * buffer we encode it and forward it to the `post` method.\n   *\n   * @api private\n   */\n\n  XHR.prototype.payload = function (payload) {\n    var msgs = [];\n\n    for (var i = 0, l = payload.length; i < l; i++) {\n      msgs.push(io.parser.encodePacket(payload[i]));\n    }\n\n    this.send(io.parser.encodePayload(msgs));\n  };\n\n  /**\n   * Send data to the Socket.IO server.\n   *\n   * @param data The message\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.send = function (data) {\n    this.post(data);\n    return this;\n  };\n\n  /**\n   * Posts a encoded message to the Socket.IO server.\n   *\n   * @param {String} data A encoded message.\n   * @api private\n   */\n\n  function empty () { };\n\n  XHR.prototype.post = function (data) {\n    var self = this;\n    this.socket.setBuffer(true);\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n        self.posting = false;\n\n        if (this.status == 200){\n          self.socket.setBuffer(false);\n        } else {\n          self.onClose();\n        }\n      }\n    }\n\n    function onload () {\n      this.onload = empty;\n      self.socket.setBuffer(false);\n    };\n\n    this.sendXHR = this.request('POST');\n\n    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\n      this.sendXHR.onload = this.sendXHR.onerror = onload;\n    } else {\n      this.sendXHR.onreadystatechange = stateChange;\n    }\n\n    this.sendXHR.send(data);\n  };\n\n  /**\n   * Disconnects the established `XHR` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.close = function () {\n    this.onClose();\n    return this;\n  };\n\n  /**\n   * Generates a configured XHR request\n   *\n   * @param {String} url The url that needs to be requested.\n   * @param {String} method The method the request should use.\n   * @returns {XMLHttpRequest}\n   * @api private\n   */\n\n  XHR.prototype.request = function (method) {\n    var req = io.util.request(this.socket.isXDomain())\n      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\n\n    req.open(method || 'GET', this.prepareUrl() + query, true);\n\n    if (method == 'POST') {\n      try {\n        if (req.setRequestHeader) {\n          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        } else {\n          // XDomainRequest\n          req.contentType = 'text/plain';\n        }\n      } catch (e) {}\n    }\n\n    return req;\n  };\n\n  /**\n   * Returns the scheme to use for the transport URLs.\n   *\n   * @api private\n   */\n\n  XHR.prototype.scheme = function () {\n    return this.socket.options.secure ? 'https' : 'http';\n  };\n\n  /**\n   * Check if the XHR transports are supported\n   *\n   * @param {Boolean} xdomain Check if we support cross domain requests.\n   * @returns {Boolean}\n   * @api public\n   */\n\n  XHR.check = function (socket, xdomain) {\n    try {\n      var request = io.util.request(xdomain),\n          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),\n          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),\n          isXProtocol = (global.location && socketProtocol != global.location.protocol);\n      if (request && !(usesXDomReq && isXProtocol)) {\n        return true;\n      }\n    } catch(e) {}\n\n    return false;\n  };\n\n  /**\n   * Check if the XHR transport supports cross domain requests.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  XHR.xdomainCheck = function (socket) {\n    return XHR.check(socket, true);\n  };\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.htmlfile = HTMLFile;\n\n  /**\n   * The HTMLFile transport creates a `forever iframe` based transport\n   * for Internet Explorer. Regular forever iframe implementations will \n   * continuously trigger the browsers buzy indicators. If the forever iframe\n   * is created inside a `htmlfile` these indicators will not be trigged.\n   *\n   * @constructor\n   * @extends {io.Transport.XHR}\n   * @api public\n   */\n\n  function HTMLFile (socket) {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(HTMLFile, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  HTMLFile.prototype.name = 'htmlfile';\n\n  /**\n   * Creates a new Ac...eX `htmlfile` with a forever loading iframe\n   * that can be used to listen to messages. Inside the generated\n   * `htmlfile` a reference will be made to the HTMLFile transport.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.get = function () {\n    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\n    this.doc.open();\n    this.doc.write('<html></html>');\n    this.doc.close();\n    this.doc.parentWindow.s = this;\n\n    var iframeC = this.doc.createElement('div');\n    iframeC.className = 'socketio';\n\n    this.doc.body.appendChild(iframeC);\n    this.iframe = this.doc.createElement('iframe');\n\n    iframeC.appendChild(this.iframe);\n\n    var self = this\n      , query = io.util.query(this.socket.options.query, 't='+ +new Date);\n\n    this.iframe.src = this.prepareUrl() + query;\n\n    io.util.on(window, 'unload', function () {\n      self.destroy();\n    });\n  };\n\n  /**\n   * The Socket.IO server will write script tags inside the forever\n   * iframe, this function will be used as callback for the incoming\n   * information.\n   *\n   * @param {String} data The message\n   * @param {document} doc Reference to the context\n   * @api private\n   */\n\n  HTMLFile.prototype._ = function (data, doc) {\n    // unescape all forward slashes. see GH-1251\n    data = data.replace(/\\\\\\//g, '/');\n    this.onData(data);\n    try {\n      var script = doc.getElementsByTagName('script')[0];\n      script.parentNode.removeChild(script);\n    } catch (e) { }\n  };\n\n  /**\n   * Destroy the established connection, iframe and `htmlfile`.\n   * And calls the `CollectGarbage` function of Internet Explorer\n   * to release the memory.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.destroy = function () {\n    if (this.iframe){\n      try {\n        this.iframe.src = 'about:blank';\n      } catch(e){}\n\n      this.doc = null;\n      this.iframe.parentNode.removeChild(this.iframe);\n      this.iframe = null;\n\n      CollectGarbage();\n    }\n  };\n\n  /**\n   * Disconnects the established connection.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  HTMLFile.prototype.close = function () {\n    this.destroy();\n    return io.Transport.XHR.prototype.close.call(this);\n  };\n\n  /**\n   * Checks if the browser supports this transport. The browser\n   * must have an `Ac...eXObject` implementation.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  HTMLFile.check = function (socket) {\n    if (typeof window != \"undefined\" && (['Active'].concat('Object').join('X')) in window){\n      try {\n        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\n        return a && io.Transport.XHR.check(socket);\n      } catch(e){}\n    }\n    return false;\n  };\n\n  /**\n   * Check if cross domain requests are supported.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  HTMLFile.xdomainCheck = function () {\n    // we can probably do handling for sub-domains, we should\n    // test that it's cross domain but a subdomain here\n    return false;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('htmlfile');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['xhr-polling'] = XHRPolling;\n\n  /**\n   * The XHR-polling transport uses long polling XHR requests to create a\n   * \"persistent\" connection with the server.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function XHRPolling () {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Merge the properties from XHR transport\n   */\n\n  io.util.merge(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  XHRPolling.prototype.name = 'xhr-polling';\n\n  /**\n   * Indicates whether heartbeats is enabled for this transport\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.heartbeats = function () {\n    return false;\n  };\n\n  /** \n   * Establish a connection, for iPhone and Android this will be done once the page\n   * is loaded.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  XHRPolling.prototype.open = function () {\n    var self = this;\n\n    io.Transport.XHR.prototype.open.call(self);\n    return false;\n  };\n\n  /**\n   * Starts a XHR request to wait for incoming messages.\n   *\n   * @api private\n   */\n\n  function empty () {};\n\n  XHRPolling.prototype.get = function () {\n    if (!this.isOpen) return;\n\n    var self = this;\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n\n        if (this.status == 200) {\n          self.onData(this.responseText);\n          self.get();\n        } else {\n          self.onClose();\n        }\n      }\n    };\n\n    function onload () {\n      this.onload = empty;\n      this.onerror = empty;\n      self.retryCounter = 1;\n      self.onData(this.responseText);\n      self.get();\n    };\n\n    function onerror () {\n      self.retryCounter ++;\n      if(!self.retryCounter || self.retryCounter > 3) {\n        self.onClose();  \n      } else {\n        self.get();\n      }\n    };\n\n    this.xhr = this.request();\n\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\n      this.xhr.onload = onload;\n      this.xhr.onerror = onerror;\n    } else {\n      this.xhr.onreadystatechange = stateChange;\n    }\n\n    this.xhr.send(null);\n  };\n\n  /**\n   * Handle the unclean close behavior.\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.onClose = function () {\n    io.Transport.XHR.prototype.onClose.call(this);\n\n    if (this.xhr) {\n      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\n      try {\n        this.xhr.abort();\n      } catch(e){}\n      this.xhr = null;\n    }\n  };\n\n  /**\n   * Webkit based browsers show a infinit spinner when you start a XHR request\n   * before the browsers onload event is called so we need to defer opening of\n   * the transport until the onload event is called. Wrapping the cb in our\n   * defer method solve this.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  XHRPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n\n    io.util.defer(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('xhr-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n  /**\n   * There is a way to hide the loading indicator in Firefox. If you create and\n   * remove a iframe it will stop showing the current loading indicator.\n   * Unfortunately we can't feature detect that and UA sniffing is evil.\n   *\n   * @api private\n   */\n\n  var indicator = global.document && \"MozAppearance\" in\n    global.document.documentElement.style;\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['jsonp-polling'] = JSONPPolling;\n\n  /**\n   * The JSONP transport creates an persistent connection by dynamically\n   * inserting a script tag in the page. This script tag will receive the\n   * information of the Socket.IO server. When new information is received\n   * it creates a new script tag for the new data stream.\n   *\n   * @constructor\n   * @extends {io.Transport.xhr-polling}\n   * @api public\n   */\n\n  function JSONPPolling (socket) {\n    io.Transport['xhr-polling'].apply(this, arguments);\n\n    this.index = io.j.length;\n\n    var self = this;\n\n    io.j.push(function (msg) {\n      self._(msg);\n    });\n  };\n\n  /**\n   * Inherits from XHR polling transport.\n   */\n\n  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  JSONPPolling.prototype.name = 'jsonp-polling';\n\n  /**\n   * Posts a encoded message to the Socket.IO server using an iframe.\n   * The iframe is used because script tags can create POST based requests.\n   * The iframe is positioned outside of the view so the user does not\n   * notice it's existence.\n   *\n   * @param {String} data A encoded message.\n   * @api private\n   */\n\n  JSONPPolling.prototype.post = function (data) {\n    var self = this\n      , query = io.util.query(\n             this.socket.options.query\n          , 't='+ (+new Date) + '&i=' + this.index\n        );\n\n    if (!this.form) {\n      var form = document.createElement('form')\n        , area = document.createElement('textarea')\n        , id = this.iframeId = 'socketio_iframe_' + this.index\n        , iframe;\n\n      form.className = 'socketio';\n      form.style.position = 'absolute';\n      form.style.top = '0px';\n      form.style.left = '0px';\n      form.style.display = 'none';\n      form.target = id;\n      form.method = 'POST';\n      form.setAttribute('accept-charset', 'utf-8');\n      area.name = 'd';\n      form.appendChild(area);\n      document.body.appendChild(form);\n\n      this.form = form;\n      this.area = area;\n    }\n\n    this.form.action = this.prepareUrl() + query;\n\n    function complete () {\n      initIframe();\n      self.socket.setBuffer(false);\n    };\n\n    function initIframe () {\n      if (self.iframe) {\n        self.form.removeChild(self.iframe);\n      }\n\n      try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = document.createElement('<iframe name=\"'+ self.iframeId +'\">');\n      } catch (e) {\n        iframe = document.createElement('iframe');\n        iframe.name = self.iframeId;\n      }\n\n      iframe.id = self.iframeId;\n\n      self.form.appendChild(iframe);\n      self.iframe = iframe;\n    };\n\n    initIframe();\n\n    // we temporarily stringify until we figure out how to prevent\n    // browsers from turning `\\n` into `\\r\\n` in form inputs\n    this.area.value = io.JSON.stringify(data);\n\n    try {\n      this.form.submit();\n    } catch(e) {}\n\n    if (this.iframe.attachEvent) {\n      iframe.onreadystatechange = function () {\n        if (self.iframe.readyState == 'complete') {\n          complete();\n        }\n      };\n    } else {\n      this.iframe.onload = complete;\n    }\n\n    this.socket.setBuffer(true);\n  };\n\n  /**\n   * Creates a new JSONP poll that can be used to listen\n   * for messages from the Socket.IO server.\n   *\n   * @api private\n   */\n\n  JSONPPolling.prototype.get = function () {\n    var self = this\n      , script = document.createElement('script')\n      , query = io.util.query(\n             this.socket.options.query\n          , 't='+ (+new Date) + '&i=' + this.index\n        );\n\n    if (this.script) {\n      this.script.parentNode.removeChild(this.script);\n      this.script = null;\n    }\n\n    script.async = true;\n    script.src = this.prepareUrl() + query;\n    script.onerror = function () {\n      self.onClose();\n    };\n\n    var insertAt = document.getElementsByTagName('script')[0];\n    insertAt.parentNode.insertBefore(script, insertAt);\n    this.script = script;\n\n    if (indicator) {\n      setTimeout(function () {\n        var iframe = document.createElement('iframe');\n        document.body.appendChild(iframe);\n        document.body.removeChild(iframe);\n      }, 100);\n    }\n  };\n\n  /**\n   * Callback function for the incoming message stream from the Socket.IO server.\n   *\n   * @param {String} data The message\n   * @api private\n   */\n\n  JSONPPolling.prototype._ = function (msg) {\n    this.onData(msg);\n    if (this.isOpen) {\n      this.get();\n    }\n    return this;\n  };\n\n  /**\n   * The indicator hack only works after onload\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  JSONPPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n    if (!indicator) return fn.call(this);\n\n    io.util.load(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Checks if browser supports this transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  JSONPPolling.check = function () {\n    return 'document' in global;\n  };\n\n  /**\n   * Check if cross domain requests are supported\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  JSONPPolling.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('jsonp-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\nif (typeof define === \"function\" && define.amd) {\n  define([], function () { return io; });\n}\n})();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/dist/socket.io.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 7\n ** module chunks = 0\n **/","// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.nextTick()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected() {\n            pendingCount--;\n            if (pendingCount === 0) {\n                deferred.reject(new Error(\n                    \"Can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected.\"\n                ));\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/q/q.js\n ** module id = 8\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar respoke = require('./respoke');\nvar log = respoke.log;\n\n/**\n * `respoke.Client` is the top-level interface to the API. Interacting with Respoke should be done using\n * a `respoke.Client` instance.\n *\n * There are two ways to get a client:\n *\n *      var client = respoke.createClient(clientParams);\n *      // . . . set stuff up, then . . .\n *      client.connect(connectParams);\n *\n * or\n *\n *      // creates client and connects to Respoke all at once\n *      var client = respoke.connect(allParams);\n *\n * A client does the following things:\n *\n * 1. authentication with the Respoke API\n * 1. receives server-side app-specific information\n * 1. tracks connections and presence\n * 1. provides methods to get and interact with tracked entities (like groups and endpoints)\n * 1. stores default settings for calls and direct connections\n * 1. automatically reconnects to the API when network activity is lost*\n *\n * *If `developmentMode` is set to true. If not using `developmentMode`, disable automatic\n * reconnect by sending `reconnect: false` and listening to the Client's disconnect event\n * to fetch a new brokered auth token, then call `client.connect()` with the new token.\n *\n * @class respoke.Client\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n * respoke.connect, respoke.createClient, or to client.connect.\n * @param {string} [params.token] - The endpoint's authentication token.\n * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n * endpoint. This is only used when `developmentMode` is set to `true`.\n * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n * operation and will limit the services you will be able to use.\n * @param {string|number|object|Array} [params.presence=unavailable] The initial presence to set once connected.\n * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n * when a disconnect occurs.\n * @proprety {number} [connectTimeoutMillis=10000] - Number of milliseconds before considering the connect operation timed out.\n * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is received\n * from anywhere on the system.\n * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect.\n * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client's user receives a call.\n * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this client's user\n * receives a request for a direct connection.\n * @returns {respoke.Client}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Client\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId || respoke.makeGUID();\n    params.instanceId = instanceId;\n    var that = respoke.EventEmitter(params);\n    respoke.instances[instanceId] = that;\n    delete that.instanceId;\n    that.connectTries = 0;\n    /**\n     * A name to identify this class\n     * @memberof! respoke.Client\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Client';\n    /**\n     * @memberof! respoke.Client\n     * @name host\n     * @type {string}\n     * @private\n     */\n    var host = window.location.hostname;\n    /**\n     * @memberof! respoke.Client\n     * @name port\n     * @type {number}\n     * @private\n     */\n    var port = window.location.port;\n\n    /**\n     * A container for baseURL, token, and appId so they won't be accidentally viewable in any JavaScript debugger.\n     * @memberof! respoke.Client\n     * @name clientSettings\n     * @type {object}\n     * @private\n     * @property {string} [baseURL] - the URL of the cloud infrastructure's REST API.\n     * @property {string} [token] - The endpoint's authentication token.\n     * @property {string} [appId] - The id of your Respoke app.\n     * @property {string} [endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @property {boolean} [developmentMode=false] - Indication to obtain an authentication token from the service.\n     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n     * operation and will limit the services you will be able to use.\n     * @property {boolean} [reconnect=false] - Whether or not to automatically reconnect to the Respoke service\n     * when a disconnect occurs.\n     * @proprety {number} [connectTimeoutMillis=10000] - Number of milliseconds before considering the connect\n     * timed out.\n     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves a group.\n     * @property {respoke.Client.onClientMessage} [onMessage] - Callback for when any message is received\n     * from anywhere on the system.\n     * @property {respoke.Client.onConnect} [onConnect] - Callback for Client connect.\n     * @property {respoke.Client.onDisconnect} [onDisconnect] - Callback for Client disconnect.\n     * @property {respoke.Client.onReconnect} [onReconnect] - Callback for Client reconnect. Not Implemented.\n     * @property {respoke.Client.onCall} [onCall] - Callback for when this client receives a call.\n     * @property {respoke.Client.onDirectConnection} [onDirectConnection] - Callback for when this client\n     * receives a request for a direct connection.\n     * @property {boolean} enableCallDebugReport=true - Upon finishing a call, should the client send debugging\n     * information to the API? Defaults to `true`.\n     */\n    var clientSettings = that.clientSettings = {};\n\n    delete that.appId;\n    delete that.baseURL;\n    delete that.developmentMode;\n    delete that.token;\n    delete that.resolveEndpointPresence;\n\n    /**\n     * Internal list of known groups.\n     * @memberof! respoke.Client\n     * @name groups\n     * @type {Array<respoke.Group>}\n     * @private\n     */\n    var groups = [];\n    /**\n     * Internal list of known endpoints.\n     * @memberof! respoke.Client\n     * @name endpoints\n     * @type {Array<respoke.Endpoint>}\n     * @private\n     */\n    var endpoints = [];\n    /**\n     * Array of calls in progress, made accessible for informational purposes only.\n     * **Never modify this array directly.**\n     *\n     * @memberof! respoke.Client\n     * @name calls\n     * @type {array}\n     */\n    that.calls = [];\n    log.debug(\"Client ID is \", instanceId);\n\n    /**\n     * @memberof! respoke.Client\n     * @name signalingChannel\n     * @type {respoke.SignalingChannel}\n     * @private\n     */\n    that.signalingChannel = respoke.SignalingChannel({\n        instanceId: instanceId,\n        clientSettings: clientSettings\n    });\n\n    /**\n     * Represents the presence status. Typically a string, but other types are supported.\n     * Defaults to `'unavailable'`.\n     *\n     * **Do not modify this directly** - it won't update presence with Respoke. Use `setPresence()`.\n     *\n     * @memberof! respoke.Client\n     * @name presence\n     * @type {string|number|object|Array}\n     */\n    that.presence = params.presence || 'unavailable';\n\n    /**\n     * Deprecated: use endpoint.presence instead.\n     *\n     * Return the presence.\n     * @memberof! respoke.Client\n     * @deprecated\n     * @name presence\n     * @type {string|number|object|Array}\n     */\n    that.getPresence = function () {\n        return that.presence;\n    };\n\n    /**\n     * Save parameters of the constructor or client.connect() onto the clientSettings object\n     * @memberof! respoke.Client\n     * @method respoke.saveParameters\n     * @param {object} params\n     * @param {respoke.Client.connectSuccessHandler} [params.onSuccess] - Success handler for this invocation\n     * of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n     * respoke.connect, respoke.createClient, or to client.connect.\n     * @param {string} [params.token] - The endpoint's authentication token.\n     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n     * @param {respoke.client.resolveEndpointPresence} [params.resolveEndpointPresence] An optional function for\n     * resolving presence for an endpoint.  An endpoint can have multiple Connections this function will be used\n     * to decide which Connection's presence gets precedence for the Endpoint.\n     * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n     * operation and will limit the services you will be able to use.\n     * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n     * when a disconnect occurs.\n     * @proprety {number} [paramsconnectTimeoutMillis=10000] - Number of milliseconds before considering the connect\n     * timed out.\n     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves\n     * a group.\n     * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is\n     * received from anywhere on the system.\n     * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n     * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n     * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n     * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client receives a call.\n     * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this\n     * client receives a request for a direct connection.\n     * @private\n     */\n    function saveParameters(params) {\n        Object.keys(params).forEach(function eachParam(key) {\n            if (['onSuccess', 'onError', 'reconnect', 'presence'].indexOf(key) === -1 && params[key] !== undefined) {\n                clientSettings[key] = params[key];\n            }\n        });\n\n        clientSettings.developmentMode = !!clientSettings.developmentMode;\n        clientSettings.enableCallDebugReport = typeof clientSettings.enableCallDebugReport === 'boolean' ?\n            clientSettings.enableCallDebugReport : true;\n\n        if (typeof clientSettings.connectTimeoutMillis !== 'number') {\n            clientSettings.connectTimeoutMillis = 10000;\n        }\n\n        if (typeof params.reconnect !== 'boolean') {\n            clientSettings.reconnect = typeof clientSettings.developmentMode === 'boolean' ?\n                clientSettings.developmentMode : false;\n        } else {\n            clientSettings.reconnect = !!params.reconnect;\n        }\n    }\n    saveParameters(params);\n\n    /**\n     * Connect to the Respoke infrastructure and authenticate using `params.token`.\n     *\n     * After `connect`, the app auth session token is stored so it can be used in API requests.\n     *\n     * This method attaches quite a few event listeners for things like group joining and connection status changes.\n     *\n     * #### Usage\n     *\n     *      client.connect({\n     *          appId: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\",\n     *          token: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\", // if not developmentMode\n     *          developmentMode: false || true,\n     *          // if developmentMode, otherwise your server will set endpointId\n     *          endpointId: \"daveops\"\n     *      });\n     *      client.listen(\"connect\", function () { } );\n     *\n     *\n     * If no `params.token` is given and `developmentMode` is set to true, it will attempt to obtain a token\n     * automatically. You must set an `endpointId`.\n     *\n     *\n     * #### App auth session token expiration\n     *\n     * If `params.reconnect` is set to true (which it is by default for `developmentMode`), the `client`\n     * will attempt to keep reconnecting each time the app auth session expires.\n     *\n     * If not using `developmentMode`, automatic reconnect will be disabled. You will need to\n     * listen to the Client's `disconnect` event to fetch a new brokered auth token and call\n     * `client.connect()` with the new token.\n     *\n     *      client.listen('disconnect', function () {\n     *\n     *          // example method you implemented to get a new token from your server\n     *          myServer.getNewRespokeAccessToken(function (newToken) {\n     *              // reconnect with respoke.Client\n     *              client.connect({ token: newToken });\n     *          });\n     *\n     *      });\n     *\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.connect\n     * @param {object} params\n     * @param {respoke.Client.connectSuccessHandler} [params.onSuccess] - Success handler for this invocation\n     * of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {string} [params.appId] - The ID of your Respoke app. This must be passed either to\n     * respoke.connect, respoke.createClient, or to client.connect.\n     * @param {string} [params.token] - The endpoint's authentication token.\n     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @param {string|number|object|Array} [params.presence] The initial presence to set once connected.\n     * @param {respoke.client.resolveEndpointPresence} [params.resolveEndpointPresence] An optional function for\n     * resolving presence for an endpoint.  An endpoint can have multiple Connections this function will be used\n     * to decide which Connection's presence gets precedence for the Endpoint.\n     * @param {boolean} [params.developmentMode=false] - Indication to obtain an authentication token from the service.\n     * Note: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\n     * operation and will limit the services you will be able to use.\n     * @param {boolean} [params.reconnect=true] - Whether or not to automatically reconnect to the Respoke service\n     * when a disconnect occurs.\n     * @proprety {number} [connectTimeoutMillis=10000] - Number of milliseconds before considering the connect\n     * timed out.\n     * @param {respoke.Client.onJoin} [params.onJoin] - Callback for when this client's endpoint joins a group.\n     * @param {respoke.Client.onLeave} [params.onLeave] - Callback for when this client's endpoint leaves\n     * a group.\n     * @param {respoke.Client.onClientMessage} [params.onMessage] - Callback for when any message is\n     * received from anywhere on the system.\n     * @param {respoke.Client.onConnect} [params.onConnect] - Callback for Client connect.\n     * @param {respoke.Client.onDisconnect} [params.onDisconnect] - Callback for Client disconnect.\n     * @param {respoke.Client.onReconnect} [params.onReconnect] - Callback for Client reconnect. Not Implemented.\n     * @param {respoke.Client.onCall} [params.onCall] - Callback for when this client receives a call.\n     * @param {respoke.Client.onDirectConnection} [params.onDirectConnection] - Callback for when this\n     * client receives a request for a direct connection.\n     * @returns {Promise|undefined}\n     * @fires respoke.Client#connect\n     */\n    that.connect = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n        log.debug('Client.connect');\n        that.connectTries += 1;\n\n        saveParameters(params);\n        that.presence = params.presence || that.presence;\n        that.endpointId = clientSettings.endpointId;\n        promise = actuallyConnect(params);\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        promise.then(function successHandler() {\n            /**\n             * This event is fired the first time the library connects to the cloud infrastructure.\n             * @event respoke.Client#connect\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            that.fire('connect');\n        });\n        return retVal;\n    };\n\n    /**\n     * This function contains the meat of the connection, the portions which can be repeated again on reconnect.\n     *\n     * When `reconnect` is true, this function will be added in an event listener to the Client#disconnect event.\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     * @memberof! respoke.Client\n     * @method respoke.Client.actuallyConnect\n     * @private\n     * @param {object} params\n     * @param {connectSuccessHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    function actuallyConnect(params) {\n        params = params || {};\n        var deferred = Q.defer();\n\n        if (!clientSettings.token &&\n                (!clientSettings.appId || !clientSettings.endpointId || clientSettings.developmentMode !== true)) {\n            deferred.reject(new Error(\"Must pass either endpointID & appId & developmentMode=true, or a token, \" +\n                \"to client.connect().\"));\n            return deferred.promise;\n        }\n\n        that.signalingChannel.open({\n            actuallyConnect: actuallyConnect,\n            endpointId: that.endpointId,\n            token: clientSettings.token\n        }).then(function successHandler() {\n            return that.signalingChannel.authenticate();\n        }).done(function successHandler() {\n            // set initial presence for the connection\n            if (that.presence) {\n                that.setPresence({presence: that.presence});\n            }\n\n            /*\n             * These rely on the EventEmitter checking for duplicate event listeners in order for these\n             * not to be duplicated on reconnect.\n             */\n\n            /**\n             * This event provides notification for when an incoming call is being received.  If the user wishes\n             * to allow the call, `evt.call.answer()`.\n             * @event respoke.Client#call\n             * @type {respoke.Event}\n             * @property {respoke.Call} call\n             * @property {respoke.Endpoint} endpoint\n             * @property {string} name - The event name.\n             * @property {respoke.Client} target\n             */\n            that.listen('call', clientSettings.onCall);\n            /**\n             * This event is fired when the local end of the directConnection is available. It still will not be\n             * ready to send and receive messages until the 'open' event fires.\n             * @event respoke.Client#direct-connection\n             * @type {respoke.Event}\n             * @property {respoke.DirectConnection} directConnection\n             * @property {respoke.Endpoint} endpoint\n             * @property {string} name - the event name.\n             * @property {respoke.Call} target\n             */\n            that.listen('direct-connection', clientSettings.onDirectConnection);\n            that.listen('join', clientSettings.onJoin);\n            /**\n             * This event is fired every time the client leaves a group.\n             * @event respoke.Client#leave\n             * @type {respoke.Event}\n             * @property {respoke.Group} group\n             * @property {string} name - the event name.\n             */\n            that.listen('leave', clientSettings.onLeave);\n            /**\n             * A generic message handler when a message was received by the client.\n             *\n             * @event respoke.Client#message\n             * @type {respoke.Event}\n             * @property {string} name - The event name.\n             * @property {respoke.Endpoint} endpoint - If the message was private, this is the Endpoint who sent it.\n             * @property {respoke.Group} group - If the message was to a group, this is the group.\n             * @property {respoke.TextMessage} message - The generic message object.\n             * @property {string} message.connectionId\n             * @property {string} message.endpointId\n             * @property {string} message.message - Message body text.\n             * @property {respoke.Client} target\n             */\n            that.listen('message', clientSettings.onMessage);\n            that.listen('connect', clientSettings.onConnect);\n            /**\n             * Client has disconnected from Respoke.\n             *\n             * @event respoke.Client#disconnect\n             * @type {respoke.Event}\n             * @property {string} name - The event name.\n             * @property {respoke.Client} target\n             */\n            that.listen('disconnect', clientSettings.onDisconnect);\n            that.listen('disconnect', function () {\n                that.calls.forEach(function (call) {\n                    call.hangup({signal: false});\n                });\n            }, true);\n            /**\n             * Client has reconnected to Respoke.\n             *\n             * @event respoke.Client#reconnect\n             * @type {respoke.Event}\n             * @property {string} name - The event name.\n             * @property {respoke.Client} target\n             */\n            that.listen('reconnect', clientSettings.onReconnect);\n\n            log.info('logged in as ' + that.endpointId, that);\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n            if (err.message && err.message.match(/Connection limit exceeded/)) {\n                log.error(\n                    'You have reached the connection limit on the account associated with this appId. ' +\n                    'Please upgrade your account from the developer portal at https://portal.respoke.io ' +\n                    'if you need more concurrent connections.', err);\n            } else {\n                log.error(err.message, err.stack);\n            }\n        });\n\n        return deferred.promise;\n    }\n\n    /**\n     * Disconnect from the Respoke infrastructure, leave all groups, invalidate the token, and disconnect the websocket.\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     * @memberof! respoke.Client\n     * @method respoke.Client.disconnect\n     * @returns {Promise|undefined}\n     * @param {object} params\n     * @param {disconnectSuccessHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @fires respoke.Client#disconnect\n     */\n    that.disconnect = function (params) {\n        // TODO: also call this on socket disconnect\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            deferred.reject(e);\n            return retVal;\n        }\n\n        var leaveGroups = groups.map(function eachGroup(group) {\n            if (group.isJoined()) {\n                return group.leave();\n            }\n        });\n\n        Q.all(leaveGroups).fin(function successHandler() {\n            return that.signalingChannel.close();\n        }).fin(function finallyHandler() {\n            that.presence = 'unavailable';\n            endpoints = [];\n            groups = [];\n            /**\n             * This event is fired when the library has disconnected from the cloud infrastructure.\n             * @event respoke.Client#disconnect\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            that.fire('disconnect');\n            deferred.resolve();\n        }).done();\n\n        return retVal;\n    };\n\n    /**\n     * Set the presence for this client.\n     *\n     * The value of presence can be a string, number, object, or array - in any format -\n     * depending on the needs of your application. The only requirement is that\n     * `JSON.stringify()` must work (no circular references).\n     *\n     *      var myPresence = 'At lunch'\n     *                      || 4\n     *                      || { status: 'Away', message: 'At lunch' }\n     *                      || ['Away', 'At lunch'];\n     *\n     *      client.setPresence({\n     *          presence: myPresence,\n     *          onSuccess: function (evt) {\n     *              // successfully updated my presence\n     *          }\n     *      });\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     *\n     * ### Resolving presence\n     *\n     * When not using a custom endpoint presence resolver\n     * (see `respoke.createClient({ resolveEndpointPresence: <Function> })`)\n     * these are the supported presence values. Values not below will be put at the end of the\n     * list when resolving an endpoint's presence across the presence of its connections.\n     *\n     * ```\n     * ['chat', 'available', 'away', 'dnd', 'xa', 'unavailable']\n     * ```\n     *\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.setPresence\n     * @param {object} params\n     * @param {string|number|object|array} params.presence\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @return {Promise|undefined}\n     */\n    that.setPresence = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n        params.presence = params.presence || 'available';\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        log.info('sending my presence update ' + params.presence);\n\n        promise = that.signalingChannel.sendPresence({\n            presence: params.presence\n        }).then(function successHandler(p) {\n            that.presence = params.presence;\n\n            /**\n             * This event indicates that the presence for this endpoint has been updated.\n             * @event respoke.Client#presence\n             * @type {respoke.Event}\n             * @property {string|number|object|Array} presence\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            that.fire('presence', {\n                presence: that.presence\n            });\n        });\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };\n\n    /**\n     * Get the Call with the endpoint specified.\n     *\n     *     // hang up on chad\n     *     var call = client.getCall({\n     *         endpointId: 'chad'\n     *     });\n     *\n     *     if (call) {\n     *         call.hangup()\n     *     }\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getCall\n     * @param {object} params\n     * @param {string} [params.id] - Call ID.\n     * @param {string} [params.endpointId] - Endpoint ID. Warning: If you pass only the endpointId, this method\n     * will just return the first call that matches. If you are placing multiple calls to the same endpoint,\n     * pass in the call ID, too.\n     * @arg {boolean} [params.create] - whether or not to create a new call if the specified endpointId isn't found\n     * @arg {string} [params.fromType] - fromType from the signal, tells us if this is a SIP or DID call.\n     * @arg {string} [params.target] - target from the signal, tells us if this is a screenshare or conference call.\n     * @arg {*} [params.metadata] - Metadata to be attached to the call if created, accessible by the callee.\n     * @returns {respoke.Call}\n     */\n    that.getCall = function (params) {\n        var call = null;\n        var methods = {\n            screenshare: \"startScreenShare\",\n            did: \"startPhoneCall\",\n            web: \"startCall\",\n            sip: \"startSIPCall\",\n            conference: \"joinConference\"\n        };\n        var callParams = {};\n        params.fromType = params.type || \"web\";\n        var switchType = params.type;\n\n        that.calls.every(function findCall(one) {\n            if (params.id && one.id === params.id) {\n                call = one;\n                return false;\n            }\n\n            if (!params.id && params.endpointId && one.remoteEndpoint.id === params.endpointId) {\n                call = one;\n                return false;\n            }\n            return true;\n        });\n\n        if (call || params.create !== true) {\n            return call;\n        }\n\n        callParams.id = params.id;\n        callParams.caller = false;\n        callParams.fromType = \"web\";\n        callParams.callerId = params.callerId;\n        callParams.target = params.target;\n        callParams.metadata = params.metadata;\n\n        if (params.target === \"conference\") {\n            callParams.id = params.conferenceId;\n            switchType = params.target;\n        } else if (params.target === \"screenshare\") {\n            switchType = params.target;\n        }\n\n        switch (switchType) {\n            case \"screenshare\":\n            case \"web\":\n                callParams.toType = \"web\"; // overwrite \"screenshare\"\n                callParams.endpointId = params.endpointId;\n                break;\n            case \"did\":\n                callParams.number = params.endpointId;\n                callParams.toType = \"did\";\n                break;\n            case \"sip\":\n                callParams.uri = params.endpointId;\n                callParams.toType = \"sip\";\n                break;\n        }\n\n        try {\n            call = that[methods[params.type]](callParams);\n        } catch (e) {\n            log.error(\"Couldn't create Call.\", e.message, e.stack);\n        }\n        return call;\n    };\n\n    /**\n     * Add the call to internal record-keeping.\n     * @memberof! respoke.Client\n     * @method respoke.Client.addCall\n     * @param {object} evt\n     * @param {respoke.Call} evt.call\n     * @private\n     */\n    function addCall(evt) {\n        log.debug('addCall');\n        if (!evt.call) {\n            throw new Error(\"Can't add call without a call parameter.\");\n        }\n        if (that.calls.indexOf(evt.call) === -1) {\n            that.calls.push(evt.call);\n        }\n\n        evt.call.listen('hangup', function () {\n            removeCall({ call: evt.call });\n        }, true);\n    }\n\n    /**\n     * Remove the call or direct connection from internal record-keeping.\n     * @memberof! respoke.Client\n     * @method respoke.Client.removeCall\n     * @param {object} evt\n     * @param {respoke.Call} evt.call\n     * @private\n     */\n    function removeCall(evt) {\n        var match = 0;\n        if (!evt.call) {\n            throw new Error(\"Can't remove call without a call parameter.\");\n        }\n\n        // Loop backward since we're modifying the array in place.\n        for (var i = that.calls.length - 1; i >= 0; i -= 1) {\n            if (that.calls[i].id === evt.call.id) {\n                that.calls.splice(i, 1);\n                match += 1;\n            }\n        }\n\n        if (match !== 1) {\n            log.warn(\"Something went wrong.\", match, \"calls were removed!\");\n        }\n    }\n\n    /**\n     * Convenience method for setting presence to `\"available\"`.\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.setOnline\n     * @param {object} params\n     * @param {string|number|object|Array} [params.presence=available] - The presence to set.\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.setOnline = function (params) {\n        var promise;\n\n        params = params || {};\n        params.presence = params.presence || 'available';\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        return that.setPresence(params);\n    };\n\n    /**\n     * Convenience method for setting presence to `\"unavailable\"`.\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.setOffline\n     * @param {object} params\n     * @param {string|number|object|Array} [params.presence=unavailable] - The presence to set.\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.setOffline = function (params) {\n        var promise;\n\n        params = params || {};\n        params.presence = params.presence || 'unavailable';\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        return that.setPresence(params);\n    };\n\n    /**\n     * Send a message to an endpoint.\n     *\n     *     client.sendMessage({\n     *         endpointId: 'dan',\n     *         message: \"Jolly good.\"\n     *     });\n     *\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     * @memberof! respoke.Client\n     * @method respoke.Client.sendMessage\n     * @param {object} params\n     * @param {string} params.endpointId - The endpoint id of the recipient.\n     * @param {string} [params.connectionId] - The optional connection id of the receipient. If not set, message will be\n     * broadcast to all connections for this endpoint.\n     * @param {string} params.message - a string message.\n     * @param {sendHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        var promise;\n        var retVal;\n        var endpoint;\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n        endpoint = that.getEndpoint({\n            skipPresence: true,\n            id: params.endpointId\n        });\n        delete params.endpointId;\n        return endpoint.sendMessage(params);\n    };\n\n    /**\n     * Experimental. Create a new conference call with the specified id.\n     *\n     *     client.joinConference({\n     *         id: \"javascript-meetup\",\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof respoke.Client\n     * @method respoke.Client.joinConference\n     * @private\n     * @param {object} params\n     * @param {string} params.id - The id that should be used to create the conference call or the ID\n     * of the call to join.\n     * @param {string|boolean} params.audio - Whether participant should send and receive audio. Boolean `true`\n     * indicates send and receive. Boolean `false` indicates neither send nor receive. Strings `send` and `receive`\n     * indicate send only and receive only respectively.\n     * @param {string|boolean} params.video - Whether participant should send and receive audio. Boolean `true`\n     * indicates send and receive. Boolean `false` indicates neither send nor receive. Strings `send` and `receive`\n     * indicate send only and receive only respectively.\n     * @param {boolean} params.mixAudio - Whether Respoke should mix all the audio streams together to save bandwidth\n     * for this one participant.\n     * @param {Array<RTCConstraints>} [params.constraints]\n     * @arg {respoke.Conference.onJoin} [params.onJoin] - Callback for when a participant joins the conference.\n     * @arg {respoke.Conference.onLeave} [params.onLeave] - Callback for when a participant leaves the conference.\n     * @arg {respoke.Conference.onMessage} [params.onMessage] - Callback for when a message is sent to the conference.\n     * @param {respoke.Conference.onMute} [params.onMute] - Callback for when local or remote media is muted or unmuted.\n     * @arg {respoke.Conference.onTopic} [params.onTopic] - Callback for the conference topic changes.\n     * @arg {respoke.Conference.onPresenter} [params.onPresenter] - Callback for when the presenter changes.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n     * and the remote party has received the video.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {*} [params.metadata] - Metadata to be attached to the conference call, accessible by the callee.\n     * @returns {respoke.Conference}\n     */\n    that.joinConference = function (params) {\n        var conference;\n        var recipient;\n\n        that.verifyConnected();\n\n        params = params || {};\n        params.open = !!params.open;\n\n        if (!params.id) {\n            params.id = respoke.makeGUID();\n        }\n\n        recipient = {id: params.id};\n\n        if (params.open) {\n            params.key = undefined;\n        } else if (!params.key) {\n            params.key = respoke.makeGUID();\n        }\n\n        params.instanceId = instanceId;\n        params.target = \"conference\";\n        params.constraints = respoke.convertConstraints(params.constraints, [{\n            video: false,\n            audio: true,\n            mandatory: {},\n            optional: []\n        }]);\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = params.target;\n            signalParams.id = params.id;\n            signalParams.key = params.key;\n            signalParams.open = params.open;\n            signalParams.recipient = recipient;\n            signalParams.toType = \"conference\";\n            signalParams.metadata = params.metadata;\n\n            that.signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'answer';\n            signalParams.target = params.target;\n            signalParams.recipient = recipient;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.toType = \"conference\";\n            that.signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = params.target;\n            signalParams.connectionId = signalParams.call.connectionId;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.recipient = recipient;\n            signalParams.toType = \"conference\";\n            that.signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = params.target;\n            signalParams.recipient = recipient;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.toType = \"conference\";\n            that.signalingChannel.sendModify(signalParams).done();\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = params.target;\n            signalParams.recipient = recipient;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.toType = \"conference\";\n            return that.signalingChannel.sendCandidate(signalParams);\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = params.target;\n            signalParams.recipient = recipient;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.toType = \"conference\";\n            that.signalingChannel.sendHangup(signalParams).done();\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            that.signalingChannel.sendReport(signalParams).done();\n        };\n\n        params.signalingChannel = that.signalingChannel;\n        conference = respoke.Conference(params);\n        addCall({ call: conference.call });\n        return conference;\n    };\n\n    /**\n     * Create a new screen sharing call. Screenshares are inherently unidirectional video only. This may change\n     * in the future when Chrome adds the ability to obtain screen video and microphone audio at the same time. For\n     * now, if you also need audio, place a second audio only call.\n     *\n     * The endpoint who calls `client.startScreenShare` will be the one whose screen is shared. If you'd like to\n     * implement this as a screenshare request in which the endpoint who starts the call is the watcher and\n     * not the sharer, it is recommened that you use `endpoint.sendMessage` to send a control message to the user\n     * whose screenshare is being requested so that user's app can call `client.startScreenShare`.\n     *\n     * NOTE: At this time, screen sharing only works with Chrome, and Chrome requires a Chrome extension to\n     * access screen sharing features. Please see instructions at https://github.com/respoke/respoke-chrome-extension.\n     * Support for additional browsers will be added in the future.\n     *\n     *     client.startScreenShare({\n     *         endpointId: 'tian',\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.startScreenShare\n     * @param {object} params\n     * @param {string} params.endpointId - The id of the endpoint that should be called.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n     * and the remote party has received the video.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {string} [params.source] - Pass in what type of mediaSource you want. If omitted, you'll have access\n     * to both the screen and windows. In firefox, you'll have access to the screen only.\n     * @param {*} [params.metadata] - Metadata to be attached to the screenShare, accessible by the callee.\n     * @returns {respoke.Call}\n     */\n    that.startScreenShare = function (params) {\n        that.verifyConnected();\n        var endpoint = that.getEndpoint({\n            skipPresence: true,\n            id: params.endpointId\n        });\n        delete params.endpointId;\n        return endpoint.startScreenShare(params);\n    };\n\n    /**\n     * Place an audio and/or video call to an endpoint.\n     *\n     *     // defaults to video when no constraints are supplied\n     *     client.startCall({\n     *         endpointId: 'erin',\n     *         onConnect: function (evt) { },\n     *         onLocalMedia: function (evt) { }\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.startCall\n     * @param {object} params\n     * @param {string} params.endpointId - The id of the endpoint that should be called.\n     * @param {Array<RTCConstraints>} [params.constraints]\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have\n     * local video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have\n     * remote video attached to it.\n     * @param {*} [params.metadata] - Metadata to be attached to the call, accessible by the callee.\n     * @return {respoke.Call}\n     */\n    that.startCall = function (params) {\n        that.verifyConnected();\n        var endpoint = that.getEndpoint({\n            skipPresence: true,\n            id: params.endpointId\n        });\n        delete params.endpointId;\n        return endpoint.startCall(params);\n    };\n\n    /**\n     * Place an audio only call to an endpoint.\n     *\n     *     client.startAudioCall({\n     *         endpointId: 'erin',\n     *         onConnect: function (evt) { },\n     *         onLocalMedia: function (evt) { }\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.startAudioCall\n     * @param {object} params\n     * @param {string} params.endpointId - The id of the endpoint that should be called.\n     * @param {string} [params.connectionId]\n     * @param {Array<RTCConstraints>} [params.constraints]\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n     * video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n     * video attached to it.\n     * @param {*} [params.metadata] - Metadata to be attached to the audio call, accessible by the callee.\n     * @return {respoke.Call}\n     */\n    that.startAudioCall = function (params) {\n        that.verifyConnected();\n        var endpoint = that.getEndpoint({\n            skipPresence: true,\n            id: params.endpointId\n        });\n        delete params.endpointId;\n        return endpoint.startAudioCall(params);\n    };\n\n    /**\n     * Place a video call to an endpoint.\n     *\n     *     client.startVideoCall({\n     *         endpointId: 'erin',\n     *         onConnect: function (evt) { },\n     *         onLocalMedia: function (evt) { }\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.startVideoCall\n     * @param {object} params\n     * @param {string} params.endpointId - The id of the endpoint that should be called.\n     * @param {Array<RTCConstraints>} [params.constraints]\n     * @param {string} [params.connectionId]\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n     * video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n     * video attached to it.\n     * @param {*} [params.metadata] - Metadata to be attached to the video call, accessible by the callee.\n     * @return {respoke.Call}\n     */\n    that.startVideoCall = function (params) {\n        that.verifyConnected();\n        var endpoint = that.getEndpoint({\n            skipPresence: true,\n            id: params.endpointId\n        });\n        delete params.endpointId;\n        return endpoint.startVideoCall(params);\n    };\n\n    /**\n     * Place an audio call with a phone number.\n     * @memberof! respoke.Client\n     * @method respoke.Client.startPhoneCall\n     * @param {object} params\n     * @param {string} params.number - The phone number that should be called.\n     * @param {string} params.callerId - The phone number to use as the caller ID for this phone call. This must\n     * be a phone number listed in your Respoke account, associated with your app, and allowed by the role\n     * that this client is authenticated with. If the role contains a list of numbers and the token does not contain\n     * callerId, this field must be used to set caller ID selected from the list of numbers or no caller ID will be set.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {*} [params.metadata] - Metadata to be attached to the phone call, accessible by the callee.\n     * @return {respoke.Call}\n     */\n    that.startPhoneCall = function (params) {\n        var call;\n        var recipient = {};\n        params = params || {};\n        params.constraints = [{\n            video: false,\n            audio: true,\n            mandatory: {},\n            optional: []\n        }];\n\n        that.verifyConnected();\n\n        if (!params.number) {\n            throw new Error(\"Can't start a phone call without a number.\");\n        }\n\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        recipient.id = params.number;\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = recipient;\n\n        params.toType = params.toType || 'did';\n        params.fromType = params.fromType || 'web';\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalParams.metadata = params.metadata;\n\n            // using hasOwnProperty here because callerId could be explicitly set to null or empty string\n            if (params.hasOwnProperty('callerId')) {\n                signalParams.callerId = {number: params.callerId};\n            }\n            that.signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'answer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            that.signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            that.signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            that.signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send modify.\", err.message, err.stack);\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            return that.signalingChannel.sendCandidate(signalParams);\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            that.signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            that.signalingChannel.sendReport(signalParams);\n        };\n\n        params.signalingChannel = that.signalingChannel;\n        call = respoke.Call(params);\n        addCall({ call: call });\n        return call;\n    };\n\n    /**\n     * Place an audio call to a SIP URI.\n     * @memberof! respoke.Client\n     * @method respoke.Client.startSIPCall\n     * @param {object} params\n     * @param {string} [params.uri] - The fully qualified SIP URI to call.\n     * @param {string} [params.trunk] - The SIP trunk to call. This is not necessary if `uri` is set. If `uri` is not\n     * set, both `trunk` and `user` are required, and `trunk` must be the ID of a Respoke SIP trunk. `user` is a\n     * SIP username or extension.\n     * @param {string} [params.user] - The SIP user to call. This is not necessary if `uri` is set. If `uri` is not\n     * set, both `trunk` and `user` are required, and `trunk` must be the ID of a Respoke SIP trunk. `user` is a\n     * SIP username or extension.\n     * @param {object} [params.callerId] - Caller ID information for this call.\n     * @param {string} [params.callerId.name] - Caller ID name.\n     * @param {string} [params.callerId.number] - Caller ID number, extension, or SIP username.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video element\n     * with the local audio and/or video attached.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video element\n     * with the remote audio and/or video attached.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been hung\n     * up.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {*} [params.metadata] - Metadata to be attached to the SIP call, accessible by the callee.\n     * @return {respoke.Call}\n     */\n    that.startSIPCall = function (params) {\n        var call;\n        var recipient = {};\n        params = params || {};\n        params.constraints = [{\n            video: false,\n            audio: true,\n            mandatory: {},\n            optional: []\n        }];\n\n        that.verifyConnected();\n\n        if (!params.uri && !(params.trunk && params.user)) {\n            throw new Error(\"Can't start a phone call without a SIP URI or a SIP trunk and user.\");\n        }\n\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        params.uri = params.uri || (params.trunk + \"/\" + params.user);\n        recipient.id = params.uri;\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = recipient;\n\n        params.toType = params.toType || 'sip';\n        params.fromType = params.fromType || 'web';\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalParams.metadata = params.metadata;\n\n            // using hasOwnProperty here because callerId could be explicitly set to null or empty string\n            if (params.hasOwnProperty('callerId')) {\n                signalParams.callerId = params.callerId;\n            }\n            that.signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'answer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            that.signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            that.signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            that.signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send modify.\", err.message, err.stack);\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            return that.signalingChannel.sendCandidate(signalParams);\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            that.signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            that.signalingChannel.sendReport(signalParams);\n        };\n\n        params.signalingChannel = that.signalingChannel;\n        call = respoke.Call(params);\n        addCall({ call: call });\n        return call;\n    };\n\n    /**\n     * Assert that we are connected to the backend infrastructure.\n     * @memberof! respoke.Client\n     * @method respoke.Client.verifyConnected\n     * @throws {Error}\n     * @private\n     */\n    that.verifyConnected = function () {\n        if (!that.signalingChannel.isConnected()) {\n            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n        }\n    };\n\n    /**\n     * Check whether this client is connected to the Respoke API.\n     * @memberof! respoke.Client\n     * @method respoke.Client.isConnected\n     * @returns boolean\n     */\n    that.isConnected = function () {\n        return that.signalingChannel.isConnected();\n    };\n\n    /**\n     * Join a group and begin keeping track of it. If this method is called multiple times synchronously, it will\n     * batch requests and only make one API call to Respoke.\n     *\n     * You can leave the group by calling `group.leave()`;\n     *\n     * ##### Joining and leaving a group\n     *\n     *      var group;\n     *\n     *      client.join({\n     *          id: \"book-club\",\n     *          onSuccess: function (evt) {\n     *              console.log('I joined', evt.group.id);\n     *              // \"I joined book-club\"\n     *              group = evt.group;\n     *              group.sendMessage({\n     *                  message: 'sup'\n     *              });\n     *          }\n     *      });\n     *\n     *      // . . .\n     *      // Some time later, leave the group.\n     *      // . . .\n     *      group.leave({\n     *          onSuccess: function (evt) {\n     *              console.log('I left', evt.group.id);\n     *              // \"I left book-club\"\n     *          }\n     *      });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.join\n     * @param {object} params\n     * @param {string} params.id - The name of the group.\n     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {respoke.Group.onMessage} [params.onMessage] - Message handler for messages from this group only.\n     * @param {respoke.Group.onJoin} [params.onJoin] - Join event listener for endpoints who join this group only.\n     * @param {respoke.Group.onLeave} [params.onLeave] - Leave event listener for endpoints who leave\n     * this group only.\n     * @returns {Promise<respoke.Group>|undefined} The instance of the respoke.Group which the client joined.\n     * @fires respoke.Client#join\n     */\n    that.join = function (params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            deferred.reject(e);\n            return retVal;\n        }\n\n        if (!params.id) {\n            deferred.reject(new Error(\"Can't join a group with no group id.\"));\n            return retVal;\n        }\n\n        log.trace('requested to join group', params.id);\n\n        that.signalingChannel.joinGroup({\n            groupList: [params.id]\n        }).done(function successHandler() {\n            var group;\n            params.signalingChannel = that.signalingChannel;\n            params.instanceId = instanceId;\n\n            group = that.getGroup({id: params.id});\n\n            if (!group) {\n                group = respoke.Group(params);\n                that.addGroup(group);\n            }\n\n            group.listen('join', params.onJoin);\n            group.listen('leave', params.onLeave);\n            group.listen('message', params.onMessage);\n\n            group.addMember({\n                connection: that.getConnection({\n                    endpointId: that.endpointId,\n                    connectionId: that.connectionId\n                })\n            });\n\n            /**\n             * This event is fired every time the client joins a group. If the client leaves\n             * a group, this event will be fired again on the next time the client joins the group.\n             * @event respoke.Client#join\n             * @type {respoke.Event}\n             * @property {respoke.Group} group\n             * @property {string} name - the event name.\n             */\n            that.fire('join', {\n                group: group\n            });\n            deferred.resolve(group);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return retVal;\n    };\n\n    /**\n     * Add a Group. This is called when we join a group and need to begin keeping track of it.\n     * @memberof! respoke.Client\n     * @method respoke.Client.addGroup\n     * @param {respoke.Group}\n     * @private\n     */\n    that.addGroup = function (newGroup) {\n        if (!newGroup || newGroup.className !== 'respoke.Group') {\n            throw new Error(\"Can't add group to internal tracking without a group.\");\n        }\n\n        newGroup.listen('leave', function leaveHandler(evt) {\n            var endpointThatLeft = evt.connection.getEndpoint();\n\n            if (!endpointThatLeft.hasListeners('presence') && endpointThatLeft.groupConnectionCount === 0) {\n                // No one is listening, and it's not in any more groups.\n                endpoints.every(function eachEndpoint(ept, index) {\n                    if (ept.id === endpointThatLeft.id) {\n                        endpoints.splice(index, 1);\n                        return false;\n                    }\n                    return true;\n                });\n            }\n        }, true);\n\n        groups.push(newGroup);\n    };\n\n    /**\n     * Get a list of all the groups the client is currently a member of.\n     * @memberof! respoke.Client\n     * @method respoke.Client.getGroups\n     * @returns {Array<respoke.Group>} All of the groups the library is aware of.\n     */\n    that.getGroups = function () {\n        return groups;\n    };\n\n    /**\n     * Find a group by id and return it.\n     *\n     *     var group = client.getGroup({\n     *         id: \"resistance\"\n     *     });\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getGroup\n     * @param {object} params\n     * @param {string} params.id\n     * @param {respoke.Group.onJoin} [params.onJoin] - Receive notification that an endpoint has joined this group.\n     * @param {respoke.Group.onLeave} [params.onLeave] - Receive notification that an endpoint has left this group.\n     * @param {respoke.Group.onMessage} [params.onMessage] - Receive notification that a message has been\n     * received to a group.\n     * @returns {respoke.Group|undefined} The group whose ID was specified.\n     */\n    that.getGroup = function (params) {\n        var group;\n        if (!params || !params.id) {\n            throw new Error(\"Can't get a group without group id.\");\n        }\n\n        groups.every(function eachGroup(grp) {\n            if (grp.id === params.id) {\n                group = grp;\n                return false;\n            }\n            return true;\n        });\n\n        if (group) {\n            group.listen('join', params.onJoin);\n            group.listen('leave', params.onLeave);\n            group.listen('message', params.onMessage);\n        }\n\n        return group;\n    };\n\n    /**\n     * Find an endpoint by id and return the `respoke.Endpoint` object.\n     *\n     * If it is not already cached locally, will be added to the local cache of tracked endpoints,\n     * its presence will be determined, and will be available in `client.getEndpoints()`.\n     *\n     *     var endpoint = client.getEndpoint({\n     *         id: \"dlee\"\n     *     });\n     *\n     * @ignore If the endpoint is not found in the local cache of endpoint objects (see `client.getEndpoints()`),\n     * it will be created. This is useful, for example, in the case of dynamic endpoints where groups are\n     * not in use. Override dynamic endpoint creation by setting `params.skipCreate = true`.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getEndpoint\n     * @param {object} params\n     * @param {string} params.id\n     * @param {respoke.Endpoint.onMessage} [params.onMessage] - Handle messages sent to the logged-in user\n     * from this one Endpoint.\n     * @param {respoke.Endpoint.onPresence} [params.onPresence] - Handle presence notifications from this one\n     * Endpoint.\n     * @arg {boolean} [params.skipCreate] - Skip the creation step and return undefined if we don't yet\n     * @arg {boolean} [params.skipPresence] - Skip registering for this endpoint's presence.\n     * @returns {respoke.Endpoint} The endpoint whose ID was specified.\n     */\n    that.getEndpoint = function (params) {\n        var endpoint;\n        if (!params || !params.id) {\n            throw new Error(\"Can't get an endpoint without endpoint id.\");\n        }\n\n        endpoints.every(function eachEndpoint(ept) {\n            if (ept.id === params.id) {\n                endpoint = ept;\n                return false;\n            }\n            return true;\n        });\n\n        if (!endpoint && params && !params.skipCreate) {\n            params.instanceId = instanceId;\n            params.signalingChannel = that.signalingChannel;\n            params.resolveEndpointPresence = clientSettings.resolveEndpointPresence;\n            params.addCall = addCall;\n\n            endpoint = respoke.Endpoint(params);\n            endpoints.push(endpoint);\n        }\n\n        if (!endpoint) {\n            return;\n        }\n\n        if (params.skipPresence !== true) {\n            that.signalingChannel.registerPresence({\n                endpointList: [endpoint.id]\n            }).done(null, function (err) {\n                log.error(\"Couldn't register for presence on\", endpoint.id, err.message);\n            });\n        }\n        endpoint.listen('presence', params.onPresence);\n        endpoint.listen('message', params.onMessage);\n\n        return endpoint;\n    };\n\n    /**\n     * Find a Connection by id and return it.\n     *\n     *     var connection = client.getConnection({\n     *         id: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\"\n     *     });\n     *\n     * @ignore In most cases, if we don't find it we will create it. This is useful\n     * in the case of dynamic endpoints where groups are not in use. Set skipCreate=true\n     * to return undefined if the Connection is not already known.\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getConnection\n     * @param {object} params\n     * @param {string} params.connectionId\n     * @param {string} [params.endpointId] - An endpointId to use in the creation of this connection.\n     * @param {respoke.Endpoint.onMessage} [params.onMessage] - Handle messages sent to the logged-in user\n     * from this one Connection.\n     * @param {respoke.Endpoint.onPresence} [params.onPresence] - Handle presence notifications from this one\n     * Connection.\n     * @returns {respoke.Connection} The connection whose ID was specified.\n     */\n    that.getConnection = function (params) {\n        var connection;\n        var endpoint;\n        var endpointsToSearch = endpoints;\n\n        params = params || {};\n        if (!params.connectionId) {\n            throw new Error(\"Can't get a connection without connection id.\");\n        }\n        if (!params.endpointId && !params.skipCreate) {\n            throw new Error(\"Can't create a connection without endpoint id.\");\n        }\n\n        if (params.endpointId) {\n            endpoint = that.getEndpoint({\n                id: params.endpointId,\n                skipPresence: true,\n                skipCreate: params.skipCreate\n            });\n\n            endpointsToSearch = [];\n            if (endpoint) {\n                endpointsToSearch = [endpoint];\n            }\n        }\n\n        endpointsToSearch.every(function eachEndpoint(ept) {\n            connection = ept.getConnection(params);\n            return !connection;\n        });\n\n        if (!connection && !params.skipCreate) {\n            params.instanceId = instanceId;\n            connection = respoke.Connection(params);\n            endpoint.connections.push(connection);\n        }\n\n        return connection;\n    };\n\n    /**\n     * Get the list of **all endpoints** that the library has knowledge of.\n     * These are `respoke.Endpoint` objects, not just the endpointIds.\n     *\n     * The library gains knowledge of an endpoint in two ways:\n     * 1. when an endpoint joins a group that the user (currently logged-in endpoint) is a member of (if group presence is enabled)\n     * 2. when an endpoint that the user (currently logged-in endpoint) is watching*\n     *\n     * *If an endpoint that the library does not know about sends a message to the client, you\n     * can immediately call the `client.getEndpoint()` method on the sender of the message to enable\n     * watching of the sender's endpoint.\n     *\n     *      client.on('message', function (data) {\n     *          if (data.endpoint) {\n     *              // start tracking this endpoint.\n     *              client.getEndpoint({ id: data.endpoint.id });\n     *          }\n     *      });\n     *\n     *\n     * @memberof! respoke.Client\n     * @method respoke.Client.getEndpoints\n     * @returns {Array<respoke.Endpoint>}\n     */\n    that.getEndpoints = function () {\n        return endpoints;\n    };\n\n    /**\n     * Get conference participants by conference id.\n     *\n     * ```\n     * client.getConferenceParticipants({ id: 'mygroup' }).done(function (participants) {\n     *     var ids = participants.map(function (p) { return p.endpointId; });\n     *     console.log(ids); // ['person1', 'person2']\n     * });\n     * ```\n     * @memberof respoke.Client\n     * @method respoke.Client.getConferenceParticipants\n     * @private\n     * @param object {params}\n     * @param string {params.id}\n     * @returns {Promise}\n     */\n    that.getConferenceParticipants = that.signalingChannel.getConferenceParticipants;\n\n    return that;\n}; // End respoke.Client\n\n/**\n * Handle sending successfully.\n * @callback respoke.Client.successHandler\n */\n/**\n * Handle joining a group successfully. This callback is called only once when Client.join() is called.\n * @callback respoke.Client.joinHandler\n * @param {respoke.Group} group\n */\n/**\n * Receive notification that the client has joined a group. This callback is called everytime\n * respoke.Client#join is fired.\n * @callback respoke.Client.onJoin\n * @param {respoke.Event} evt\n * @param {respoke.Group} evt.group\n * @param {string} evt.name - the event name.\n */\n/**\n * Receive notification that the client has left a group. This callback is called everytime\n * respoke.Client#leave is fired.\n * @callback respoke.Client.onLeave\n * @param {respoke.Event} evt\n * @param {respoke.Group} evt.group\n * @param {string} evt.name - the event name.\n */\n/**\n * Receive notification that a message has been received. This callback is called every time\n * respoke.Client#message is fired.\n * @callback respoke.Client.onClientMessage\n * @param {respoke.Event} evt\n * @param {respoke.TextMessage} evt.message\n * @param {respoke.Group} [evt.group] - If the message is to a group we already know about,\n * this will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\n * the group. From that point forward, Group#message will fire when a message is received as well. If\n * group is undefined instead of null, the message is not a group message at all.\n * @param {string} evt.name - the event name.\n * @param {respoke.Client} evt.target\n */\n/**\n * Receive notification that the client is receiving a call from a remote party. This callback is called every\n * time respoke.Client#call is fired.\n * @callback respoke.Client.onCall\n * @param {respoke.Event} evt\n * @param {respoke.Call} evt.call\n * @param {respoke.Endpoint} evt.endpoint\n * @param {string} evt.name - the event name.\n */\n/**\n * Receive notification that the client is receiving a request for a direct connection from a remote party.\n * This callback is called every time respoke.Client#direct-connection is fired.\n * @callback respoke.Client.onDirectConnection\n * @param {respoke.Event} evt\n * @param {respoke.DirectConnection} evt.directConnection\n * @param {respoke.Endpoint} evt.endpoint\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * Receive notification Respoke has successfully connected to the cloud. This callback is called every time\n * respoke.Client#connect is fired.\n * @callback respoke.Client.onConnect\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Client} evt.target\n */\n/**\n * Receive notification Respoke has successfully disconnected from the cloud. This callback is called every time\n * respoke.Client#disconnect is fired.\n * @callback respoke.Client.onDisconnect\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Client} evt.target\n */\n/**\n * Receive notification Respoke has successfully reconnected to the cloud. This callback is called every time\n * respoke.Client#reconnect is fired.\n * @callback respoke.Client.onReconnect\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Client} evt.target\n */\n/**\n * Handle disconnection to the cloud successfully.\n * @callback respoke.Client.disconnectSuccessHandler\n */\n/**\n * Handle an error that resulted from a method call.\n * @callback respoke.Client.errorHandler\n * @params {Error} err\n */\n/**\n * Handle connection to the cloud successfully.\n * @callback respoke.Client.connectSuccessHandler\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/client.js\n ** module id = 9\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar respoke = require('./respoke');\n\n/**\n * A `respoke.Connection` always belongs to an Endpoint.\n *\n * There is a distinction between Endpoint and Connection because an Endpoint can be authenticated\n * from multiple devices, browsers, or browser tabs. Each of these separate authentications is a Connection.\n * A Client can choose to interact with connections of the same endpoint in different ways.\n *\n * @constructor\n * @class respoke.Connection\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.id\n * @returns {respoke.Connection}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Connection\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name client\n     * @type {respoke.Client}\n     * @private\n     */\n    var client = respoke.getClient(instanceId);\n\n    /**\n     * The connection id.\n     * @memberof! respoke.Connection\n     * @name id\n     * @type {string}\n     */\n    that.id = that.id || that.connectionId;\n    if (!that.id) {\n        throw new Error(\"Can't make a connection without an id.\");\n    }\n    delete that.instanceId;\n    delete that.connectionId;\n\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.Connection\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Connection';\n\n    /**\n     * Represents the presence status. Typically a string, but other types are supported.\n     * Defaults to `'unavailable'`.\n     *\n     * **Do not modify this directly** - it won't update presence with Respoke. Presence must be updated\n     * by the remote endpoint.\n     *\n     * @memberof! respoke.Connection\n     * @name presence\n     * @type {string|number|object|Array}\n     */\n    that.presence = 'unavailable';\n\n    /**\n     * Deprecated: use endpoint.presence instead.\n     *\n     * Return the presence.\n     * @memberof! respoke.Connection\n     * @deprecated\n     * @name presence\n     * @type {string|number|object|Array}\n     */\n    that.getPresence = function () {\n        return that.presence;\n    };\n\n    /**\n     * Send a message to this connection of an endpoint. If the endpoint has multiple connections,\n     * it will only receive the message at this connection.\n     *\n     *     connection.sendMessage({\n     *         message: \"PJ, put that PBR down!\"\n     *     });\n     *\n     * **Using callbacks** will disable promises.\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.sendMessage\n     * @param {object} params\n     * @param {string} params.message\n     * @param {boolean} [params.ccSelf=false] Copy this client's own endpoint on this message so that they arrive\n     * at other devices it might be logged into elsewhere.\n     * @param {boolean} [params.push=false] Whether or not the message should be considered for push notifications to\n     * mobile devices.\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation\n     * of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        params.ccSelf = (typeof params.ccSelf === \"boolean\" ? params.ccSelf : false);\n        return that.getEndpoint().sendMessage(params);\n    };\n\n    /**\n     * Create a new screen sharing call. Screenshares are inherently unidirectional video only. This may change\n     * in the future when Chrome adds the ability to obtain screen video and microphone audio at the same time. For\n     * now, if you also need audio, place a second audio only call.\n     *\n     * The endpoint who calls `connection.startScreenShare` will be the one whose screen is shared. If you'd like to\n     * implement this as a screenshare request in which the endpoint who starts the call is the watcher and\n     * not the sharer, it is recommened that you use `endpoint.sendMessage` to send a control message to the user\n     * whose screenshare is being requested so that user's app can call `connection.startScreenShare`.\n     *\n     * NOTE: At this time, screen sharing only works with Chrome, and Chrome requires a Chrome extension to\n     * access screen sharing features. Please see instructions at https://github.com/respoke/respoke-chrome-extension.\n     * Support for additional browsers will be added in the future.\n     *\n     *     connection.startScreenShare({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startScreenShare\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n     * and the remote party has received the video.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @returns {respoke.Call}\n     */\n    that.startScreenShare = function (params) {\n        client.verifyConnected();\n        params.connectionId = that.id;\n        return that.getEndpoint().startScreenShare(params);\n    };\n\n    /**\n     * Create a new Call for a voice and/or video call this particular connection, only. The Call cannot be answered\n     * by another connection of this Endpoint.\n     *\n     *     connection.startCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {RTCConstraints} [params.constraints]\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n     * video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n     * video attached to it.\n     * @returns {respoke.Call}\n     */\n    that.startCall = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().startCall(params);\n    };\n\n    /**\n     * Create a new audio-only call.\n     *\n     *     connection.startAudioCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startAudioCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @returns {respoke.Call}\n     */\n    that.startAudioCall = function (params) {\n        client.verifyConnected();\n        params.connectionId = that.id;\n        return that.getEndpoint().startAudioCall(params);\n    };\n\n    /**\n     * Create a new call with audio and video.\n     *\n     *     connection.startVideoCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startVideoCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has\n     * been hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @returns {respoke.Call}\n     */\n    that.startVideoCall = function (params) {\n        client.verifyConnected();\n        params.connectionId = that.id;\n        return that.getEndpoint().startVideoCall(params);\n    };\n\n    /**\n     * Create a new DirectConnection with this particular connection, only. The DirectConnection cannot be answered\n     * by another connection of this Endpoint.  This method creates a new Call as well, attaching this\n     * DirectConnection to it for the purposes of creating a peer-to-peer link for sending data such as messages to\n     * the other endpoint. Information sent through a DirectConnection is not handled by the cloud infrastructure.\n     *\n     *     connection.startDirectConnection({\n     *         onOpen: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.startDirectConnection\n     * @param {object} params\n     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess] - Success handler for this\n     * invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {respoke.DirectConnection.onStart} [params.onStart] - A callback for when setup of the direct\n     * connection begins. The direct connection will not be open yet.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - A callback for receiving notification of when\n     * the DirectConnection is open and ready to be used.\n     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n     * connection.\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - A callback for receiving notification of\n     * when the DirectConnection is closed and the two Endpoints are disconnected.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - A callback for receiving messages sent\n     * through the DirectConnection.\n     * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the\n     * request for a direct connection and setup begins.\n     * @returns {respoke.DirectConnection} The DirectConnection which can be used to send data and messages\n     * directly to the other endpoint.\n     */\n    that.startDirectConnection = function (params) {\n        var retVal;\n        var deferred;\n        params = params || {};\n\n        try {\n            client.verifyConnected();\n        } catch (err) {\n            deferred = respoke.Q.defer();\n            retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        params.connectionId = that.id;\n        return that.getEndpoint().startDirectConnection(params);\n    };\n\n    /**\n     * Get the Endpoint that this Connection belongs to.\n     * @memberof! respoke.Connection\n     * @method respoke.Connection.getEndpoint\n     * @returns {respoke.Endpoint}\n     */\n    that.getEndpoint = function () {\n        return client.getEndpoint({\n            id: that.endpointId,\n            skipPresence: true\n        });\n    };\n\n    return that;\n}; // End respoke.Connection\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/connection.js\n ** module id = 10\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar respoke = require('./respoke');\nvar log = respoke.log;\n\n/**\n * `respoke.Endpoint`s are users of a Respoke app.\n * An Endpoint can be a person in a browser or device, or an app using Respoke APIs from a server.\n * A Client can interact with endpoints through messages, audio or video calls, or direct connections.\n * An Endpoint may be authenticated from multiple devices to the same app (each of which is\n * represented by a Connection).\n *\n * ```\n * var jim = client.getEndpoint({ id: 'jim' });\n * ```\n *\n * @constructor\n * @class respoke.Endpoint\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.id\n * @param {string} params.instanceId\n * @param {respoke.client.resolvePresence} [params.resolvePresence] An optional function for resolving presence\n * for an endpoint.\n * @returns {respoke.Endpoint}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Endpoint\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name client\n     * @type {respoke.Client}\n     * @private\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name signalingChannel\n     * @type {respoke.SignalingChannel}\n     * @private\n     */\n    var signalingChannel = params.signalingChannel;\n    /**\n     * The number this endpoint's connections that are joined to groups. So if\n     * an endpoint has 3 connections in the same group, the\n     * `groupConnectionCount` for that endpoint would be 3.\n     *\n     * @memberof! respoke.DirectConnection\n     * @name groupConnectionCount\n     * @type {number}\n     */\n    that.groupConnectionCount = 0;\n\n    var addCall = params.addCall;\n\n    delete that.signalingChannel;\n    delete that.instanceId;\n    delete that.connectionId;\n    delete that.addCall;\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.Endpoint\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Endpoint';\n    /**\n     * A direct connection to this endpoint. This can be used to send direct messages.\n     * @memberof! respoke.Endpoint\n     * @name directConnection\n     * @type {respoke.DirectConnection}\n     */\n    that.directConnection = null;\n\n    /**\n     * Array of connections for this endpoint.\n     * @memberof! respoke.Endpoint\n     * @name connections\n     * @type {Array<respoke.Connection>}\n     */\n    that.connections = [];\n    client.listen('disconnect', function disconnectHandler() {\n        that.connections = [];\n    }, true);\n\n    var resolveEndpointPresence = params.resolveEndpointPresence;\n    delete that.resolveEndpointPresence;\n\n    /**\n     * Represents the presence status. Typically a string, but other types are supported.\n     * Defaults to `'unavailable'`.\n     *\n     * **Do not modify this directly** - it won't update presence with Respoke. Presence must be updated\n     * by the remote endpoint.\n     *\n     * @memberof! respoke.Endpoint\n     * @name presence\n     * @type {string|number|object|Array}\n     */\n    that.presence = 'unavailable';\n\n    /**\n     * Deprecated: use endpoint.presence instead.\n     *\n     * Return the presence.\n     * @memberof! respoke.Endpoint\n     * @deprecated\n     * @name presence\n     * @type {string|number|object|Array}\n     */\n    that.getPresence = function () {\n        return that.presence;\n    };\n\n    /**\n     * Internally set the presence on the object for this session upon receipt of a presence notification from\n     * the backend. Respoke developers shouldn't use this.\n     *\n     * While technically available on an Endpoint or Connection, this will not trigger\n     * any API changes. The changes will only be reflected locally.\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.setPresence\n     * @param {object} params\n     * @param {string|number|object|Array} [params.presence=available]\n     * @param {string} params.connectionId\n     * @fires respoke.Endpoint#presence\n     * @private\n     */\n    that.setPresence = function (params) {\n        var connection;\n        params = params || {};\n        params.presence = params.presence || 'available';\n        params.connectionId = params.connectionId || that.connectionId;\n\n        if (!params.connectionId) {\n            throw new Error(\"Can't set Endpoint presence without a connectionId.\");\n        }\n\n        connection = that.getConnection({connectionId: params.connectionId}) || client.getConnection({\n            connectionId: params.connectionId,\n            skipCreate: false,\n            endpointId: that.id\n        });\n\n        connection.presence = params.presence;\n        that.resolvePresence();\n\n        /**\n         * This event indicates that the presence for this endpoint has been updated.\n         * @event respoke.Endpoint#presence\n         * @type {respoke.Event}\n         * @property {string|number|object|Array} presence\n         * @property {string} name - the event name.\n         * @property {respoke.Endpoint} target\n         */\n        that.fire('presence', {\n            presence: that.presence\n        });\n    };\n\n    /**\n     * Send a message to the endpoint through the infrastructure.\n     *\n     * ```\n     * endpoint.sendMessage({\n     *     message: \"wassuuuuup\"\n     * });\n     * ```\n     *\n     * **Using callbacks** will disable promises.\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.sendMessage\n     * @param {object} params\n     * @param {string} params.message\n     * @param {string} [params.connectionId]\n     * @param {boolean} [params.ccSelf=true] Copy this client's own endpoint on this message so that they arrive\n     * at other devices it might be logged into elsewhere.\n     * @param {boolean} [params.push=false] Whether or not to consider the message for push notifications to mobile\n     * devices.\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of this\n     * method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this method\n     * only.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n        params.ccSelf = (typeof params.ccSelf === \"boolean\" ? params.ccSelf : true);\n\n        promise = signalingChannel.sendMessage({\n            ccSelf: params.ccSelf,\n            connectionId: params.connectionId,\n            message: params.message,\n            push: !!params.push,\n            recipient: that\n        });\n\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };\n\n    /**\n     * Create a new audio-only call.\n     *\n     *     endpoint.startAudioCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startAudioCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {*} [params.metadata] - Metadata to be attached to the audio call, accessible by the callee.\n     * @returns {respoke.Call}\n     */\n    that.startAudioCall = function (params) {\n        params = params || {};\n\n        params.constraints = respoke.convertConstraints(params.constraints, [{\n            video: false,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        }]);\n\n        return that.startCall(params);\n    };\n\n    /**\n     * Create a new call with audio and video.\n     *\n     *     endpoint.startVideoCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startVideoCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {*} [params.metadata] - Metadata to be attached to the video call, accessible by the callee.\n     * @returns {respoke.Call}\n     */\n    that.startVideoCall = function (params) {\n        params = params || {};\n\n        params.constraints = respoke.convertConstraints(params.constraints, [{\n            video: true,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        }]);\n\n        return that.startCall(params);\n    };\n\n    /**\n     * The endpoint who calls `endpoint.startScreenShare` will be the one whose screen is shared. If you'd like to\n     * implement this as a screenshare request in which the endpoint who starts the call is the watcher and\n     * not the sharer, it is recommended that you use `endpoint.sendMessage` to send a control message to the user\n     * whose screenshare is being requested so that user's app can call `endpoint.startScreenShare`.\n     *\n     * By default, the call will be one-way screen share only, with the recipient sending nothing. To turn it into\n     * a bidirectional call with the recipient sending video and both parties sending audio, set `params.sendOnly`\n     * to false.\n     *\n     * NOTE: At this time, screen sharing only works with Chrome and Firefox, and both require browser extensions to\n     * access screen sharing features. Please see instructions at https://github.com/respoke/respoke-chrome-extension\n     * and https://github.com/respoke/respoke-firefox-screen-sharing-extension.\n     *\n     *     endpoint.startScreenShare({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startScreenShare\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n     * and the remote party has received the video.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {Array<RTCConstraints>} [params.constraints] - Additional media to add to the call.\n     * @param {RTCConstraints} [params.screenConstraints] - Overrides for the screen media.\n     * @param {boolean} [params.sendOnly=true] - Whether the call should be unidirectional.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {string} [params.source] - Pass in what type of mediaSource you want. If omitted, you'll have access\n     * to both the screen and windows. In firefox, you'll have access to the screen only.\n     * @param {*} [params.metadata] - Metadata to be attached to the screenShare, accessible by the callee.\n     * @returns {respoke.Call}\n     */\n    that.startScreenShare = function (params) {\n        params = params || {};\n        var hasAudio;\n        var addAudio;\n        params.target = 'screenshare';\n\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        // true and undefined -> true\n        // receiveOnly will be set in call.js by respoke.sdpHasSendOnly\n        params.sendOnly = (params.caller && (params.sendOnly || (params.sendOnly === undefined)));\n        addAudio = (!params.sendOnly && (!params.screenConstraints ||\n            (params.screenConstraints && params.screenConstraints.audio)));\n\n        if (params.caller) {\n            params.constraints = respoke.convertConstraints(params.constraints);\n            params.constraints.push(respoke.getScreenShareConstraints({\n                constraints: params.screenConstraints\n            }));\n            delete params.screenConstraints;\n\n            params.constraints.forEach(function (con) {\n                if (con.audio) {\n                    hasAudio = true;\n                }\n            });\n\n            /* If they didn't override screensharing constraints and no constraints so far have included audio,\n             * add audio to the call. If they overrode the default screensharing constraints, we'll assume they\n             * know what they are doing and didn't want audio.\n             */\n            if (addAudio && !hasAudio) {\n                params.constraints.push({\n                    audio: true,\n                    video: false\n                });\n            }\n        }\n\n        return that.startCall(params);\n    };\n\n    /**\n     * Create a new call.\n     *\n     *     endpoint.startCall({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startCall\n     * @param {object} params\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for receiving an HTML5 Video\n     * element with the remote\n     * audio and/or video attached.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {Array<RTCConstraints>} [params.constraints]\n     * @param {boolean} [params.receiveOnly] - whether or not we accept media\n     * @param {boolean} [params.sendOnly] - whether or not we send media\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint, if it is not desired to call\n     * all connections belonging to this endpoint.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an optional html video element to have local\n     * video attached to it.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an optional html video element to have remote\n     * video attached to it.\n     * @param {*} [params.metadata] - Metadata to be attached to the call, accessible by the callee.\n     * @returns {respoke.Call}\n     */\n    that.startCall = function (params) {\n        var call;\n        params = params || {};\n\n        params.constraints = respoke.convertConstraints(params.constraints, [{\n            video: true,\n            audio: true,\n            mandatory: {},\n            optional: []\n        }]);\n\n        // If they are requesting a screen share by constraints without having called startScreenShare\n        if (params.target !== 'screenshare' && params.constraints[0] &&\n                respoke.constraintsHasScreenShare(params.constraints[0])) {\n            return that.startScreenShare(params);\n        }\n\n        params.target = params.target || \"call\";\n\n        log.debug('Endpoint.call', params);\n        client.verifyConnected();\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        if (!that.id) {\n            log.error(\"Can't start a call without endpoint ID!\");\n            return;\n        }\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = that;\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = params.target;\n            signalParams.recipient = that;\n            signalParams.metadata = params.metadata;\n\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'answer';\n            signalParams.target = params.target;\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = params.target;\n            signalParams.connectionId = signalParams.call.connectionId;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.recipient = that;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = params.target;\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendModify(signalParams).done();\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = params.target;\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            return signalingChannel.sendCandidate(signalParams);\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = params.target;\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendHangup(signalParams).done();\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            signalingChannel.sendReport(signalParams).done();\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        return call;\n    };\n\n    /**\n     * Create a new DirectConnection.  This method creates a new Call as well, attaching this DirectConnection to\n     * it for the purposes of creating a peer-to-peer link for sending data such as messages to the other endpoint.\n     * Information sent through a DirectConnection is not handled by the cloud infrastructure.  If there is already\n     * a direct connection open, this method will resolve the promise with that direct connection instead of\n     * attempting to create a new one.\n     *\n     *     endpoint.startDirectConnection({\n     *         onOpen: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.startDirectConnection\n     * @param {object} params\n     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess] - Success handler for this\n     * invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @param {respoke.DirectConnection.onStart} [params.onStart] - A callback for when setup of the direct\n     * connection begins. The direct connection will not be open yet.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - A callback for receiving notification of when\n     * the DirectConnection is open and ready to be used.\n     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n     * connection.\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - A callback for receiving notification of\n     * when the DirectConnection is closed and the two Endpoints are disconnected.\n     * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the\n     * request for a direct connection and setup begins.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - A callback for receiving messages sent\n     * through the DirectConnection.\n     * @param {string} [params.connectionId] - An optional connection ID to use for this connection. This allows\n     * the connection to be made to a specific instance of an endpoint in the case that the same endpoint is logged\n     * in from multiple locations.\n     * @returns {Promise<respoke.DirectConnection>} The DirectConnection which can be used to send data and messages\n     * directly to the other endpoint.\n     */\n    that.startDirectConnection = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        var call;\n\n        try {\n            client.verifyConnected();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        if (that.directConnection || params.create === false) {\n            deferred.resolve(that.directConnection);\n            return retVal;\n        }\n\n        if (typeof params.caller !== 'boolean') {\n            params.caller = true;\n        }\n\n        if (!that.id) {\n            deferred.reject(new Error(\"Can't start a direct connection without endpoint ID!\"));\n            return retVal;\n        }\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = that;\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalParams.metadata = params.metadata;\n\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                signalParams.call.hangup();\n            });\n        };\n        params.signalAnswer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalParams.signalType = 'answer';\n            signalingChannel.sendSDP(signalParams).then(onSuccess, onError).done(null, function errorHandler(err) {\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            return signalingChannel.sendCandidate(signalParams);\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendHangup(signalParams).done();\n        };\n        params.signalReport = function (signalParams) {\n            signalParams.report.target = 'directConnection';\n            log.debug(\"Not sending report\");\n            log.debug(signalParams.report);\n        };\n        params.needDirectConnection = true;\n        // Don't include audio in the offer SDP\n        params.offerOptions = {\n            mandatory: {\n                OfferToReceiveAudio: false\n            }\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        call.listen('direct-connection', function directConnectionHandler(evt) {\n            that.directConnection = evt.directConnection;\n            if (params.caller !== true) {\n                if (!client.hasListeners('direct-connection') &&\n                        !client.hasListeners('direct-connection') &&\n                        !call.hasListeners('direct-connection')) {\n                    that.directConnection.reject();\n                    deferred.reject(new Error(\"Got an incoming direct connection with no handlers to accept it!\"));\n                    return;\n                }\n\n                deferred.resolve(that.directConnection);\n                that.directConnection.listen('close', function closeHandler(evt) {\n                    that.directConnection = undefined;\n                }, true);\n            }\n        }, true);\n\n        return retVal;\n    };\n\n    /**\n     * Default presence list.\n     * @private\n     */\n    var PRESENCE_CONSTANTS = ['chat', 'available', 'away', 'dnd', 'xa', 'unavailable'];\n\n    /**\n     * Find the presence out of all known connections with the highest priority (most availability)\n     * and set it as the endpoint's resolved presence.\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.resolvePresence\n     * @private\n     */\n    that.resolvePresence = function () {\n\n        var presenceList = that.connections.map(function (connection) {\n            return connection.presence;\n        });\n\n        if (resolveEndpointPresence !== undefined) {\n            that.presence = resolveEndpointPresence(presenceList);\n        } else {\n            var idList;\n\n            /*\n             * Sort the connections array by the priority of the value of the presence of that\n             * connectionId. This will cause the first element in the list to be the id of the\n             * session with the highest priority presence so we can access it by the 0 index.\n             * TODO: If we don't really care about the sorting and only about the highest priority\n             * we could use Array.prototype.every to improve this algorithm.\n             */\n            idList = that.connections.sort(function sorter(a, b) {\n                var indexA = PRESENCE_CONSTANTS.indexOf(a.presence);\n                var indexB = PRESENCE_CONSTANTS.indexOf(b.presence);\n                // Move it to the end of the list if it isn't one of our accepted presence values\n                indexA = indexA === -1 ? 1000 : indexA;\n                indexB = indexB === -1 ? 1000 : indexB;\n                return indexA < indexB ? -1 : (indexB < indexA ? 1 : 0);\n            });\n\n            if (idList[0]) {\n                that.presence = idList[0].presence;\n            } else {\n                that.presence = 'unavailable';\n            }\n        }\n    };\n\n    /**\n     * Get the Connection with the specified id. The connection ID is optional if only one connection exists.\n     *\n     *     var connection = endpoint.getConnection({\n     *         connectionId: \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX\"\n     *     });\n     *\n     * @memberof! respoke.Endpoint\n     * @method respoke.Endpoint.getConnection\n     * @private\n     * @param {object} params\n     * @param {string} [params.connectionId]\n     * @return {respoke.Connection}\n     */\n    that.getConnection = function (params) {\n        var connection = null;\n        params = params || {};\n        if (that.connections.length === 1 &&\n                (!params.connectionId || that.connections[0] === params.connectionId)) {\n            return that.connections[0];\n        }\n\n        if (!params || !params.connectionId) {\n            throw new Error(\"Can't find a connection without the connectionId.\");\n        }\n\n        that.connections.every(function eachConnection(conn) {\n            if (conn.id === params.connectionId) {\n                connection = conn;\n                return false;\n            }\n            return true;\n        });\n\n        return connection;\n    };\n\n    /**\n     * Called to indicate that a connection for this endpoint has joined a\n     * group.\n     *\n     * @private\n     * @returns {number} Number of groups this endpoint is a member of.\n     */\n    that.joinedGroup = function () {\n        ++that.groupConnectionCount;\n    };\n\n    /**\n     * Called to indicate that a connection for this endpoint has left a\n     * group.\n     *\n     * @private\n     * @returns {number} Number of groups this endpoint is a member of.\n     */\n    that.leftGroup = function () {\n        --that.groupConnectionCount;\n    };\n\n    return that;\n}; // End respoke.Endpoint\n/**\n * Handle messages sent to the logged-in user from this one Endpoint.  This callback is called every time\n * respoke.Endpoint#message fires.\n * @callback respoke.Endpoint.onMessage\n * @param {respoke.Event} evt\n * @param {respoke.TextMessage} evt.message - the message\n * @param {respoke.Endpoint} evt.target\n * @param {string} evt.name - the event name\n */\n/**\n * Handle presence notifications from this one Endpoint.  This callback is called every time\n * respoke.Endpoint#message fires.\n * @callback respoke.Endpoint.onPresence\n * @param {respoke.Event} evt\n * @param {string|number|object|Array} evt.presence - the Endpoint's presence\n * @param {respoke.Endpoint} evt.target\n * @param {string} evt.name - the event name\n */\n /**\n * Handle resolving presence for this endpoint\n * @callback respoke.Client.resolveEndpointPresence\n * @param {Array<object>} connectionPresence\n * @returns {object|string|number}\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/endpoint.js\n ** module id = 11\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\n/**\n * A text message and the information needed to route it.\n * @class respoke.TextMessage\n * @constructor\n * @param {object} params\n * @param {string} [params.endpointId] - If sending, endpoint ID of the thing we're sending a message to.\n * @param {string} [params.cSelf] - Copy this client's own endpoint on this message so that they arrive\n * at other devices it might be logged into elsewhere.\n * @param {string} [params.connectionId] - If sending, connection ID of the thing we're sending a message to.\n * @param {string} [params.message] - If sending, a message to send\n * @param {object} [params.rawMessage] - If receiving, the parsed JSON we got from the server\n * @private\n * @returns {respoke.TextMessage}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = {};\n\n    /**\n     * Parse rawMessage and set attributes required for message delivery.\n     * @memberof! respoke.TextMessage\n     * @method respoke.TextMessage.parse\n     * @private\n     */\n    function parse() {\n        if (params.rawMessage) {\n            try {\n                that.endpointId = params.rawMessage.header.from;\n                that.originalRecipient = params.rawMessage.header.toOriginal;\n                that.connectionId = params.rawMessage.header.fromConnection;\n                that.timestamp = params.rawMessage.header.timestamp;\n            } catch (e) {\n                throw new Error(e);\n            }\n            that.message = params.rawMessage.message || params.rawMessage.body;\n            if (params.rawMessage.header.channel) {\n                that.recipient = params.rawMessage.header.channel;\n            }\n        } else {\n            try {\n                that.to = params.endpointId;\n                that.ccSelf = params.ccSelf;\n                that.toConnection = params.connectionId;\n                that.requestConnectionReply = (params.requestConnectionReply === true);\n                that.push = (params.push === true);\n            } catch (e) {\n                throw new Error(e);\n            }\n            that.message = params.message;\n        }\n    }\n\n    parse();\n    return that;\n}; // End respoke.TextMessage\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/textMessage.js\n ** module id = 12\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\n/**\n * A signaling message and the information needed to route it.\n * @class respoke.SignalingMessage\n * @constructor\n * @param {object} params\n * @param {string} [params.fromEndpoint] - If sending, the endpoint ID of the recipient\n * @param {string} [params.fromConnection] - If sending, the connection ID of the recipient\n * @param {string} [params.connectionId] - The connectionId of the endpoint whose answer signal has been accepted.\n * @param {string} [params.signal] - If sending, a message to send\n * @param {respoke.Endpoint} [params.recipient]\n * @param {string} [params.signalType]\n * @param {string} [params.sessionId] - A globally unique ID to identify this call.\n * @param {string} [params.target] - Either 'call' or 'directConnection', TODO remove the need for this.\n * @param {string} [params.callerId] - Human readable caller ID. Not implemented.\n * @param {RTCSessionDescription} [params.sdp]\n * @param {Array<RTCIceCandidate>} [params.iceCandidates]\n * @param {object} [params.offering] - Object describing the media we're offering to send the remote party in a more\n * usable way than SDP. Not implemented.\n * @param {object} [params.requesting] - Object describing the media we're requesting from the remote party in a more\n * usable way than SDP. Not implemented.\n * @param {string} [params.reason] - Human readable reason for hanging up.\n * @param {string} [params.error] - String indicating that a previous signal was malformed or received in the wrong\n * state. Not implemented.\n * @param {string} [params.status] - \"Ringing\". Not implemented.\n * @param {object} [params.rawMessage] - If receiving, the parsed JSON we got from the server\n * @private\n * @returns {respoke.SignalingMessage}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = {};\n\n    /**\n     * Attributes without which we cannot build a signaling message.\n     * @memberof! respoke.SignalingMessage\n     * @name required\n     * @private\n     */\n    var required = ['signalType', 'sessionId', 'target', 'signalId'];\n\n    /**\n     * Attributes which we will copy onto the signal if defined.\n     * @memberof! respoke.SignalingMessage\n     * @name required\n     * @private\n     */\n    var optional = [\n        'sessionDescription', 'iceCandidates', 'offering', 'callerId', 'requesting',\n        'reason', 'error', 'status', 'connectionId', 'finalCandidates', 'metadata',\n        'action'\n    ];\n\n    /**\n     * Parse rawMessage and set attributes required for message delivery.\n     * @memberof! respoke.SignalingMessage\n     * @method respoke.SignalingMessage.parse\n     * @private\n     */\n    function parse() {\n        if (params.rawMessage) {\n            try {\n                that = JSON.parse(params.rawMessage.body); // Incoming message\n            } catch (e) {\n                that = params.rawMessage.body;\n            }\n            that.fromType = params.rawMessage.header.fromType;\n            that.fromEndpoint = params.rawMessage.header.from;\n            that.fromConnection = params.rawMessage.header.fromConnection;\n            that.timestamp = params.rawMessage.header.timestamp;\n\n            if (!that.target) {\n                that.target = 'call';\n            }\n        } else {\n            required.forEach(function eachAttr(attr) {\n                if (!params.hasOwnProperty(attr)) {\n                    throw new Error(\"Can't build a signaling without \" + attr);\n                }\n                that[attr] = params[attr];\n            });\n\n            optional.forEach(function eachAttr(attr) {\n                if (params.hasOwnProperty(attr)) {\n                    that[attr] = params[attr];\n                }\n            });\n        }\n    }\n\n    parse();\n\n    that.version = '1.0';\n\n    return that;\n}; // End respoke.SignalingMessage\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/signalingMessage.js\n ** module id = 13\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar respoke = require('./respoke');\n\n/**\n * A `respoke.Group` represents a collection of endpoints.\n *\n * There are methods to communicate with the endpoints at the group level and track\n * their presence in the group.\n *\n * @class respoke.Group\n * @augments respoke.EventEmitter\n * @constructor\n * @param {object} params\n * @param {string} params.instanceId\n * @param {respoke.Group.onJoin} params.onJoin - A callback to receive notifications every time a new\n * endpoint has joined the group. This callback does not get called when the client joins the group.\n * @param {respoke.Group.onMessage} params.onMessage - A callback to receive messages sent to the group from\n * remote endpoints.\n * @param {respoke.Group.onLeave} params.onLeave - A callback to receive notifications every time a new\n * endpoint has left the group. This callback does not get called when the client leaves the group.\n * @returns {respoke.Group}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n\n    var that = respoke.EventEmitter(params);\n    /**\n     * @memberof! respoke.Group\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var client = respoke.getClient(instanceId);\n\n    if (!that.id) {\n        throw new Error(\"Can't create a group without an ID.\");\n    }\n\n    /**\n     * Indicates whether there have been group membership changes since the last time we performed\n     * a network request to list group members.\n     * @memberof! respoke.Group\n     * @name cacheIsValid\n     * @private\n     * @type {boolean}\n     */\n    var cacheIsValid = false;\n\n    /**\n     * Internal reference to the api signaling channel.\n     * @memberof! respoke.Group\n     * @name signalingChannel\n     * @type respoke.SignalingChannel\n     * @private\n     */\n    var signalingChannel = params.signalingChannel;\n    delete params.signalingChannel;\n\n    /**\n     * The connections to members of this group.\n     * @memberof! respoke.Group\n     * @name endpoints\n     * @type {array<respoke.Connection>}\n     */\n    that.connections = [];\n    /**\n     * A name to identify the type of this object.\n     * @memberof! respoke.Group\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Group';\n    that.listen('join', params.onJoin);\n    /**\n     * Indicates that a message has been sent to this group.\n     * @event respoke.Group#message\n     * @type {respoke.Event}\n     * @property {respoke.TextMessage} message\n     * @property {string} name - The event name.\n     * @property {respoke.Group} target\n     */\n    that.listen('message', params.onMessage);\n    that.listen('leave', params.onLeave);\n\n    /**\n     * Clear out the connections within this group. Called when we're no longer\n     * connected to the group.\n     * @private\n     */\n    function clearConnections() {\n        that.connections.forEach(function (connection) {\n            connection.getEndpoint().leftGroup();\n        });\n        that.connections = [];\n    }\n\n    client.listen('disconnect', function disconnectHandler() {\n        cacheIsValid = false;\n        clearConnections();\n    }, true);\n\n    delete that.instanceId;\n    delete that.onMessage;\n    delete that.onPresence;\n    delete that.onJoin;\n    delete that.onLeave;\n\n    /**\n     * Join this group.\n     *\n     *     group.join().done(function () {\n     *         group.sendMessage({\n     *             message: \"Hey, ppl! I'm here!\"\n     *         });\n     *     }, function (err) {\n     *         // Couldn't join the group, possibly permissions error\n     *     });\n     *\n     * **Using callbacks** will disable promises.\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.join\n     * @return {Promise|undefined}\n     * @param {object} params\n     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @fires respoke.Client#join\n     */\n    that.join = function () {\n        var params = {\n            id: that.id\n        };\n        var promise;\n        var deferred;\n        var retVal;\n        cacheIsValid = false;\n\n        try {\n            validateConnection();\n        } catch (err) {\n            deferred = Q.defer();\n            retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        promise = client.join(params);\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };\n\n    /**\n     * Leave this group. If this method is called multiple times synchronously, it will batch requests and\n     * only make one API call to Respoke.\n     *\n     *     group.leave({\n     *         onSuccess: function () {\n     *             // good riddance\n     *         },\n     *         onError: function (err) {\n     *             // Couldn't leave the group, possibly a permissions error\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.leave\n     * @param {object} params\n     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @return {Promise|undefined}\n     * @fires respoke.Client#leave\n     */\n    that.leave = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        signalingChannel.leaveGroup({\n            groupList: [that.id]\n        }).done(function successHandler() {\n            clearConnections();\n            deferred.resolve();\n            cacheIsValid = false;\n\n            /**\n             * This event is fired when the client leaves a group.\n             * @event respoke.Client#leave\n             * @type {respoke.Event}\n             * @property {respoke.Group} group\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             * @private\n             */\n            client.fire('leave', {\n                group: that\n            });\n        }, function errorHandler(err) {\n            deferred.reject();\n        });\n        return retVal;\n    };\n\n    /**\n     * Remove a Connection from a Group. This does not change the status of the remote Endpoint, it only changes the\n     * internal representation of the Group membership. This method should only be used internally.\n     * @private\n     * @memberof! respoke.Group\n     * @method respoke.Group.removeMember\n     * @param {object} params\n     * @param {string} [params.connectionId] - Endpoint's connection id\n     * @fires respoke.Group#leave\n     */\n    that.removeMember = function (params) {\n        params = params || {};\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            return;\n        }\n\n        if (!params.connectionId) {\n            throw new Error(\"Can't remove a member to the group without it's Connection id.\");\n        }\n\n        cacheIsValid = false;\n\n        that.connections.every(function eachConnection(conn, index) {\n            if (conn.id === params.connectionId) {\n                that.connections.splice(index, 1);\n                conn.getEndpoint().leftGroup();\n\n                /**\n                 * This event is fired when a member leaves a group the client is a member of.\n                 * @event respoke.Group#leave\n                 * @type {respoke.Event}\n                 * @property {respoke.Connection} connection - The connection that left the group.\n                 * @property {string} name - The event name.\n                 * @property {respoke.Group} target\n                 */\n                that.fire('leave', {\n                    connection: conn\n                });\n                return false;\n            }\n            return true;\n        });\n    };\n\n    /**\n     * Return true if the logged-in user is a member of this group and false if not.\n     *\n     *     if (group.isJoined()) {\n     *         // I'm a member!\n     *     } else {\n     *         // Maybe join here\n     *     }\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.isJoined\n     * @returns {boolean}\n     */\n    that.isJoined = function () {\n        // connections array contains some connections and ours is among them.\n        return (that.connections.length > 0 && !that.connections.every(function (conn) {\n            return conn.id !== client.connectionId;\n        }));\n    };\n\n    /**\n     * Add a Connection to a group. This does not change the status of the remote Endpoint, it only changes the\n     * internal representation of the Group membership. This method should only be used internally.\n     * @memberof! respoke.Group\n     * @private\n     * @method respoke.Group.addMember\n     * @param {object} params\n     * @param {respoke.Connection} params.connection\n     * @fires respoke.Group#join\n     */\n    that.addMember = function (params) {\n        params = params || {};\n        var absent;\n\n        validateConnection();\n\n        if (!params.connection) {\n            throw new Error(\"Can't add a member to the group without it's Connection object.\");\n        }\n\n        cacheIsValid = false;\n\n        absent = that.connections.every(function eachConnection(conn) {\n            return (conn.id !== params.connection.id);\n        });\n\n        if (absent) {\n            that.connections.push(params.connection);\n            params.connection.getEndpoint().joinedGroup();\n            if (params.skipEvent) {\n                return;\n            }\n\n            /**\n             * This event is fired when a member joins a Group that the currently logged-in endpoint is a member\n             * of.\n             * @event respoke.Group#join\n             * @type {respoke.Event}\n             * @property {respoke.Connection} connection - The connection that joined the group.\n             * @property {string} name - The event name.\n             * @property {respoke.Group} target\n             */\n            that.fire('join', {\n                connection: params.connection\n            });\n        }\n    };\n\n    /**\n     * Validate that the client is connected to the Respoke infrastructure.\n     * @memberof! respoke.Group\n     * @method respoke.Group.validateConnection\n     * @private\n     */\n    function validateConnection() {\n        if (!signalingChannel || !signalingChannel.isConnected()) {\n            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n        }\n    }\n\n    /**\n     * Validate that the client is a member of this group.\n     * @memberof! respoke.Group\n     * @method respoke.Group.validateMembership\n     * @private\n     */\n    function validateMembership() {\n        if (!that.isJoined()) {\n            throw new Error(\"Not a member of this group anymore.\");\n        }\n    }\n\n    /**\n     *\n     * Send a message to all of the endpoints in the group.\n     *\n     *      var group = client.getGroup({ id: 'js-enthusiasts'});\n     *\n     *      group.sendMessage({\n     *          message: \"Cat on keyboard\",\n     *          onSuccess: function (evt) {\n     *              console.log('Message was sent');\n     *          }\n     *      });\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.sendMessage\n     * @param {object} params\n     * @param {string} params.message - The message.\n     * @param {boolean} [params.push=false] - Whether or not the message should be considered for push notifications to\n     * mobile devices.\n     * @param {function} params.onSuccess - Success handler indicating that the message was delivered.\n     * @param {function} params.onError - Error handler indicating that the message was not delivered.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        params = params || {};\n        params.id = that.id;\n        var promise;\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            promise = Q.reject(err);\n        }\n\n        return respoke.handlePromise(promise ? promise : signalingChannel.publish(params),\n                params.onSuccess, params.onError);\n    };\n\n    /**\n     * Get group members\n     *\n     * Get an array containing all connections subscribed to the group. Accepts onSuccess or onError parameters,\n     * or it returns a promise that you can observe. An endpoint may have more than one connection subscribed to\n\t * a group, so if you're interested in unique endpoints, you may want to filter the connections by endpointId.\n     *\n     *     group.getMembers({\n     *         onSuccess: function (connections) {\n     *             connections.forEach(function (connection) {\n     *                 console.log(connection.endpointId);\n     *             });\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.getMembers\n     * @param {object} params\n     * @param {respoke.Client.joinHandler} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Success handler for this invocation of this method only.\n     * @returns {Promise<Array>} A promise to an array of Connections.\n     */\n    that.getMembers = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        if (that.connections.length > 0 && cacheIsValid) {\n            deferred.resolve(that.connections);\n            return retVal;\n        }\n\n        signalingChannel.getGroupMembers({\n            id: that.id\n        }).done(function successHandler(list) {\n            var endpointList = [];\n            list.forEach(function eachMember(params) {\n                var connection = client.getConnection({\n                    endpointId: params.endpointId,\n                    connectionId: params.connectionId,\n                    skipCreate: true\n                });\n\n                if (!connection) {\n                    // Create the connection\n                    connection = client.getConnection({\n                        endpointId: params.endpointId,\n                        connectionId: params.connectionId\n                    });\n                }\n\n                if (endpointList.indexOf(params.endpointId) === -1) {\n                    endpointList.push(params.endpointId);\n                }\n                that.addMember({\n                    connection: connection,\n                    skipEvent: true\n                });\n            });\n\n            cacheIsValid = true;\n\n            deferred.resolve(that.connections);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return retVal;\n    };\n\n    /**\n     * Experimental. Create a new conference call. The ID will be the group name. Only members of this group will\n     * be permitted to participate in the conference call.\n     *\n     *     group.joinConference({\n     *         onConnect: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.Group\n     * @method respoke.Group.joinConference\n     * @private\n     * @param {object} params\n     * @param {string|boolean} params.audio - Whether participant should send and receive audio. Boolean `true`\n     * indicates send and receive. Boolean `false` indicates neither send nor receive. Strings `send` and `receive`\n     * indicate send only and receive only respectively.\n     * @param {string|boolean} params.video - Whether participant should send and receive audio. Boolean `true`\n     * indicates send and receive. Boolean `false` indicates neither send nor receive. Strings `send` and `receive`\n     * indicate send only and receive only respectively.\n     * @param {boolean} params.mixAudio - Whether Respoke should mix all the audio streams together to save bandwidth\n     * for this one participant.\n     * @arg {respoke.Conference.onJoin} [params.onJoin] - Callback for when a participant joins the conference.\n     * @arg {respoke.Conference.onLeave} [params.onLeave] - Callback for when a participant leaves the conference.\n     * @arg {respoke.Conference.onMessage} [params.onMessage] - Callback for when a message is sent to the conference.\n     * @param {respoke.Conference.onMute} [params.onMute] - Callback for when local or remote media is muted or unmuted.\n     * @arg {respoke.Conference.onTopic} [params.onTopic] - Callback for the conference topic changes.\n     * @arg {respoke.Conference.onPresenter} [params.onPresenter] - Callback for when the presenter changes.\n     * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n     * media renegotiation.\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for when the screenshare is connected\n     * and the remote party has received the video.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for being notified when the call has been\n     * hung up.\n     * @param {respoke.Call.onAllow} [params.onAllow] - When setting up a call, receive notification that the\n     * browser has granted access to media.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for receiving statistical\n     * information.\n     * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n     * relay servers. If it cannot flow through relay servers, the call will fail.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @returns {respoke.Conference}\n     */\n    that.joinConference = function (params) {\n        var conference = null;\n        params = params || {};\n        params.id = that.id;\n\n        conference = client.joinConference(params);\n        return conference;\n    };\n\n    return that;\n}; // End respoke.Group\n/**\n * Receive notification that an endpoint has joined this group. This callback is called everytime\n * respoke.Group#join is fired.\n * @callback respoke.Group.onJoin\n * @param {respoke.Event} evt\n * @param {respoke.Connection} evt.connection\n * @param {string} evt.name - the event name.\n * @param {respoke.Group} evt.target\n */\n/**\n * Receive notification that an endpoint has left this group. This callback is called everytime\n * respoke.Group#leave is fired.\n * @callback respoke.Group.onLeave\n * @param {respoke.Event} evt\n * @param {respoke.Connection} evt.connection\n * @param {string} evt.name - the event name.\n * @param {respoke.Group} evt.target\n */\n/**\n * Receive notification that a message has been received to a group. This callback is called every time\n * respoke.Group#message is fired.\n * @callback respoke.Group.onMessage\n * @param {respoke.Event} evt\n * @param {respoke.TextMessage} evt.message\n * @param {string} evt.name - the event name.\n * @param {respoke.Group} evt.target\n */\n/**\n * Get a list of the Connections which are members of this Group.\n * @callback respoke.Group.connectionsHandler\n * @param {Array<respoke.Connection>} connections\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/group.js\n ** module id = 14\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n'use strict';\n\nvar Q = require('q');\nvar respoke = require('./respoke');\nvar template = require('url-template');\nvar log = respoke.log;\n\nvar sdkHeaderValue = 'Respoke.js/' + respoke.version;\n\nvar billingSuspensionErrorMessage = \"Can't perform this action: Not Authorized. Your account is suspended due to a \" +\n    \"billing issue. Please visit the Respoke Developer Portal (https://www.respoke.io) or contact customer support \" +\n    \"(support@respoke.io) to address this issue.\";\n\nvar suspensionErrorMessage = \"Canot perform this action: Not Authorized. Your account is suspended. Please visit \" +\n    \"the Respoke Developer Portal (https://www.respoke.io) or contact customer support (support@respoke.io) to \" +\n    \"address this issue.\";\n\n/**\n * Returns a timestamp, measured in milliseconds.\n *\n * This method will use high resolution time, if available. Otherwise it falls back to just\n * using the wall clock.\n *\n * @return {number} Number of milliseconds that have passed since some point in the past.\n * @private\n */\nvar now;\nif (window.performance && window.performance.now) {\n    now = window.performance.now.bind(window.performance);\n} else if (Date.now) {\n    now = Date.now.bind(Date);\n} else {\n    now = function () {\n        return new Date().getTime();\n    };\n}\n\n/**\n * Container for holding requests that are currently waiting on responses.\n * @returns {PendingRequests}\n * @private\n * @constructor\n */\nvar PendingRequests = function () {\n    /**\n     * Pending requests.\n     * @private\n     * @type {Array}\n     */\n    var contents = [];\n    /**\n     * Counter to provide the next id.\n     * @private\n     * @type {number}\n     */\n    var counter = 0;\n    var that = {};\n\n    /**\n     * Add a new pending request.\n     *\n     * @memberof PendingRequests\n     * @param obj\n     * @returns {*} The key to use for the `remove` method.\n     */\n    that.add = function (obj) {\n        contents[counter] = obj;\n        counter++;\n        return counter;\n    };\n\n    /**\n     * Remove a pending request.\n     *\n     * @param {*} key Key returned from `add` method.\n     */\n    that.remove = function (key) {\n        delete contents[key];\n    };\n\n    /**\n     * Disposes of any currently pending requests, synchronously invoking the provided function on\n     * each.\n     *\n     * @param {function} [fn] Callback for pending requests.\n     */\n    that.reset = function (fn) {\n        if (fn) {\n            contents.forEach(fn);\n        }\n        contents = [];\n    };\n\n    return that;\n};\n\n/**\n * The purpose of this class is to make a method call for each API call\n * to the backend REST interface.  This class takes care of App authentication, websocket connection,\n * Endpoint authentication, and all App interactions thereafter.  Almost all methods return a Promise.\n * @class respoke.SignalingChannel\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId - client id\n * @private\n * @returns {respoke.SignalingChannel}\n */\nmodule.exports = function (params) {\n    params = params || {};\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name className\n     * @type {string}\n     * @private\n     */\n    that.className = 'respoke.SignalingChannel';\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name client\n     * @private\n     * @type {respoke.Client}\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name socket\n     * @private\n     * @type {Socket.io.Socket}\n     */\n    that.socket = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name clientSettings\n     * @private\n     * @type {object}\n     */\n    var clientSettings = params.clientSettings;\n    delete that.clientSettings;\n    clientSettings.baseURL = clientSettings.baseURL || 'https://api.respoke.io';\n    /**\n     * A map to avoid duplicate endpoint presence registrations.\n     * @memberof! respoke.SignalingChannel\n     * @name presenceRegistered\n     * @private\n     * @type {object}\n     */\n    var presenceRegistered = {};\n    /**\n     * A reference to the private function Client.actuallyConnect that gets set in SignalingChannel.open() so we\n     * don't have to make it public.\n     * @memberof! respoke.SignalingChannel\n     * @name actuallyConnect\n     * @private\n     * @type {function}\n     */\n    var actuallyConnect = null;\n    /**\n     * Set of promises for any pending requests on the WebSocket.\n     * @private\n     * @type {PendingRequests}\n     */\n    var pendingRequests = PendingRequests();\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name reconnectTimeout\n     * @private\n     * @type {number}\n     */\n    var reconnectTimeout = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name maxReconnectTimeout\n     * @private\n     * @type {number}\n     */\n    var maxReconnectTimeout = 5 * 60 * 1000;\n    /**\n     * Rejects a message if the body size is greater than this. It is enforced servcer side, so changing this\n     * won't make the bodySizeLimit any bigger, this just gives you a senseable error if it's too big.\n     * @memberof! respoke.signalingChannel\n     * @name bodySizeLimit\n     * @private\n     * @type {number}\n     */\n    var bodySizeLimit = 20000;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name appId\n     * @private\n     * @type {string}\n     */\n    var appId = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name endpointId\n     * @private\n     * @type {string}\n     */\n    var endpointId = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name token\n     * @private\n     * @type {string}\n     */\n    var token = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name appToken\n     * @private\n     * @type {string}\n     */\n    var appToken = null;\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name xhr\n     * @private\n     * @type {XMLHttpRequest}\n     */\n    var xhr = new XMLHttpRequest();\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name routingMethods\n     * @private\n     * @type {object}\n     * @desc The methods contained in this object are statically defined methods that are called by constructing\n     * their names dynamically. 'do' + $className + $signalType == 'doCallOffer', et. al.\n     */\n    var routingMethods = {};\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name handlerQueue\n     * @private\n     * @type {object}\n     */\n    var handlerQueue = {\n        'message': [],\n        'signal': [],\n        'presence': []\n    };\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @name errors\n     * @private\n     * @type {object}\n     */\n    var errors = {\n        400: \"Can't perform this action: missing or invalid parameters.\",\n        401: \"Can't perform this action: not authenticated.\",\n        403: \"Can't perform this action: not authorized.\",\n        404: \"Item not found.\",\n        409: \"Can't perform this action: item in the wrong state.\",\n        429: \"API rate limit was exceeded.\",\n        500: \"Can't perform this action: server problem.\"\n    };\n\n    /**\n     * Indicate whether the signaling channel has a valid connection to Respoke.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.isConnected\n     * @return {boolean}\n     */\n    that.isConnected = function () {\n        return !!(that.socket && that.socket.socket.connected);\n    };\n\n    /**\n     * Indicate whether the signaling channel is currently waiting on a websocket to connect.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.isConnecting\n     * @private\n     * @return {boolean}\n     */\n    function isConnecting() {\n        return !!(that.socket && that.socket.socket.connecting);\n    }\n\n    /**\n     * Get the call debug preference.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.isSendingReport\n     * @private\n     * @return {boolean}\n     */\n    that.isSendingReport = function (params) {\n        return clientSettings.enableCallDebugReport;\n    };\n\n    /**\n     * Open a connection to the REST API and validate the app, creating a session token.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.open\n     * @private\n     * @param {object} params\n     * @param {string} [params.token] - The Endpoint's auth token\n     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @return {Promise}\n     */\n    that.open = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug('SignalingChannel.open', params, clientSettings);\n        token = params.token || token;\n        actuallyConnect = typeof params.actuallyConnect === 'function' ? params.actuallyConnect : actuallyConnect;\n\n        Q.fcall(function tokenPromise() {\n            if (clientSettings.developmentMode === true && clientSettings.appId && params.endpointId) {\n                return that.getToken({\n                    appId: clientSettings.appId,\n                    endpointId: params.endpointId\n                });\n            }\n            return null;\n        }).then(function successHandler(newToken) {\n            token = newToken || token;\n            return doOpen({token: token});\n        }).done(function successHandler() {\n            deferred.resolve();\n            log.debug('client', client);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Get a developer mode token for an endpoint. App must be in developer mode.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getToken\n     * @private\n     * @param {object} params\n     * @param {string} [params.endpointId] - An identifier to use when creating an authentication token for this\n     * endpoint. This is only used when `developmentMode` is set to `true`.\n     * @return {Promise<String>}\n     */\n    that.getToken = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug('SignalingChannel.getToken', params);\n\n        var callParams = {\n            path: '/v1/tokens',\n            httpMethod: 'POST',\n            parameters: {\n                appId: clientSettings.appId,\n                endpointId: params.endpointId,\n                ttl: 60 * 60 * 6\n            }\n        };\n\n        call(callParams).done(function (response) {\n            if (response.statusCode === 200 && response.body && response.body.tokenId) {\n                token = response.body.tokenId;\n                deferred.resolve(response.body.tokenId);\n                return;\n            }\n\n            var errorMessage = \"Couldn't get a developer mode token. \";\n            if (isBillingSuspensionUnauthorizedResponse(response)) {\n                errorMessage += billingSuspensionErrorMessage;\n            } else if (isSuspensionUnauthorizedResponse(response)) {\n                errorMessage += suspensionErrorMessage;\n            } else {\n                errorMessage += response.error;\n            }\n\n            deferred.reject(buildResponseError(response, errorMessage));\n        }, function (err) {\n            deferred.reject(new Error(\"Couldn't get a developer mode token. \" + err.message));\n        });\n        return deferred.promise;\n    };\n\n    /**\n     * Open a connection to the REST API and validate the app, creating a session token.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.doOpen\n     * @param {object} params\n     * @param {string} params.token - The Endpoint's auth token\n     * @return {Promise}\n     * @private\n     */\n    function doOpen(params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug('SignalingChannel.doOpen', params);\n\n        if (!params.token) {\n            deferred.reject(new Error(\"Can't open connection to Respoke without a token.\"));\n            return deferred.promise;\n        }\n\n        call({\n            path: '/v1/session-tokens',\n            httpMethod: 'POST',\n            parameters: {\n                tokenId: params.token\n            }\n        }).done(function (response) {\n            if (response.statusCode === 200) {\n                appToken = response.body.token;\n                deferred.resolve();\n                log.debug(\"Signaling connection open to\", clientSettings.baseURL);\n                return;\n            }\n\n            var errorMessage = \"Couldn't authenticate app. \";\n            if (isBillingSuspensionUnauthorizedResponse(response)) {\n                errorMessage += billingSuspensionErrorMessage;\n            } else if (isSuspensionUnauthorizedResponse(response)) {\n                errorMessage += suspensionErrorMessage;\n            } else {\n                errorMessage += response.error;\n            }\n\n            deferred.reject(buildResponseError(response, errorMessage));\n        }, function (err) {\n            log.error(\"Network call failed:\", err.message);\n            deferred.reject(new Error(\"Couldn't authenticate app. \" + err.message));\n        });\n\n        return deferred.promise;\n    }\n\n    /**\n     * Close a connection to the REST API. Invalidate the session token.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.close\n     * @private\n     * @return {Promise}\n     */\n    that.close = function () {\n        var deferred = Q.defer();\n\n        wsCall({\n            path: '/v1/connections/{id}/',\n            httpMethod: 'DELETE',\n            urlParams: {\n                id: client.endpointId\n            }\n        }).fin(function finallyHandler() {\n            return call({\n                path: '/v1/session-tokens',\n                httpMethod: 'DELETE'\n            });\n        }).fin(function finallyHandler() {\n            if (that.socket) {\n                that.socket.removeAllListeners();\n                that.socket.disconnect();\n            }\n            that.socket = null;\n            deferred.resolve();\n        }).done();\n\n        return deferred.promise;\n    };\n\n    /**\n     * Generate and send a presence message representing the client's current status. This triggers\n     * the server to send the client's endpoint's presence.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendPresence\n     * @private\n     * @param {object} params\n     * @param {string|number|object|Array} [params.presence=available]\n     * @param {string} [params.status] - Non-enumeration human-readable status.\n     * @param {string} [params.show] - I can't remember what this is.\n     * @returns {Promise}\n     */\n    that.sendPresence = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        log.debug(\"Signaling sendPresence\");\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/presence',\n            httpMethod: 'POST',\n            parameters: {\n                'presence': {\n                    show: params.show,\n                    'status': params.status,\n                    type: params.presence || \"available\"\n                }\n            }\n        }).done(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    };\n\n    /**\n     * If the logged-in endpoint has permission through its Respoke role, forcibly remove another participant\n     * from the conference, ending its conference call.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.removeConferenceParticipant\n     * @private\n     * @param {object} params\n     * @param {string} [endpointId] - The endpoint id of the endpoint to be removed\n     * @param {string} [connectionId] - The connection id of the connection to be removed\n     * @returns {Promise}\n     */\n    that.removeConferenceParticipant = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var endpointId = params.endpointId;\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        if (!endpointId && params.connectionId) {\n            try {\n                endpointId = client.getConnection({\n                    connectionId: params.connectionId\n                }).getEndpoint().id;\n            } catch (err) {}\n\n            if (!endpointId) {\n                deferred.reject(new Error(\"conference.removeParticipant can't figure out what endpoint to remove!\"));\n                return deferred.promise;\n            }\n        }\n\n        wsCall({\n            httpMethod: 'DELETE',\n            path: '/v1/conferences/{id}/participants/{endpointId}',\n            urlParams: {\n                id: params.conferenceId,\n                endpointId: endpointId\n            },\n            parameters: {\n                connectionId: params.connectionId // Optional; It's OK if it's undefined here.\n            }\n        }).then(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * If the logged-in endpoint has permission through its Respoke role, close down the conference, removing all\n     * participants.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.destroyConference\n     * @param {object} params\n     * @param {string} params.id\n     * @private\n     * @returns {Promise}\n     */\n    that.destroyConference = function (params) {\n        var deferred = Q.defer();\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            httpMethod: 'DELETE',\n            path: '/v1/conferences/{id}/',\n            urlParams: { id: params.conferenceId }\n        }).then(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Retrieve the list of participants in the specified conference.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getConferenceParticipants\n     * @private\n     * @returns {Promise<respoke.Connection>}\n     * @param {object} params\n     * @param {string} params.id\n     */\n    that.getConferenceParticipants = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            httpMethod: 'GET',\n            path: '/v1/conferences/{id}/participants/',\n            urlParams: { id: params.id }\n        }).then(function successHandler(participants) {\n            deferred.resolve(participants.map(function (par) {\n                return client.getConnection({\n                    connectionId: par.connectionId,\n                    endpointId: par.endpointId\n                });\n            }));\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Get or create a group in the infrastructure.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getGroup\n     * @private\n     * @returns {Promise<respoke.Group>}\n     * @param {object} params\n     * @param {string} params.name\n     */\n    that.getGroup = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            httpMethod: 'POST',\n            path: '/v1/channels/',\n            parameters: {\n                name: params.name\n            }\n        }).then(function successHandler(group) {\n            deferred.resolve(group);\n        }, function errorHandler(err) {\n            // Group was already created, just return back the same params we were given.\n            deferred.resolve({id: params.name});\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Leave a group. In order to aggregate subsequent repeated requests, this function, when called synchronously,\n     * will continue to accumulate group ids until the next tick of the event loop, when the request will be\n     * issued. The same instance of Promise is returned each time.\n     * @memberof! respoke.SignalingChannel\n     * @private\n     * @method respoke.SignalingChannel.leaveGroup\n     * @returns {Promise}\n     * @param {object} params\n     * @param {array} params.groupList\n     */\n    that.leaveGroup = (function () {\n        var groups = {};\n        var deferred = Q.defer();\n\n        return function (params) {\n            params = params || {};\n            params.groupList = params.groupList || [];\n\n            var toRun = (Object.keys(groups).length === 0);\n\n            if (!that.isConnected()) {\n                deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n                return deferred.promise;\n            }\n\n            params.groupList.forEach(function (id) {\n                if (typeof id === 'string') {\n                    groups[id] = true;\n                }\n            });\n\n            if (!toRun) {\n                return deferred.promise;\n            }\n\n            setTimeout(function () {\n                // restart accumulation\n                var groupList = Object.keys(groups);\n                groups = {};\n                var saveDeferred = deferred;\n                deferred = Q.defer();\n\n                if (groupList.length === 0) {\n                    saveDeferred.resolve();\n                    return;\n                }\n\n                wsCall({\n                    path: '/v1/groups/',\n                    parameters: {\n                        groups: groupList\n                    },\n                    httpMethod: 'DELETE'\n                }).done(function successHandler() {\n                    saveDeferred.resolve();\n                }, function errorHandler(err) {\n                    saveDeferred.reject(err);\n                });\n            });\n            return deferred.promise;\n        };\n    })();\n\n    /**\n     * Join a group. In order to aggregate subsequent repeated requests, this function, when called synchronously,\n     * will continue to accumulate group ids until the next tick of the event loop, when the request will be\n     * issued. The same instance of Promise is returned each time.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.joinGroup\n     * @private\n     * @returns {Promise}\n     * @param {object} params\n     * @param {array} params.groupList\n     */\n    that.joinGroup = (function () {\n        var groups = {};\n        var deferred = Q.defer();//i think this needs to go in actualJoinGroup\n\n        return function actualJoinGroup(params) {\n            params = params || {};\n            params.groupList = params.groupList || [];\n\n            log.trace('been asked to join groups', params.groupList);\n\n            var needsToRun = (Object.keys(groups).length === 0);\n\n            if (!that.isConnected()) {\n                deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n                return deferred.promise;\n            }\n\n            params.groupList.forEach(function (id) {\n                if (typeof id === 'string') {\n                    log.trace('put group', id, 'in the join queue');\n                    groups[id] = true;\n                }\n            });\n\n            if (!needsToRun) {\n                return deferred.promise;\n            }\n\n            setTimeout(function requestJoinsForGroupQueue() {\n                // restart accumulation\n                var groupList = Object.keys(groups);\n                log.trace('list of groups to be requested', groupList);\n                //reset the groups object\n                groups = {};\n                var saveDeferred = deferred;\n                deferred = Q.defer();\n\n                if (groupList.length === 0) {\n                    log.trace('list of groups was empty so not sending queue');\n                    saveDeferred.resolve();\n                    return;\n                }\n\n                wsCall({\n                    path: '/v1/groups/',\n                    parameters: {\n                        groups: groupList\n                    },\n                    httpMethod: 'POST'\n                }).done(function successHandler() {\n                    saveDeferred.resolve();\n                }, function errorHandler(err) {\n                    saveDeferred.reject(err);\n                });\n            });\n            return deferred.promise;\n        };\n    })();\n\n    /**\n     * Publish a message to a group.\n     * @memberof! respoke.SignalingChannel\n     * @private\n     * @method respoke.SignalingChannel.publish\n     * @returns {Promise}\n     * @param {object} params\n     * @param {string} params.id\n     * @param {string} params.message\n     * @param {boolean} [params.push=false]\n     */\n    that.publish = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var message = respoke.TextMessage({\n            endpointId: params.id,\n            message: params.message,\n            push: !!params.push\n        });\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/channels/{id}/publish/',\n            urlParams: { id: params.id },\n            httpMethod: 'POST',\n            parameters: message\n        }).done(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    };\n\n    /**\n     * Register as an observer of presence for the specified endpoint ids. In order to aggregate subsequent repeated\n     * requests, this function, when called synchronously, will continue to accumulate endpoint ids until the next\n     * tick of the event loop, when the request will be issued. The same instance of Promise is returned each time.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.registerPresence\n     * @private\n     * @param {object} params\n     * @param {Array<string>} params.endpointList\n     * @returns {Promise}\n     */\n    that.registerPresence = (function () {\n        var endpoints = {};\n        var deferred = Q.defer();\n\n        return function (params) {\n            params = params || {};\n            params.endpointList = params.endpointList || [];\n            var toRun = (Object.keys(endpoints).length === 0);\n\n            if (!that.isConnected()) {\n                return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            }\n\n            params.endpointList.forEach(function (ep) {\n                if (typeof ep === 'string' && presenceRegistered[ep] !== true) {\n                    endpoints[ep] = true;\n                }\n            });\n\n            if (!toRun) {\n                return deferred.promise;\n            }\n\n            setTimeout(function () {\n                // restart accumulation\n                var endpointList = Object.keys(endpoints);\n                endpoints = {};\n                var saveDeferred = deferred;\n                deferred = Q.defer();\n\n                if (endpointList.length === 0) {\n                    saveDeferred.resolve();\n                    return;\n                }\n\n                wsCall({\n                    httpMethod: 'POST',\n                    path: '/v1/presenceobservers',\n                    parameters: {\n                        endpointList: endpointList\n                    }\n                }).done(function successHandler() {\n                    params.endpointList.forEach(function eachId(id) {\n                        presenceRegistered[id] = true;\n                    });\n                    saveDeferred.resolve();\n                }, function (err) {\n                    saveDeferred.reject(err);\n                });\n                // We could even add a tiny delay like 10ms if we want to get more conservative and\n                // catch asychronous calls to client.getEndpoint() and other methods which call\n                // this method.\n            });\n\n            return deferred.promise;\n        };\n    })();\n\n    /**\n     * Join a group.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getGroupMembers\n     * @private\n     * @returns {Promise<Array>}\n     * @param {object} params\n     * @param {string} params.id\n     */\n    that.getGroupMembers = function (params) {\n        var deferred = Q.defer();\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        if (!params.id) {\n            deferred.reject(new Error(\"Can't get group's endpoints without group ID.\"));\n            return deferred.promise;\n        }\n\n        return wsCall({\n            path: '/v1/channels/{id}/subscribers/',\n            urlParams: { id: params.id },\n            httpMethod: 'GET'\n        });\n    };\n\n    /**\n     * Send a chat message.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendMessage\n     * @private\n     * @param {object} params\n     * @param {respoke.SignalingMessage} params.message - The string text message to send.\n     * @param {respoke.Endpoint} params.recipient\n     * @param {string} [params.connectionId]\n     * @param {boolean} [params.push=false]\n     * @returns {Promise}\n     */\n    that.sendMessage = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var message = respoke.TextMessage({\n            endpointId: params.recipient.id,\n            ccSelf: params.ccSelf,\n            connectionId: params.connectionId,\n            message: params.message,\n            push: !!params.push\n        });\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/messages',\n            httpMethod: 'POST',\n            parameters: message\n        }).done(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    };\n\n    /**\n     * Send an ACK signal to acknowlege reception of a signal.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendACK\n     * @private\n     * @param {object} params\n     * @param {respoke.SignalingMessage} params.signal\n     * @return {Promise}\n     */\n    that.sendACK = function (params) {\n        var endpoint;\n        params = params || {};\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        if (!params.signal) {\n            return Q.reject(new Error(\"Can't send ACK, no signal was given.\"));\n        }\n\n        endpoint = client.getEndpoint({\n            id: params.signal.fromEndpoint,\n            skipPresence: true\n        });\n        if (!endpoint) {\n            return Q.reject(new Error(\"Can't send ACK, can't get endpoint.\"));\n        }\n\n        return that.sendSignal({\n            recipient: endpoint,\n            signalType: 'ack',\n            signalId: params.signal.signalId,\n            sessionId: params.signal.sessionId,\n            target: params.signal.target,\n            ackedSignalType: params.signal.signalType\n        });\n    };\n\n    /**\n     * Send a signaling message.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendSignal\n     * @private\n     * @param {object} params\n     * @param {respoke.Call} [params.call] - For getting the sessionId & connectionId. Not required for 'ack'.\n     * @return {Promise}\n     */\n    that.sendSignal = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var signal;\n        var to;\n        var toConnection;\n        var toType;\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        if (params.call) {\n            params.sessionId = params.call.id;\n            if (params.call.connectionId) { // the recipient's connectionId\n                params.connectionId = params.call.connectionId;\n            }\n        }\n\n        to = params.recipient.id;\n        toConnection = params.connectionId;\n        toType = params.toType || 'web';\n\n        try {\n            params.signalId = respoke.makeGUID();\n            // This will strip off non-signaling attributes.\n            signal = respoke.SignalingMessage(params);\n        } catch (e) {\n            deferred.reject(e);\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/signaling',\n            httpMethod: 'POST',\n            parameters: {\n                ccSelf: params.ccSelf,\n                signal: JSON.stringify(signal),\n                to: to,\n                toConnection: toConnection,\n                toType: toType\n            }\n        }).done(function successHandler() {\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Send an ICE candidate.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendCandidate\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @param {string} [params.connectionId]\n     * @param {Array<RTCIceCandidate>} params.iceCandidates - An array of ICE candidate.\n     * @return {Promise}\n     */\n    that.sendCandidate = function (params) {\n        params = params || {};\n        params.signalType = 'iceCandidates';\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        if (typeof params.finalCandidates !== 'undefined') {\n            log.debug('Sending final', params.iceCandidates.length, 'of', params.finalCandidates.length, 'ice candidates');\n        } else {\n            log.debug('Sending', params.iceCandidates.length, 'ice candidates');\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Send an SDP.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendSDP\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @param {string} [params.connectionId]\n     * @param {RTCSessionDescription} params.sessionDescription - An SDP to JSONify and send.\n     * @return {Promise}\n     */\n    that.sendSDP = function (params) {\n        params = params || {};\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        if (['offer', 'answer'].indexOf(params.signalType) === -1) {\n            return Q.reject(\"Not an SDP type signal.\");\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Send a call report to the cloud infrastructure.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendReport\n     * @private\n     * @param {object} params\n     * @todo TODO document the params.\n     * @return {Promise}\n     */\n    that.sendReport = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var message = {\n            debugData: params\n        };\n\n        if (!clientSettings.enableCallDebugReport) {\n            log.debug('not sending call debugs - disabled');\n            deferred.resolve();\n            return deferred.promise;\n        }\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            path: '/v1/call-debugs',\n            httpMethod: 'POST',\n            parameters: message\n        }).done(function () {\n            deferred.resolve();\n        }, function (err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Send a message hanging up the WebRTC session.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendHangup\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @param {string} [params.connectionId]\n     * @param {string} params.reason - The reason the session is being hung up.\n     * @return {Promise}\n     */\n    that.sendHangup = function (params) {\n        params = params || {};\n        params.signalType = 'bye';\n        params.ccSelf = true;\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Send a message to all connection ids indicating we have negotiated a call with one connection.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendConnected\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @return {Promise}\n     */\n    that.sendConnected = function (params) {\n        params = params || {};\n        params.signalType = 'connected';\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Send a message to the remote party indicating a desire to renegotiate media.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.sendModify\n     * @private\n     * @param {object} params\n     * @param {respoke.Endpoint} params.recipient - The recipient.\n     * @param {string} params.action - The state of the modify request, one of: 'initiate', 'accept', 'reject'\n     * @return {Promise}\n     */\n    that.sendModify = function (params) {\n        params = params || {};\n        params.signalType = 'modify';\n\n        if (['initiate', 'accept', 'reject'].indexOf(params.action) === -1) {\n            return Q.reject(\"No valid action in modify signal.\");\n        }\n\n        if (!that.isConnected()) {\n            return Q.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n        }\n\n        return that.sendSignal(params);\n    };\n\n    /**\n     * Uppercase the first letter of the word.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.firstUpper\n     * @private\n     */\n    function firstUpper(str) {\n        return str[0].toUpperCase() + str.slice(1);\n    }\n\n    /**\n     * Route different types of signaling messages via events.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routeSignal\n     * @private\n     * @param {respoke.SignalingMessage} signal - A message to route\n     * @fires respoke.Call#offer\n     * @fires respoke.Call#connected\n     * @fires respoke.Call#answer\n     * @fires respoke.Call#iceCandidates\n     * @fires respoke.Call#hangup\n     * @fires respoke.DirectConnection#offer\n     * @fires respoke.DirectConnection#connected\n     * @fires respoke.DirectConnection#answer\n     * @fires respoke.DirectConnection#iceCandidates\n     * @fires respoke.DirectConnection#hangup\n     */\n    that.routeSignal = function (signal) {\n        var target = null;\n        var method = 'do';\n\n        if (signal.signalType !== 'iceCandidates' || respoke.ridiculous) { // Too many of these!\n            log.debug(signal.signalType, signal);\n        }\n\n        // Only create if this signal is an offer.\n        return Q().then(function () {\n            var endpoint;\n\n            if (signal.target === undefined) {\n                throw new Error(\"target undefined\");\n            }\n\n            /*\n             * This will return calls regardless of whether they are associated\n             * with a direct connection or not, and it will create a call if no\n             * call is found and this signal is an offer. Direct connections get\n             * created in the next step.\n             *\n             * signal.toOriginal will be undefined except in the case that another connection\n             * with our same endpointId has just hung up on the call.\n             */\n            target = client.getCall({\n                id: signal.sessionId,\n                endpointId: signal.toOriginal || signal.fromEndpoint,\n                target: signal.target,\n                conferenceId: signal.conferenceId,\n                type: signal.fromType,\n                create: (signal.target !== 'directConnection' && signal.signalType === 'offer'),\n                callerId: signal.callerId,\n                metadata: signal.metadata\n            });\n            if (target) {\n                return target;\n            }\n\n            if (signal.target === 'directConnection') {\n                // return a promise\n                endpoint = client.getEndpoint({\n                    id: signal.fromEndpoint,\n                    skipPresence: true\n                });\n\n                if (endpoint.directConnection && endpoint.directConnection.call.id === signal.sessionId) {\n                    return endpoint.directConnection;\n                }\n\n                return endpoint.startDirectConnection({\n                    id: signal.sessionId,\n                    create: (signal.signalType === 'offer'),\n                    caller: (signal.signalType !== 'offer'),\n                    metadata: signal.metadata\n                });\n            }\n        }).then(function successHandler(target) {\n            // target might be null, a Call, or a DirectConnection.\n            if (target) {\n                target = target.call || target;\n            }\n            if (!target || target.id !== signal.sessionId) {\n                // orphaned signal\n                log.warn(\"Couldn't associate signal with a call. This is usually OK.\", signal);\n                return;\n            }\n\n            method += firstUpper(signal.signalType);\n            routingMethods[method]({\n                call: target,\n                signal: signal\n            });\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doOffer\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-offer\n     */\n    routingMethods.doOffer = function (params) {\n        params.call.connectionId = params.signal.fromConnection;\n        /**\n         * Send the `offer` signal into the Call.\n         * @event respoke.Call#signal-offer\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-offer', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doConnected\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-connected\n     */\n    routingMethods.doConnected = function (params) {\n        /**\n         * Send the `connected` signal into the Call.\n         * @event respoke.Call#signal-connected\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-connected', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.dModify\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-modify\n     */\n    routingMethods.doModify = function (params) {\n        /**\n         * Send the `modify` signal into the Call.\n         * @event respoke.Call#signal-modify\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-modify', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doAnswer\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-answer\n     */\n    routingMethods.doAnswer = function (params) {\n        params.call.connectionId = params.signal.fromConnection;\n        /**\n         * Send the `answer` signal into the Call.\n         * @event respoke.Call#signal-answer\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-answer', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doIceCandidates\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-icecandidates\n     */\n    routingMethods.doIceCandidates = function (params) {\n        /**\n         * Send the `icecandidates` signal into the Call.\n         * @event respoke.Call#signal-icecandidates\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-icecandidates', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doBye\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     * @fires respoke.Call#signal-hangup\n     */\n    routingMethods.doBye = function (params) {\n        /**\n         *  The caller may receive hangup from one or more parties after connectionId is set if the call is rejected\n         *  by a connection that didn't win the call. In this case, we have to ignore the signal since\n         *  we are already on a call.\n         *\n         *  The callee's connectionId is always set.\n         */\n        if (params.call.caller && params.call.connectionId &&\n                params.call.connectionId !== params.signal.fromConnection) {\n            return;\n        }\n        /**\n         * Send the `hangup` signal into the Call.\n         * @event respoke.Call#signal-hangup\n         * @type {respoke.Event}\n         * @property {object} signal\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        params.call.fire('signal-hangup', {\n            signal: params.signal\n        });\n    };\n\n    /**\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.routingMethods.doUnknown\n     * @private\n     * @params {object} params\n     * @params {object} params.signal\n     */\n    routingMethods.doUnknown = function (params) {\n        log.error(\"Don't know what to do with\", params.signal.target, \"msg of unknown type\", params.signal.signalType);\n    };\n\n    /**\n     * Add a handler to the connection for messages of different types.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.addHandler\n     * @private\n     * @param {object} params\n     * @param {string} params.type - The type of socket message, i. e., 'message', 'presence', 'join'\n     * @param {function} params.handler - A function to which to pass the message\n     * @todo TODO See if this is necessary anymore\n     */\n    that.addHandler = function (params) {\n        if (that.socket.socket && that.socket.socket.open) {\n            that.socket.on(params.type, params.handler);\n        } else {\n            handlerQueue[params.type].push(params.handler);\n        }\n    };\n\n    function socketOnSignal(message) {\n        var knownSignals = ['offer', 'answer', 'connected', 'modify', 'iceCandidates', 'bye'];\n        var signal = respoke.SignalingMessage({\n            rawMessage: message\n        });\n\n        if (signal.signalType === 'ack') {\n            return;\n        }\n\n        if (!signal.target || !signal.signalType || knownSignals.indexOf(signal.signalType) === -1) {\n            log.error(\"Got malformed signal.\", signal);\n            throw new Error(\"Can't route signal without target or type.\");\n        }\n\n        that.routeSignal(signal).done();\n    }\n    that.socketOnSignal = socketOnSignal;\n\n    /**\n     * Socket handler for pub-sub messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.socketOnPubSub\n     * @param {object} message The Socket.io message.\n     * @private\n     * @fires respoke.Group#message\n     * @fires respoke.Client#message\n     */\n    function socketOnPubSub(message) {\n        var group;\n        var groupMessage = respoke.TextMessage({\n            rawMessage: message\n        });\n\n        group = client.getGroup({id: message.header.channel});\n        if (group) {\n            /**\n             * Indicate that a message has been received to a group.\n             * @event respoke.Group#message\n             * @type {respoke.Event}\n             * @property {respoke.TextMessage} message\n             * @property {string} name - the event name.\n             * @property {respoke.Group} target\n             */\n            group.fire('message', {\n                message: groupMessage\n            });\n        }\n        /**\n         * Indicate that a message has been received.\n         * @event respoke.Client#message\n         * @type {respoke.Event}\n         * @property {respoke.TextMessage} message\n         * @property {respoke.Group} [group] - If the message is to a group we already know about,\n         * this will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\n         * the group. From that point forward, Group#message will fire when a message is received as well. If\n         * group is undefined instead of null, the message is not a group message at all.\n         * @property {string} name - the event name.\n         * @property {respoke.Client} target\n         */\n        client.fire('message', {\n            message: groupMessage,\n            group: group || null\n        });\n    }\n    that.socketOnPubSub = socketOnPubSub;\n\n    /**\n     * Socket handler for join messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.socketOnJoin\n     * @param {object} message The Socket.io message.\n     * @private\n     */\n    function socketOnJoin(message) {\n        var group;\n        var presenceMessage;\n        var endpoint;\n        var connection;\n\n        if (message.connectionId === client.connectionId) {\n            connection = client.getConnection({connectionId: message.connectionId, endpointId: message.endpointId});\n            group = client.getGroup({id: message.header.channel});\n            if (!group) {\n                group = respoke.Group({\n                    id: message.header.channel,\n                    instanceId: instanceId,\n                    signalingChannel: that\n                });\n                client.addGroup(group);\n            }\n            if (!group.isJoined()) {\n                group.addMember({connection: connection});\n                client.fire('join', {\n                    group: group\n                });\n            }\n        } else {\n\n            endpoint = client.getEndpoint({\n                skipPresence: true,\n                id: message.endpointId,\n                instanceId: instanceId,\n                name: message.endpointId\n            });\n\n            // Handle presence not associated with a channel\n            if (!connection) {\n                endpoint.setPresence({\n                    connectionId: message.connectionId\n                });\n                connection = client.getConnection({\n                    connectionId: message.connectionId,\n                    endpointId: message.endpointId\n                });\n            }\n\n            group = client.getGroup({id: message.header.channel});\n\n            if (group && connection) {\n                group.addMember({connection: connection});\n            } else {\n                log.error(\"Can't add endpoint to group:\", message, group, endpoint, connection);\n            }\n        }\n    }\n    that.socketOnJoin = socketOnJoin;\n\n    /**\n     * Socket handler for leave messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.socketOnLeave\n     * @param {object} message The Socket.io message.\n     * @private\n     */\n    function socketOnLeave(message) {\n        var group;\n        var presenceMessage;\n        var endpoint;\n        if (message.connectionId === client.connectionId) {\n            group = client.getGroup({id: message.header.channel});\n            client.fire('leave', {\n                group: group\n            });\n        } else {\n\n            endpoint = client.getEndpoint({\n                skipPresence: true,\n                id: message.endpointId\n            });\n\n            endpoint.connections.every(function eachConnection(conn, index) {\n                if (conn.id === message.connectionId) {\n                    endpoint.connections.splice(index, 1);\n                    return false;\n                }\n                return true;\n            });\n\n            group = client.getGroup({id: message.header.channel});\n            if (group) {\n                group.removeMember({connectionId: message.connectionId});\n            }\n        }\n    }\n    that.socketOnLeave = socketOnLeave;\n\n    /**\n     * Socket handler for presence messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.onMessage\n     * @param {object} message The Socket.io message.\n     * @private\n     * @fires respoke.Endpoint#message\n     * @fires respoke.Client#message\n     */\n    function socketOnMessage(message) {\n        var endpoint;\n        message = respoke.TextMessage({rawMessage: message});\n        if (message.originalRecipient || message.endpointId) {\n            endpoint = client.getEndpoint({\n                id: message.originalRecipient || message.endpointId,\n                skipCreate: true\n            });\n        }\n        if (endpoint) {\n            /**\n             * Indicate that a message has been received.\n             * @event respoke.Endpoint#message\n             * @type {respoke.Event}\n             * @property {respoke.TextMessage} message\n             * @property {string} name - the event name.\n             * @property {respoke.Endpoint} target\n             */\n            endpoint.fire('message', {\n                message: message\n            });\n        }\n        /**\n         * Indicate that a message has been received.\n         * @event respoke.Client#message\n         * @type {respoke.Event}\n         * @property {respoke.TextMessage} message\n         * @property {respoke.Endpoint} [endpoint] - If the message is from an endpoint we already know about,\n         * this will be set. If null, the developer can use client.getEndpoint({id: evt.message.endpointId}) to get\n         * the Endpoint. From that point forward, Endpoint#message will fire when a message is received as well.\n         * @property {string} name - the event name.\n         * @property {respoke.Client} target\n         */\n        client.fire('message', {\n            endpoint: endpoint || null,\n            message: message\n        });\n    }\n    that.socketOnMessage = socketOnMessage;\n\n    /**\n     * Create a socket handler for the onConnect event with all the right things in scope.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.generateConnectHandler\n     * @param {respoke.Client.successHandler} [onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [onError] - Error handler for this invocation of this\n     * method only.\n     * @private\n     */\n    var generateConnectHandler = function generateConnectHandler(onSuccess, onError) {\n        onSuccess = onSuccess || function () {};\n        onError = onError || function () {};\n        return function onConnect() {\n            Object.keys(handlerQueue).forEach(function addEachHandlerType(category) {\n                if (!handlerQueue[category]) {\n                    return;\n                }\n\n                handlerQueue[category].forEach(function addEachHandler(handler) {\n                    that.socket.on(category, handler);\n                });\n                handlerQueue[category] = [];\n            });\n\n            wsCall({\n                path: '/v1/connections',\n                httpMethod: 'POST',\n                parameters: {\n                    capabilities: {\n                        iceFinalCandidates: true\n                    }\n                }\n            }).done(function successHandler(res) {\n                log.debug('connections result', res);\n                client.endpointId = res.endpointId;\n                client.connectionId = res.id;\n                onSuccess();\n            }, onError);\n        };\n    };\n\n    /**\n     * Socket handler for presence messages.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.socketOnPresence\n     * @param {object} message The Socket.io message.\n     * @private\n     */\n    function socketOnPresence(message) {\n        var endpoint;\n        var groups;\n\n        if (message.header.from === client.endpointId) {\n            log.debug('socket.on presence for self ignored', message);\n            // Skip ourselves\n            return;\n        }\n        log.debug('socket.on presence', message);\n\n        endpoint = client.getEndpoint({\n            skipPresence: true,\n            id: message.header.from,\n            instanceId: instanceId,\n            // TODO: find out what this is for? should it be message.header.type?\n            name: message.header.from,\n            connection: message.header.fromConnection\n        });\n\n        endpoint.setPresence({\n            connectionId: message.header.fromConnection,\n            presence: message.type\n        });\n\n        if (endpoint.presence === 'unavailable') {\n            groups = client.getGroups();\n            if (groups) {\n                groups.forEach(function eachGroup(group) {\n                    group.removeMember({connectionId: message.header.fromConnection});\n                });\n            }\n        }\n    }\n    that.socketOnPresence = socketOnPresence;\n\n    /**\n     * On reconnect, start with a reconnect interval of 2000ms. Every time reconnect fails, the interval\n     * is doubled up to a maximum of 5 minutes. From then on, it will attempt to reconnect every 5 minutes forever.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.reconnect\n     * @private\n     */\n    function reconnect() {\n        if (clientSettings.reconnect !== true) {\n            return;\n        }\n        // Reconnects within reconnects is ungood\n        clientSettings.reconnect = false;\n\n        appToken = null;\n        token = null;\n\n        if (that.socket) {\n            that.socket.removeAllListeners();\n            that.socket.disconnect();\n            that.socket = null;\n        }\n\n        reconnectTimeout = (reconnectTimeout === null) ? 2500 : 2 * reconnectTimeout;\n\n        if (reconnectTimeout > (maxReconnectTimeout)) {\n            reconnectTimeout = maxReconnectTimeout;\n        }\n\n        setTimeout(function doReconnect() {\n            log.debug('Reconnecting...');\n\n            actuallyConnect().then(function successHandler() {\n                reconnectTimeout = null;\n                log.debug('socket reconnected');\n                return Q.all(client.getGroups().map(function iterGroups(group) {\n                    client.join({\n                        id: group.id,\n                        onMessage: clientSettings.onMessage,\n                        onJoin: clientSettings.onJoin,\n                        onLeave: clientSettings.onLeave\n                    }).catch(function (err) {\n                        log.error(\"Couldn't rejoin previous group.\", { id: group.id, message: err.message, stack: err.stack });\n                        throw err;\n                    });\n                }));\n            }).then(function successHandler() {\n                log.debug('groups rejoined after reconnect');\n                /**\n                 * Indicate that a reconnect has succeeded.\n                 * @event respoke.Client#reconnect\n                 * @property {string} name - the event name.\n                 * @property {respoke.Client}\n                 */\n                client.fire('reconnect');\n            }).fin(function finHandler() {\n                // re-enable reconnects\n                clientSettings.reconnect = true;\n            }).done(null, function errHandler(err) {\n                log.error(\"Couldn't reconnect. Retrying...\", { message: err.message, stack: err.stack });\n                reconnect();\n            });\n        }, reconnectTimeout);\n    }\n\n    /**\n     * Authenticate to the cloud and call the handler on state change.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.authenticate\n     * @private\n     * @param {object} params\n     * @return {Promise}\n     */\n    that.authenticate = function authenticate(params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var pieces = [];\n        var protocol = null;\n        var host = null;\n        var port = null;\n\n        if (!appToken) {\n            deferred.reject(new Error(\"Can't open a websocket without an app token.\"));\n        }\n\n        pieces = clientSettings.baseURL.split(/:\\/\\//);\n        protocol = pieces[0];\n        pieces = pieces[1].split(/:/);\n        host = pieces[0];\n        port = pieces[1];\n\n        var connectParams = {\n            'connect timeout': clientSettings.connectTimeoutMillis,\n            'force new connection': true, // Don't try to reuse old connection.\n            'sync disconnect on unload': true, // have Socket.io call disconnect() on the browser unload event.\n            reconnect: false,\n            host: host,\n            port: port || '443',\n            protocol: protocol,\n            secure: (protocol === 'https'),\n            query: '__sails_io_sdk_version=0.10.0&app-token=' + appToken + '&Respoke-SDK=' + sdkHeaderValue\n        };\n\n        if (that.isConnected() || isConnecting()) {\n            return;\n        }\n\n        that.socket = respoke.io.connect(clientSettings.baseURL, connectParams);\n\n        that.socket.on('connect', generateConnectHandler(function onSuccess() {\n            deferred.resolve();\n        }, function onError(err) {\n            deferred.reject(err);\n        }));\n\n        that.socket.on('join', socketOnJoin);\n        that.socket.on('leave', socketOnLeave);\n        that.socket.on('pubsub', socketOnPubSub);\n        that.socket.on('message', socketOnMessage);\n        that.socket.on('presence', socketOnPresence);\n        that.socket.on('signal', socketOnSignal);\n\n        // connection timeout\n        that.socket.on('connect_failed', function connectFailedHandler(res) {\n            deferred.reject(new Error(\"WebSocket connection failed.\"));\n            log.error('Socket.io connect timeout.', res || \"\");\n            reconnect();\n        });\n\n        // handshake error, 403, socket disconnects on FireFox\n        that.socket.on('error', function errorHandler(res) {\n            log.error('Socket.io error.', res || \"\");\n            reconnect();\n        });\n\n        that.socket.on('disconnect', function onDisconnect() {\n            log.debug('Socket.io disconnect.');\n            pendingRequests.reset(function (pendingRequest) {\n                log.debug('Failing pending requests');\n                pendingRequest.reject(new Error(\"WebSocket disconnected\"));\n            });\n\n            /**\n             * Indicate that this client has been disconnected from the Respoke service.\n             * @event respoke.Client#disconnect\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            client.fire('disconnect');\n\n            reconnect();\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Get ephemeral TURN credentials.  This method is called whenever a call is either\n     * sent or received, prior to creating a PeerConnection\n     *\n     * @memberof! respoke.SignalingChannel\n     * @private\n     * @method respoke.SignalingChannel.getTurnCredentials\n     * @return {Promise<Array>}\n     */\n    that.getTurnCredentials = function getTurnCredentials() {\n        var deferred = Q.defer();\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        wsCall({\n            httpMethod: 'GET',\n            path: '/v1/turn'\n        }).done(function successHandler(creds) {\n            var result = [];\n\n            if (!creds || !creds.uris) {\n                deferred.reject(new Error(\"Turn credentials empty.\"));\n                return;\n            }\n\n            creds.uris.forEach(function saveTurnUri(uri) {\n                var cred = null;\n\n                if (!uri) {\n                    return;\n                }\n\n                cred = createIceServer(uri, creds.username, creds.password);\n                result.push(cred);\n            });\n\n            if (result.length === 0) {\n                deferred.reject(new Error(\"Got no TURN credentials.\"));\n            }\n\n            log.debug('TURN creds', result);\n            deferred.resolve(result);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n\n        return deferred.promise;\n    };\n\n    /**\n     * Construct a websocket API call and return the formatted response and errors. The 'success'\n     * attribute indicates the success or failure of the API call. The 'response' attribute\n     * is an associative array constructed by json.decode. The 'error' attriute is a message.\n     * If the API call is successful but the server returns invalid JSON, error will be\n     * \"Invalid JSON.\" and response will be the unchanged content of the response body.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.wsCall\n     * @private\n     * @param {object} params\n     * @param {string} params.httpMethod\n     * @param {string} params.path\n     * @param {string} params.objectId\n     * @param {object} params.parameters - These are request body parameters that get converted to JSON before\n     * being sent over the websocket. Undefined parameters and functions are removed by JSON.stringify.\n     * @return {Promise<object>}\n     */\n    function wsCall(params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var start = now();\n        // Too many of these!\n        var logRequest = (params.path.indexOf('messages') === -1 && params.path.indexOf('signaling') === -1) ||\n            respoke.ridiculous;\n        var request;\n        var bodyLength = 0;\n        if (params.parameters) {\n            bodyLength = encodeURI(JSON.stringify(params.parameters)).split(/%..|./).length - 1;\n        }\n\n        if (!that.isConnected()) {\n            deferred.reject(new Error(\"Can't complete request when not connected. Please reconnect!\"));\n            return deferred.promise;\n        }\n\n        if (!params) {\n            deferred.reject(new Error('No params.'));\n            return deferred.promise;\n        }\n\n        if (!params.path) {\n            deferred.reject(new Error('No request path.'));\n            return deferred.promise;\n        }\n\n        if (bodyLength > bodySizeLimit) {\n            deferred.reject(new Error('Request body exceeds maximum size of ' + bodySizeLimit + ' bytes'));\n            return deferred.promise;\n        }\n\n        params.httpMethod = (params.httpMethod || 'get').toLowerCase();\n\n        if (params.urlParams) {\n            params.path = template.parse(params.path).expand(params.urlParams);\n        }\n\n        if (logRequest) {\n            log.debug('socket request', {\n                method: params.httpMethod,\n                path: params.path,\n                parameters: params.parameters\n            });\n        }\n\n        request = {\n            method: params.httpMethod,\n            path: params.path,\n            parameters: params.parameters,\n            tries: 0,\n            durationMillis: 0\n        };\n\n        request.id = pendingRequests.add(deferred);\n\n        function handleResponse(response) {\n            var thisHandler = this; // jshint ignore:line\n            /*\n             * Response:\n             *  {\n             *      body: {},\n             *      headers: {},\n             *      statusCode: 200\n             *  }\n             */\n            try {\n                response.body = JSON.parse(response.body);\n            } catch (e) {\n                if (typeof response.body !== 'object') {\n                    deferred.reject(new Error(\"Server response could not be parsed!\" + response.body));\n                    return;\n                }\n            }\n\n            if (response.statusCode === 429) {\n                if (request.tries < 3 && deferred.promise.isPending()) {\n                    setTimeout(function () {\n                        start = now();\n                        sendWebsocketRequest(request, handleResponse);\n                    }, 1000); // one day this will be response.interval or something\n                } else {\n                    request.durationMillis = now() - start;\n                    pendingRequests.remove(request.id);\n                    failWebsocketRequest(request, response,\n                            \"Too many retries after rate limit exceeded.\", deferred);\n                }\n                return;\n            }\n\n            request.durationMillis = now() - start;\n            pendingRequests.remove(request.id);\n\n            if (logRequest) {\n                log.debug('socket response', {\n                    method: request.method,\n                    path: request.path,\n                    durationMillis: request.durationMillis,\n                    response: response\n                });\n            }\n\n            if (isBillingSuspensionUnauthorizedResponse(response)) {\n                failWebsocketRequest(request, response, billingSuspensionErrorMessage, deferred);\n                return;\n            }\n\n            if (isSuspensionUnauthorizedResponse(response)) {\n                failWebsocketRequest(request, response, suspensionErrorMessage, deferred);\n                return;\n            }\n\n            if ([200, 204, 205, 302, 401, 403, 404, 418].indexOf(thisHandler.status) === -1) {\n                failWebsocketRequest(request, response,\n                        response.body.error || errors[thisHandler.status] || \"Unknown error\", deferred);\n                return;\n            }\n\n            deferred.resolve(response.body);\n        }\n\n        start = now();\n        sendWebsocketRequest(request, handleResponse);\n        return deferred.promise;\n    }\n    that.wsCall = wsCall;\n\n    function failWebsocketRequest(request, response, error, deferred) {\n        if (response && response.body && response.body.error) {\n            deferred.reject(buildResponseError(response, error + ' (' + request.method + ' ' + request.path + ')'));\n        } else {\n            deferred.resolve(response.body);\n        }\n    }\n\n    function sendWebsocketRequest(request, handleResponse) {\n        request.tries += 1;\n        that.socket.emit(request.method, JSON.stringify({\n            url: request.path,\n            data: request.parameters,\n            headers: {\n                'App-Token': appToken,\n                'Respoke-SDK': sdkHeaderValue }\n        }), handleResponse);\n    }\n\n    /**\n     * Construct an API call and return the formatted response and errors. The 'success'\n     * attribute indicates the success or failure of the API call. The 'response' attribute\n     * is an associative array constructed by json.decode. The 'error' attribute is a message.\n     * If the API call is successful but the server returns invalid JSON, error will be\n     * \"Invalid JSON.\" and response will be the unchanged content of the response body.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.call\n     * @private\n     * @param {object} params\n     * @param {string} params.httpMethod\n     * @param {string} params.objectId\n     * @param {string} params.path\n     * @param {object} params.parameters\n     * @returns {Promise}\n     */\n    function call(params) {\n        /* Params go in the URI for GET, DELETE, same format for\n         * POST and PUT, but they must be sent separately after the\n         * request is opened. */\n        var deferred = Q.defer();\n        var paramString = null;\n        var uri = null;\n        var response = {\n            body: null,\n            statusCode: null\n        };\n        var start = now();\n\n        uri = clientSettings.baseURL + params.path;\n\n        if (!params) {\n            deferred.reject(new Error('No params.'));\n            return;\n        }\n\n        if (!params.httpMethod) {\n            deferred.reject(new Error('No HTTP method.'));\n            return;\n        }\n\n        if (!params.path) {\n            deferred.reject(new Error('No request path.'));\n            return;\n        }\n\n        if (params.urlParams) {\n            uri = template.parse(uri).expand(params.urlParams);\n        }\n\n        if (['GET', 'DELETE'].indexOf(params.httpMethod) > -1) {\n            uri += makeParamString(params.parameters);\n        }\n\n        xhr.open(params.httpMethod, uri);\n        xhr.setRequestHeader('Respoke-SDK', sdkHeaderValue);\n        if (appToken) {\n            xhr.setRequestHeader(\"App-Token\", appToken);\n        }\n        if (['POST', 'PUT'].indexOf(params.httpMethod) > -1) {\n            paramString = JSON.stringify(params.parameters);\n            if (paramString.length > bodySizeLimit) {\n                deferred.reject(new Error('Request body exceeds maximum size of ' + bodySizeLimit + ' bytes'));\n                return;\n            }\n            xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n        } else if (['GET', 'DELETE'].indexOf(params.httpMethod) === -1) {\n            deferred.reject(new Error('Illegal HTTP request method ' + params.httpMethod));\n            return;\n        }\n        log.debug('request', {\n            method: params.httpMethod,\n            uri: uri,\n            params: paramString\n        });\n\n        try {\n            xhr.send(paramString);\n        } catch (err) {\n            deferred.reject(err);\n            return;\n        }\n\n        xhr.onreadystatechange = function () {\n            var durationMillis = now() - start;\n            var limit;\n            var unit;\n\n            if (this.readyState !== 4) {\n                return;\n            }\n\n            if (this.status === 0) {\n                deferred.reject(new Error(\"Status is 0: Incomplete request, SSL error, or CORS error.\"));\n                return;\n            }\n\n            response.statusCode = this.status;\n            response.headers = getAllResponseHeaders(this);\n            response.uri = uri;\n            response.params = params.parameters;\n            response.error = errors[this.status];\n\n            if (this.response) {\n                try {\n                    response.body = JSON.parse(this.response);\n                } catch (e) {\n                    response.body = this.response;\n                    response.error = \"Invalid JSON.\";\n                }\n            }\n\n            log.debug('response', {\n                method: params.httpMethod,\n                durationMillis: durationMillis,\n                response: response\n            });\n\n            if ([200, 204, 205, 302, 401, 403, 404, 418].indexOf(this.status) > -1) {\n                deferred.resolve(response);\n            } else if (this.status === 429) {\n                unit = getResponseHeader(this, 'RateLimit-Time-Units');\n                limit = getResponseHeader(this, 'RateLimit-Limit');\n                deferred.reject(buildResponseError(response, \"Rate limit of \" + limit + \"/\" + unit +\n                    \" exceeded. Try again in 1 \" + unit + \".\"));\n            } else {\n                deferred.reject(buildResponseError(response, 'unexpected response code ' + this.status));\n            }\n        };\n\n        return deferred.promise;\n    }\n\n    function isSuspensionUnauthorizedResponse(response) {\n        return (response.statusCode === 401) && response.body && response.body.details &&\n            (typeof response.body.details.message === 'string') &&\n            (response.body.details.message.indexOf('suspended') > -1);\n    }\n\n    function isBillingSuspensionUnauthorizedResponse(response) {\n        return isSuspensionUnauthorizedResponse(response) &&\n            (typeof response.body.details.reason === 'string') &&\n            (response.body.details.reason.indexOf('billing suspension') > -1);\n    }\n\n    /**\n     * Turn key/value and key/list pairs into an HTTP URL parameter string.\n     * var1=value1&var2=value2,value3,value4\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.makeParamString\n     * @private\n     * @param {object} params - Arbitrary collection of strings and arrays to serialize.\n     * @returns {string}\n     */\n    function makeParamString(params) {\n        var strings = [];\n        if (!params) {\n            return '';\n        }\n\n        Object.keys(params).forEach(function formatParam(name) {\n            var value = params[name];\n            /* Skip objects -- We won't know how to name these. */\n            if (value instanceof Array) {\n                strings.push([name, value.join(',')].join('='));\n            } else if (typeof value !== 'object' && typeof value !== 'function') {\n                strings.push([name, value].join('='));\n            }\n        });\n\n        if (strings.length > 0) {\n            return '?' + strings.join('&');\n        } else {\n            return '';\n        }\n    }\n\n    /**\n     * Tries to retrieve a single header value from an XHR response. If the header is disallowed,\n     * or does not exist, will return null. Otherwise returns the value of the header.\n     *\n     * The CORS spec does not define what the browser should do in the case of a request for a\n     * disallowed header, but at least Chrome throws an exception.\n     *\n     * @param {object} xhrResponse The response of an XMLHttpRequest\n     * @param {string} header The name of the header to retrieve the value for\n     * @returns {string|null} The value(s) of the header, or null if disallowed or unavailable.\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getResponseHeader\n     * @private\n     */\n    function getResponseHeader(xhrResponse, header) {\n        try {\n            return xhrResponse.getResponseHeader(header);\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     * Retrieves all headers from an XHR response as key/val pairs\n     *\n     * @param {object} xhrResponse The response of an XMLHttpRequest\n     * @returns {*} the key/val pairs of the response headers\n     * @memberof! respoke.SignalingChannel\n     * @method respoke.SignalingChannel.getAllResponseHeaders\n     * @private\n     */\n    function getAllResponseHeaders(xhrResponse) {\n        var result = {};\n        var headers;\n        var pairs;\n\n        headers = xhrResponse.getAllResponseHeaders();\n        if (!headers) {\n            return result;\n        }\n\n        // 1 header per line (cr+lf)\n        pairs = headers.split('\\u000d\\u000a');\n        pairs.forEach(function (pair) {\n            var key;\n            var val;\n\n            // key separated from value by ': '\n            // value may contain ': ', so using indexOf instead of split\n            var index = pair.indexOf('\\u003a\\u0020');\n            if (index > 0) {\n                key = pair.substring(0, index);\n                val = pair.substring(index + 2);\n                result[key] = val;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Creates an Error with the supplied `message` and, if available, the `Request-Id` header\n     * from the supplied `response`.\n     *\n     * @param {object} res\n     * @param {object} [res.headers]\n     * @param {string} [res.headers.Request-Id] The requestId to append to the Error message\n     * @param {string} message The message the Error should be constructed with\n     * @returns {Error} the constructed Error object\n     * @memberof respoke.SignalingChannel\n     * @method respoke.SignalingChannel.buildResponseError\n     * @api private\n     */\n    function buildResponseError(res, message) {\n        var requestId = res && res.headers && res.headers['Request-Id'];\n        if (requestId) {\n            message += ' [Request-Id: ' + requestId + ']';\n        }\n\n        return new Error(message);\n    }\n\n    return that;\n}; // End respoke.SignalingChannel\n/**\n * Handle an error that resulted from a method call.\n * @callback respoke.SignalingChannel.errorHandler\n * @params {Error} err\n */\n/**\n * Handle sending successfully.\n * @callback respoke.SignalingChannel.sendHandler\n */\n/**\n * Receive a group.\n * @callback respoke.SignalingChannel.groupHandler\n * @param {respoke.Group}\n */\n/**\n * Receive a list of groups.\n * @callback respoke.SignalingChannel.groupListHandler\n * @param {Array}\n */\n/**\n * Receive a list of TURN credentials.\n * @callback respoke.SignalingChannel.turnSuccessHandler\n * @param {Array}\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/signalingChannel.js\n ** module id = 15\n ** module chunks = 0\n **/","(function (root, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else {\n        root.urltemplate = factory();\n    }\n}(this, function () {\n  /**\n   * @constructor\n   */\n  function UrlTemplate() {\n  }\n\n  /**\n   * @private\n   * @param {string} str\n   * @return {string}\n   */\n  UrlTemplate.prototype.encodeReserved = function (str) {\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n      if (!/%[0-9A-Fa-f]/.test(part)) {\n        part = encodeURI(part);\n      }\n      return part;\n    }).join('');\n  };\n\n  /**\n   * @private\n   * @param {string} operator\n   * @param {string} value\n   * @param {string} key\n   * @return {string}\n   */\n  UrlTemplate.prototype.encodeValue = function (operator, value, key) {\n    value = (operator === '+' || operator === '#') ? this.encodeReserved(value) : encodeURIComponent(value);\n\n    if (key) {\n      return encodeURIComponent(key) + '=' + value;\n    } else {\n      return value;\n    }\n  };\n\n  /**\n   * @private\n   * @param {*} value\n   * @return {boolean}\n   */\n  UrlTemplate.prototype.isDefined = function (value) {\n    return value !== undefined && value !== null;\n  };\n\n  /**\n   * @private\n   * @param {string}\n   * @return {boolean}\n   */\n  UrlTemplate.prototype.isKeyOperator = function (operator) {\n    return operator === ';' || operator === '&' || operator === '?';\n  };\n\n  /**\n   * @private\n   * @param {Object} context\n   * @param {string} operator\n   * @param {string} key\n   * @param {string} modifier\n   */\n  UrlTemplate.prototype.getValues = function (context, operator, key, modifier) {\n    var value = context[key],\n        result = [];\n\n    if (this.isDefined(value) && value !== '') {\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        value = value.toString();\n\n        if (modifier && modifier !== '*') {\n          value = value.substring(0, parseInt(modifier, 10));\n        }\n\n        result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n      } else {\n        if (modifier === '*') {\n          if (Array.isArray(value)) {\n            value.filter(this.isDefined).forEach(function (value) {\n              result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));\n            }, this);\n          } else {\n            Object.keys(value).forEach(function (k) {\n              if (this.isDefined(value[k])) {\n                result.push(this.encodeValue(operator, value[k], k));\n              }\n            }, this);\n          }\n        } else {\n          var tmp = [];\n\n          if (Array.isArray(value)) {\n            value.filter(this.isDefined).forEach(function (value) {\n              tmp.push(this.encodeValue(operator, value));\n            }, this);\n          } else {\n            Object.keys(value).forEach(function (k) {\n              if (this.isDefined(value[k])) {\n                tmp.push(encodeURIComponent(k));\n                tmp.push(this.encodeValue(operator, value[k].toString()));\n              }\n            }, this);\n          }\n\n          if (this.isKeyOperator(operator)) {\n            result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n          } else if (tmp.length !== 0) {\n            result.push(tmp.join(','));\n          }\n        }\n      }\n    } else {\n      if (operator === ';') {\n        result.push(encodeURIComponent(key));\n      } else if (value === '' && (operator === '&' || operator === '?')) {\n        result.push(encodeURIComponent(key) + '=');\n      } else if (value === '') {\n        result.push('');\n      }\n    }\n    return result;\n  };\n\n  /**\n   * @param {string} template\n   * @return {function(Object):string}\n   */\n  UrlTemplate.prototype.parse = function (template) {\n    var that = this;\n    var operators = ['+', '#', '.', '/', ';', '?', '&'];\n\n    return {\n      expand: function (context) {\n        return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n          if (expression) {\n            var operator = null,\n                values = [];\n\n            if (operators.indexOf(expression.charAt(0)) !== -1) {\n              operator = expression.charAt(0);\n              expression = expression.substr(1);\n            }\n\n            expression.split(/,/g).forEach(function (variable) {\n              var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n              values.push.apply(values, that.getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n            });\n\n            if (operator && operator !== '+') {\n              var separator = ',';\n\n              if (operator === '?') {\n                separator = '&';\n              } else if (operator !== '#') {\n                separator = operator;\n              }\n              return (values.length !== 0 ? operator : '') + values.join(separator);\n            } else {\n              return values.join(',');\n            }\n          } else {\n            return that.encodeReserved(literal);\n          }\n        });\n      }\n    };\n  };\n\n  return new UrlTemplate();\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/url-template/lib/url-template.js\n ** module id = 16\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar respoke = require('./respoke');\nvar log = respoke.log;\n\n/**\n * A direct connection via RTCDataChannel, including state and path negotation.\n * @class respoke.DirectConnection\n * @constructor\n * @augments respoke.EventEmitter\n * @param {string} params\n * @param {string} params.instanceId - client id\n * @param {respoke.Call} params.call - The call that is handling state for this direct connection.\n * @param {boolean} [params.forceTurn] - If true, force the data to flow through relay servers instead of allowing\n * it to flow peer-to-peer. The relay acts like a blind proxy.\n * @param {string} params.connectionId - The connection ID of the remoteEndpoint.\n * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n * @param {function} params.signalReport - Signaling action from SignalingChannel.\n * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n * @param {respoke.DirectConnection.onStart} [params.onStart] - Callback for when setup of the direct connection\n * begins. The direct connection will not be open yet.\n * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors that happen during\n * direct connection setup or media renegotiation.\n * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for closing the direct connection.\n * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for opening the direct connection.\n * @param {respoke.DirectConnection.onAccept} [params.onAccept] - Callback for when the user accepts the request\n * for a direct connection and setup is about to begin.\n * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for incoming messages. Not usually\n * necessary to listen to this event if you are already listening to respoke.Endpoint#message.\n * @returns {respoke.DirectConnection}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Client\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n\n    /**\n     * A name to identify this class\n     * @memberof! respoke.DirectConnection\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.DirectConnection';\n    /**\n     * The unique identifier of the direct connection.\n     *\n     * @memberof! respoke.DirectConnection\n     * @name id\n     * @type {string}\n     */\n    that.id = respoke.makeGUID();\n\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name call\n     * @type {respoke.Call}\n     */\n    if (!that.call.caller) {\n        that.call.caller = false;\n    }\n\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name dataChannel\n     * @type {RTCDataChannel}\n     * @private\n     */\n    var dataChannel = null;\n\n    /**\n     * @memberof! respoke.DirectConnection\n     * @name pc\n     * @type {RTCPeerConnection}\n     * @private\n     */\n    var pc = params.pc;\n    delete params.pc;\n\n    /**\n     * When the datachannel is availble, we need to attach the callbacks. The event this function is attached to\n     * only fires for the callee.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.listenDataChannel\n     * @param {respoke.Event} evt\n     * @private\n     */\n    function listenDataChannel(evt) {\n        dataChannel = evt.channel;\n        dataChannel.onerror = onDataChannelError;\n        dataChannel.onmessage = onDataChannelMessage;\n        if (dataChannel.readyState === 'open') {\n            dataChannel.onopen = null;\n            onDataChannelOpen();\n        } else {\n            dataChannel.onopen = onDataChannelOpen;\n        }\n    }\n\n    /**\n     * Register any event listeners passed in as callbacks\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.saveParameters\n     * @param {object} params\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for when the direct connection\n     * is closed.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for when the direct connection\n     * is open.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for incoming messages.\n     * @param {respoke.DirectConnection.onError} [params.onError] - Callback for errors setting up the direct\n     * connection.\n     * @param {respoke.DirectConnection.onStart} [params.onStart] - Callback for when the direct connection\n     * is being set up. The direct connection will not be open yet.\n     * @param {boolean} [params.forceTurn] - If true, force the data to flow through relay servers instead of allowing\n     * it to flow peer-to-peer. The relay acts like a blind proxy.\n     * @private\n     */\n    function saveParameters(params) {\n        /**\n         * The direct connection is open.\n         * @event respoke.DirectConnection#open\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.listen('open', params.onOpen);\n        /**\n         * The direct connection is closed.\n         * @event respoke.DirectConnection#close\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.listen('close', params.onClose);\n        /**\n         * Incoming message on this direct connection.\n         * @event respoke.DirectConnection#message\n         * @type {respoke.Event}\n         * @property {respoke.TextMessage} message\n         * @property {respoke.Endpoint} endpoint\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.listen('message', params.onMessage);\n        // documented elsewhere\n        that.listen('start', params.onStart);\n        /**\n         * An error occurred while setting up the direct connection.\n         * @event respoke.DirectConnection#error\n         * @type {respoke.Event}\n         * @property {string} reason - A human-readable description of the error.\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.listen('error', params.onError);\n        pc.listen('direct-connection', listenDataChannel, true);\n        pc.listen('stats', function fireStats(evt) {\n            /**\n             * This event is fired every time statistical information about the direct connection\n             * becomes available.\n             * @event respoke.DirectConnection#stats\n             * @type {respoke.Event}\n             * @property {object} stats - an object with stats in it.\n             * @property {respoke.DirectConnection} target\n             * @property {string} name - the event name.\n             */\n            that.fire('stats', {stats: evt.stats});\n        }, true);\n\n    }\n    saveParameters(params);\n\n    delete that.onOpen;\n    delete that.onClose;\n    delete that.onMessage;\n\n    /**\n     * Return media stats. Since we have to wait for both the answer and offer to be available before starting\n     * statistics, we'll return a promise for the stats object.\n     *\n     *     directConnection.getStats({\n     *         onStats: function (evt) {\n     *             console.log('Stats', evt.stats);\n     *         }\n     *     }).done(function () {\n     *         console.log('Stats started.');\n     *     }, function (err) {\n     *         console.log('Direct connection is already closed.');\n     *     });\n     *\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.getStats\n     * @returns {Promise<object>|undefined}\n     * @param {object} params\n     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive the\n     * stats if the Respoke stats module is loaded. If no callback is provided, the connection's report will\n     * contain stats but the developer will not receive them on the client-side.\n     * @param {respoke.DirectConnection.statsSuccessHandler} [params.onSuccess] - Success handler for this\n     * invocation of this method only.\n     * @param {respoke.DirectConnection.errorHandler} [params.onError] - Error handler for this invocation of\n     * this method only.\n     */\n    that.getStats = function (params) {\n        if (pc && pc.getStats) {\n            that.listen('stats', params.onStats);\n            delete params.onStats;\n            return pc.getStats(params);\n        }\n        return null;\n    };\n\n    if (!respoke.MediaStats) {\n        delete that.getStats;\n    }\n\n    /**\n     * Detect datachannel errors for internal state.\n     * @memberof! respoke.DirectConnection\n     * @private\n     * @method respoke.DirectConnection.onDataChannelError\n     */\n    function onDataChannelError(error) {\n        /**\n         * Indicate that an error has occurred setting up the direct connection.\n         * @event respoke.DirectConnection#error\n         * @type {respoke.Event}\n         * @property {object} error\n         * @property {respoke.DirectConnection} directConnection\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('error', {\n            error: error\n        });\n        that.close();\n    }\n\n    /**\n     * Receive and route messages to the Endpoint.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.onDataChannelMessage\n     * @private\n     * @param {MessageEvent}\n     * @fires respoke.DirectConnection#message\n     */\n    function onDataChannelMessage(evt) {\n        var message;\n        try {\n            message = JSON.parse(evt.data);\n        } catch (e) {\n            message = evt.data;\n        }\n        /**\n         * A message has been received over the direct connection.\n         * @event respoke.Endpoint#message\n         * @type {respoke.Event}\n         * @property {object} message\n         * @property {respoke.DirectConnection} directConnection\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.call.remoteEndpoint.fire('message', {\n            message: message,\n            directConnection: that\n        });\n        /**\n         * A message has been received over the direct connection.\n         * @event respoke.DirectConnection#message\n         * @type {respoke.Event}\n         * @property {object} message\n         * @property {respoke.Endpoint} endpoint\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('message', {\n            message: message,\n            endpoint: that.call.remoteEndpoint\n        });\n    }\n\n    /**\n     * Detect when the channel is open.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.onDataChannelOpen\n     * @private\n     * @param {MessageEvent}\n     * @fires respoke.DirectConnection#open\n     */\n    function onDataChannelOpen(evt) {\n        //dataChannel = evt.target || evt.channel;\n        /**\n         * The direct connection is open.\n         * @event respoke.DirectConnection#open\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('open');\n    }\n\n    /**\n     * Detect when the channel is closed.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.onDataChannelClose\n     * @private\n     * @param {MessageEvent}\n     * @fires respoke.DirectConnection#close\n     */\n    function onDataChannelClose(evt) {\n        //dataChannel = evt.target || evt.channel;\n        /**\n         * The direct connection is closed.\n         * @event respoke.DirectConnection#close\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('close');\n    }\n\n    /**\n     * Create the datachannel. For the caller, set up all the handlers we'll need to keep track of the\n     * datachannel's state and to receive messages.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.createDataChannel\n     * @private\n     */\n    function createDataChannel() {\n        dataChannel = pc.createDataChannel(\"respokeDataChannel\");\n        dataChannel.binaryType = 'arraybuffer';\n        dataChannel.onerror = onDataChannelError;\n        dataChannel.onmessage = onDataChannelMessage;\n        dataChannel.onopen = onDataChannelOpen;\n\n        /**\n         * The direct connection setup has begun. This does NOT mean it's ready to send messages yet. Listen to\n         * DirectConnection#open for that notification.\n         * @event respoke.DirectConnection#start\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('start');\n    }\n\n    /**\n     * Start the process of obtaining media. saveParameters will only be meaningful for the callee,\n     * since the library calls this method for the caller. Developers will use this method to pass in\n     * callbacks for the callee.\n     *\n     *     directConnection.accept({\n     *         onOpen: function (evt) {}\n     *     });\n     *\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.accept\n     * @fires respoke.DirectConnection#accept\n     * @param {object} params\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen]\n     * @param {respoke.DirectConnection.onClose} [params.onClose]\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage]\n     */\n    that.accept = function (params) {\n        params = params || {};\n        log.debug('DirectConnection.accept');\n        saveParameters(params);\n\n        log.debug(\"I am \" + (pc.state.caller ? '' : 'not ') + \"the caller.\");\n\n        if (pc.state.caller === true) {\n            createDataChannel();\n        }\n        that.call.answer();\n\n        /**\n         * The request to open a direct connection has been accepted.\n         * @event respoke.DirectConnection#accept\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('accept');\n    };\n\n    /**\n     * Tear down the connection.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.close\n     * @fires respoke.DirectConnection#close\n     */\n    that.close = function (params) {\n        params = params || {};\n        log.debug(\"DirectConnection.close\");\n\n        if (that.call && that.call.remoteEndpoint) {\n            that.call.remoteEndpoint.directConnection = null;\n        }\n\n        if (dataChannel) {\n            dataChannel.close();\n        }\n\n        /**\n         * The direct connection has been closed.\n         * @event respoke.DirectConnection#close\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.DirectConnection} target\n         */\n        that.fire('close');\n\n        that.ignore();\n\n        if (that.call && params.skipRemove !== true) {\n            that.call.removeDirectConnection();\n        }\n\n        dataChannel = null;\n        that.call = null;\n        pc = null;\n    };\n\n    /**\n     * Send a message over the datachannel in the form of a JSON-encoded plain old JavaScript object. Only one\n     * attribute may be given: either a string 'message' or an object 'object'.\n     * **Using callbacks** by passing `params.onSuccess` or `params.onError` will disable promises.\n     *\n     *     directConnection.sendMessage({\n     *         message: \"And they say HTTP is stateless!\"\n     *     });\n     *\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.sendMessage\n     * @param {object} params\n     * @param {string} [params.message] - The message to send.\n     * @param {object} [params.object] - An object to send.\n     * @param {respoke.DirectConnection.sendHandler} [params.onSuccess] - Success handler for this invocation\n     * of this method only.\n     * @param {respoke.DirectConnection.errorHandler} [params.onError] - Error handler for this invocation\n     * of this method only.\n     * @returns {Promise|undefined}\n     */\n    that.sendMessage = function (params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        if (that.isActive()) {\n            dataChannel.send(JSON.stringify(params.object || {\n                message: params.message\n            }));\n            deferred.resolve();\n        } else {\n            deferred.reject(new Error(\"dataChannel not in an open state.\"));\n        }\n        return retVal;\n    };\n\n    /**\n     * Expose close as reject for approve/reject workflow.\n     *\n     *     client.listen('direct-connection, function (evt) {\n     *         if (iDontLikeThisPerson()) {\n     *             evt.directConnection.reject();\n     *         }\n     *     });\n     *\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.reject\n     * @param {boolean} signal - Optional flag to indicate whether to send or suppress sending\n     * a hangup signal to the remote side.\n     */\n    that.reject = that.close;\n\n    /**\n     * Indicate whether a datachannel is being setup or is in progress.\n     * @memberof! respoke.DirectConnection\n     * @method respoke.DirectConnection.isActive\n     * @returns {boolean}\n     */\n    that.isActive = function () {\n        // Why does pc.iceConnectionState not transition into 'connected' even though media is flowing?\n        //return (pc && pc.isActive() && dataChannel && dataChannel.readyState === 'open');\n        return (dataChannel && dataChannel.readyState === 'open');\n    };\n\n    return that;\n}; // End respoke.DirectConnection\n\n/**\n * Called when the direct connection is closed.  This callback is called every time respoke.DirectConnection#close\n * fires.\n * @callback respoke.DirectConnection.onClose\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Called when the setup of the direct connection has begun. The direct connection will not be open yet. This\n * callback is called every time respoke.DirectConnection#start fires.\n * @callback respoke.DirectConnection.onStart\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Called when the direct connection is opened.  This callback is called every time respoke.DirectConnection#open\n * fires.\n * @callback respoke.DirectConnection.onOpen\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Called when a message is received over the direct connection.  This callback is called every time\n * respoke.DirectConnection#message fires.\n * @callback respoke.DirectConnection.onMessage\n * @param {respoke.Event} evt\n * @param {object} evt.message\n * @param {respoke.Endpoint} evt.endpoint\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Handle an error that resulted from a specific method call. This handler will not fire more than once.\n * @callback respoke.DirectConnection.errorHandler\n * @param {Error} err\n */\n/**\n * When a call is in setup or media renegotiation happens. This callback will be called every time\n * respoke.DirectConnection#error.\n * @callback respoke.DirectConnection.onError\n * @param {respoke.Event} evt\n * @param {boolean} evt.reason - A human-readable description of the error.\n * @param {string} evt.name - the event name.\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Called when the callee accepts the direct connection. This callback is called every time\n * respoke.DirectConnection#accept is fired.\n * @callback respoke.DirectConnection.onAccept\n * @param {respoke.Event} evt\n * @param {respoke.DirectConnection} evt.target\n */\n/**\n * Handle the successful kick-off of stats on a call.\n * @callback respoke.DirectConnection.statsSuccessHandler\n * @param {respoke.Event} evt\n * @param {object} evt.stats - an object with stats in it.\n * @param {respoke.DirectConnection} evt.target\n * @param {string} evt.name - the event name.\n */\n/**\n * Handle sending successfully.\n * @callback respoke.DirectConnection.sendHandler\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/directConnection.js\n ** module id = 17\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar respoke = require('./respoke');\nvar log = respoke.log;\nvar Statechart = require('statechart');\n\n/**\n * WebRTC PeerConnection. This class handles all the state and connectivity for Call and DirectConnection.\n * This class cannot be used alone, but is instantiated by and must be given media by either Call, DirectConnection,\n * or the not-yet-implemented ScreenShare.\n * @class respoke.PeerConnection\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId - client id\n * @param {boolean} [params.forceTurn] - If true, delete all 'host' and 'srvflx' candidates and send only 'relay'\n * candidates.\n * @param {boolean} [params.disableTurn] - If true, delete all 'relay' candidates and send only 'host' and 'srvflx'\n * candidates.\n * @param {respoke.Call} params.call\n * @param {string} params.connectionId - The connection ID of the remoteEndpoint.\n * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n * @param {function} params.signalModify - Signaling action from SignalingChannel.\n * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n * @param {function} params.signalReport - Signaling action from SignalingChannel.\n * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n * @param {respoke.Call.onHangup} [params.onHangup] - Callback for the developer to be notified about hangup.\n * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback for the developer to receive\n * statistics about the call. This is only used if call.getStats() is called and the stats module is loaded.\n * @param {object} [params.pcOptions]\n * @param {object} [params.offerOptions]\n * @returns {respoke.PeerConnection}\n */\n\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.PeerConnection';\n\n    /**\n     * Whether or not we will send a 'hangup' signal to the other side during hangup.\n     * @memberof! respoke.PeerConnection\n     * @name toSendHangup\n     * @type {respoke.Endpoint}\n     */\n    var toSendHangup;\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @private\n     * @name pc\n     * @type RTCPeerConnection\n     * @desc The RTCPeerConnection as provided by the browser API. All internal state, networking functionality, and\n     * raw data transfer occurs within the PeerConnection.\n     */\n    var pc = null;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name defModify\n     * @private\n     * @type {Promise}\n     * @desc Used in the state machine to trigger methods or functions whose execution depends on the reception,\n     * handling, or sending of some information.\n     */\n    var defModify;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name previewLocalMedia\n     * @private\n     * @type {respoke.Call.previewLocalMedia}\n     * @desc A callback provided by the developer that we'll call after receiving local media and before\n     * approve() is called.\n     */\n    var previewLocalMedia = typeof params.previewLocalMedia === 'function' ? params.previewLocalMedia : undefined;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name candidateReceivingQueue\n     * @private\n     * @type {array}\n     * @desc An array to save candidates between offer and answer so that both parties can process them simultaneously.\n     */\n    var candidateReceivingQueue = respoke.queueFactory();\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name client\n     * @private\n     * @type {respoke.Client}\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalOffer\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalOffer = params.signalOffer;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalConnected\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalConnected = params.signalConnected;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalModify\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalModify = params.signalModify;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalAnswer\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalAnswer = params.signalAnswer;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalHangup\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalHangup = respoke.callOnce(params.signalHangup);\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalReport\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed by the signaling channel.\n     */\n    var signalReport = params.signalReport;\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalCandidateOrig\n     * @private\n     * @type {function}\n     * @desc A temporary function saved from params in order to construct the candidate signaling function.\n     */\n    var signalCandidateOrig = params.signalCandidate;\n\n    /**\n     * The RTCDTMFSender as provided by the browser API.\n     * @memberof! respoke.PeerConnection\n     * @private\n     * @name digitSender\n     * @type RTCDigitSender\n     */\n\n    var digitSender = null;\n\n    /**\n     * A temporary variable to define if we're in the middle of cancelling any tones on a peer connection\n     * @memberof! respoke.PeerConnection\n     * @private\n     * @name cancellingTones\n     * @type boolean\n     */\n\n    var cancellingTones = false;\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name signalCandidates\n     * @private\n     * @type {function}\n     * @desc A signaling function constructed from the one passed to us by the signaling channel with additions\n     * to facilitate candidate logging.\n     */\n\n    function signalCandidates(params) {\n        if (!pc) {\n            return Q.resolve();\n        }\n\n        params.call = that.call;\n        that.report.candidatesSent = that.report.candidatesSent.concat(params.iceCandidates);\n\n        return signalCandidateOrig(params);\n    }\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name offerOptions\n     * @private\n     * @type {object}\n     */\n    var offerOptions = params.offerOptions || {};\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name pcOptions\n     * @private\n     * @type {object}\n     */\n    var pcOptions = params.pcOptions || {\n        optional: [\n            { DtlsSrtpKeyAgreement: true },\n            { RtpDataChannels: false }\n        ]\n    };\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name report\n     * @type {object}\n     */\n    that.report = {\n        callStarted: 0,\n        callStopped: 0,\n        callerendpoint: that.call.caller ? client.name : that.call.remoteEndpoint.id,\n        callerconnection: that.call.caller ? client.id : that.call.connectionId,\n        calleeendpoint: that.call.caller ? that.call.remoteEndpoint.id : client.id,\n        calleeconnection: that.call.caller ? that.call.connectionId : client.connectionId,\n        sessionId: that.call.id,\n        lastSDPString: '',\n        sdpsSent: [],\n        sdpsReceived: [],\n        candidatesSent: [],\n        candidatesReceived: [],\n        userAgent: navigator.userAgent,\n        os: navigator.platform\n    };\n\n    /**\n     * Start the process of network and media negotiation. Called after local video approved.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.initOffer\n     * @fires respoke.PeerConnection#initOffer\n     * @private\n     */\n    function initOffer() {\n        if (!pc) {\n            return;\n        }\n\n        if (that.state.receiveOnly) {\n            makeOptionsReceiveOnly(offerOptions);\n        }\n\n        if (that.state.sendOnly) {\n            makeOptionsSendOnly(offerOptions);\n        }\n\n        log.info('creating offer', offerOptions);\n\n        pc.createOffer(function saveOfferAndSend(oSession) {\n            oSession.type = 'offer';\n            if (!pc) {\n                return;\n            }\n            log.debug('setting and sending offer', oSession);\n            that.report.sdpsSent.push(oSession);\n\n            pc.setLocalDescription(oSession, function successHandler(p) {\n                oSession.type = 'offer';\n                signalOffer({\n                    call: that.call,\n                    sessionDescription: oSession,\n                    onSuccess: function () {\n                        that.state.sentSDP = true;\n                        localCandidatesFSM.dispatch('ready');\n                    },\n                    onError: function (err) {\n                        log.error('offer could not be sent', err);\n                        that.call.hangup({signal: false});\n                    }\n                });\n            }, function errorHandler(p) {\n                var errorMessage = 'Error calling setLocalDescription on offer I created.';\n                var err = new Error(errorMessage);\n                log.error(errorMessage, p);\n                /**\n                 * This event is fired on errors that occur during call setup or media negotiation.\n                 * @event respoke.Call#error\n                 * @type {respoke.Event}\n                 * @property {string} reason - A human readable description about the error.\n                 * @property {respoke.Call} target\n                 * @property {string} name - the event name.\n                 */\n                that.call.fire('error', {\n                    message: err.message\n                });\n            });\n        }, function errorHandler(e) {\n            log.error('createOffer failed', e);\n        }, offerOptions);\n    }\n\n    function makeOptionsReceiveOnly(options) {\n        if (navigator.webkitGetUserMedia) {\n            options.mandatory = {\n                OfferToReceiveVideo: true,\n                OfferToReceiveAudio: true,\n                OfferToSendVideo: false,\n                OfferToSendAudio: false\n            };\n        } else {\n            options.offerToReceiveVideo = true;\n            options.offerToReceiveAudio = true;\n            options.offerToSendVideo = false;\n            options.offerToSendAudio = false;\n        }\n    }\n\n    function makeOptionsSendOnly(options) {\n        if (navigator.webkitGetUserMedia) {\n            options.mandatory = {\n                OfferToSendVideo: true,\n                OfferToSendAudio: true,\n                OfferToReceiveVideo: false,\n                OfferToReceiveAudio: false\n            };\n        } else {\n            options.offerToSendVideo = true;\n            options.offerToSendAudio = true;\n            options.offerToReceiveVideo = false;\n            options.offerToReceiveAudio = false;\n        }\n    }\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name localCandidates\n     * @private\n     * @type {array}\n     * @desc An array to save local candidates, to retransmit for peers that\n     *       don't support trickle ice.\n     */\n    var localCandidates = [];\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name localCandidatesComplete\n     * @private\n     * @type {boolean}\n     * @desc Whether all the local candidates have been received.\n     */\n    var localCandidatesComplete = false;\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name localCandidatesSent\n     * @private\n     * @type {number}\n     * @desc The number of local candidates that have been sent to the remote.\n     */\n    var localCandidatesSent = 0;\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name localCandidatesSent\n     * @private\n     * @type {Statechart}\n     * @desc FSM for managing local ICE candidates.\n     */\n    var localCandidatesFSM;\n\n    /**\n     * @memberof! respoke.PeerConnection\n     * @name localCandidatesTimeout\n     * @private\n     * @type {number}\n     * @desc timeoutId for the ice gathering timeout. Fires when no ice candidate\n     *  received in a specified period of time, to speed up finalCandidates signal.\n     */\n    var localCandidatesTimeout;\n\n    /**\n     * The number of local candidates that have not yet been sent.\n     * @returns {number}\n     * @private\n     */\n    function localCandidatesRemaining() {\n        return localCandidates.length - localCandidatesSent;\n    }\n\n    /**\n     * Throw another local ICE candidate on the pile\n     * @param params\n     * @param params.candidate ICE candidate\n     * @private\n     */\n    function collectLocalIceCandidate(params) {\n        if (params && params.candidate) {\n            localCandidates.push(params.candidate);\n        }\n    }\n\n    /**\n     * Send the remaining local candidates that have not yet been sent.\n     * @private\n     */\n    function sendRemainingCandidates(params) {\n        var remainingCandidates = localCandidates.slice(localCandidatesSent);\n        var signalParams = {iceCandidates: remainingCandidates};\n\n        localCandidatesSent += remainingCandidates.length;\n\n        if (localCandidatesComplete && !(params && params.suppressFinalCandidates)) {\n            signalParams.finalCandidates = localCandidates;\n        }\n\n        if (!signalParams.iceCandidates.length && !signalParams.finalCandidates) {\n            // Nothing to send. Happens if we receive the null \"end of ice\" ice candidate\n            // after we've already sent the finalCandidates signal.\n            return;\n        }\n\n        signalCandidates(signalParams)\n            .finally(function () {\n                localCandidatesFSM.dispatch('iceSent');\n            }).done();\n    }\n\n    localCandidatesFSM = respoke.Class({\n        that: Object.create(Statechart),\n        initialState: 'buffering',\n        states: {\n            buffering: {\n                localIceCandidate: {action: collectLocalIceCandidate},\n                ready: [{\n                    guard: function () {\n                        return localCandidatesRemaining() === 0 && localCandidatesComplete;\n                    },\n                    target: 'finished',\n                    action: function () {\n                        log.error('ice completed without any candidates');\n                    }\n                }, {\n                    guard: function () {\n                        return localCandidatesRemaining() === 0 && !localCandidatesComplete;\n                    },\n                    target: 'waiting'\n                }, {\n                    guard: function () {\n                        return localCandidatesRemaining() !== 0;\n                    },\n                    target: 'sending',\n                    action: sendRemainingCandidates\n                }]\n            },\n            sending: {\n                localIceCandidate: {action: collectLocalIceCandidate},\n                iceSent: [{\n                    guard: function () {\n                        return localCandidatesRemaining() === 0 && localCandidatesComplete;\n                    },\n                    target: 'finished'\n                }, {\n                    guard: function () {\n                        return localCandidatesRemaining() === 0 && !localCandidatesComplete;\n                    },\n                    target: 'waiting'\n                }, {\n                    guard: function () {\n                        return localCandidatesRemaining() !== 0;\n                    },\n                    action: sendRemainingCandidates\n                }]\n            },\n            waiting: {\n                entry: {\n                    action: function () {\n                        localCandidatesTimeout = setTimeout(function () {\n                            log.debug('ice gathering has timed out. sending final candidate signal.');\n                            localCandidatesComplete = true;\n                            localCandidatesFSM.dispatch('localIceCandidate');\n                        }, 2000);\n                    }\n                },\n                exit: {\n                    action: function () {\n                        clearTimeout(localCandidatesTimeout);\n                    }\n                },\n                localIceCandidate: {\n                    action: function (params) {\n                        collectLocalIceCandidate(params);\n                        sendRemainingCandidates();\n                    },\n                    target: 'sending'\n                }\n            },\n            finished: {\n                localIceCandidate: {\n                    // helps trickleIce-compatible clients\n                    action: function (params) {\n                        collectLocalIceCandidate(params);\n                        sendRemainingCandidates({ suppressFinalCandidates: true });\n                    }\n                }\n            }\n        }\n    });\n\n    localCandidatesFSM.run();\n\n    /**\n     * Process a remote offer if we are not the caller. This is necessary because we don't process the offer until\n     * the callee has answered the call.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.processOffer\n     * @param {RTCSessionDescriptor}\n     * @returns {Promise}\n     */\n    that.processOffer = function (oOffer) {\n\n        function onSetRemoteDescriptionSuccess() {\n            if (!pc) {\n                return;\n            }\n\n            log.debug('set remote desc of offer succeeded');\n\n            processReceivingQueue();\n\n            pc.createAnswer(function saveAnswerAndSend(oSession) {\n                if (!pc) {\n                    return;\n                }\n\n                that.state.processedRemoteSDP = true;\n\n                if (!that.state.caller) {\n                    that.report.callerconnection = that.call.connectionId;\n                }\n\n                oSession.type = 'answer';\n                log.debug('setting and sending answer', oSession);\n                that.report.sdpsSent.push(oSession);\n\n                pc.setLocalDescription(oSession, function successHandler(p) {\n                    oSession.type = 'answer';\n                    signalAnswer({\n                        sessionDescription: oSession,\n                        call: that.call,\n                        onSuccess: function () {\n                            localCandidatesFSM.dispatch('ready');\n                        }\n                    });\n                    that.state.sentSDP = true;\n                }, function errorHandler(p) {\n                    var errorMessage = 'Error calling setLocalDescription on answer I created.';\n                    var err = new Error(errorMessage);\n                    log.error(errorMessage, p);\n                    /**\n                     * This event is fired on errors that occur during call setup or media negotiation.\n                     * @event respoke.Call#error\n                     * @type {respoke.Event}\n                     * @property {string} reason - A human readable description about the error.\n                     * @property {respoke.Call} target\n                     * @property {string} name - the event name.\n                     */\n                    that.call.fire('error', {\n                        message: err.message\n                    });\n                });\n            }, function errorHandler(err) {\n                log.error('create answer failed', err);\n\n                err = new Error(\"Error creating SDP answer. \" + err);\n                that.report.callStoppedReason = err.message;\n\n                /**\n                 * This event is fired on errors that occur during call setup or media negotiation.\n                 * @event respoke.Call#error\n                 * @type {respoke.Event}\n                 * @property {string} reason - A human readable description about the error.\n                 * @property {respoke.Call} target\n                 * @property {string} name - the event name.\n                 */\n                that.call.fire('error', {\n                    message: err.message\n                });\n                that.report.callStoppedReason = 'setRemoteDescription failed at answer.';\n                that.close();\n            });\n        }\n\n        function onSetRemoteDescriptionInitialError(err) {\n            log.debug('Error calling setRemoteDescription on offer I received.', err);\n\n            if (!pc) {\n                return;\n            }\n\n            /*\n             * Attempt to remove the dtls transport protocol from the offer sdp. This has been observed\n             * to cause setRemoteDescription failures when Chrome 46+ is placing calls to Chrome <= 41.\n             * This is a particularly acute issue when using nw.js 0.12.x or lower.\n             */\n            var alteredSdp = oOffer.sdp.replace(/UDP\\/TLS\\/RTP\\/SAVPF/g, 'RTP/SAVPF');\n            if (oOffer.sdp !== alteredSdp) {\n                oOffer.sdp = alteredSdp;\n                log.debug('Retrying setRemoteDescription with legacy transport in offer sdp', oOffer);\n                pc.setRemoteDescription(new RTCSessionDescription(oOffer),\n                    onSetRemoteDescriptionSuccess, onSetRemoteDescriptionFinalError);\n                return;\n            }\n\n            onSetRemoteDescriptionFinalError(err);\n        }\n\n        function onSetRemoteDescriptionFinalError(p) {\n            var errorMessage = 'Error calling setRemoteDescription on offer I received.';\n            var err = new Error(errorMessage);\n            log.error(errorMessage, p);\n            that.report.callStoppedReason = err.message;\n\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.call.fire('error', {\n                message: err.message\n            });\n        }\n\n        if (!pc) {\n            return;\n        }\n\n        log.debug('processOffer', oOffer);\n\n        that.report.sdpsReceived.push(oOffer);\n        that.report.lastSDPString = oOffer.sdp;\n\n        //set flags for audio / video being offered\n        that.call.hasDataChannel = respoke.sdpHasDataChannel(oOffer.sdp);\n\n        try {\n            pc.setRemoteDescription(new RTCSessionDescription(oOffer),\n                onSetRemoteDescriptionSuccess, onSetRemoteDescriptionInitialError);\n        } catch (err) {\n            var newErr = new Error(\"Exception calling setRemoteDescription on offer I received.\" + err.message);\n            that.report.callStoppedReason = newErr.message;\n\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.call.fire('error', {\n                message: newErr.message\n            });\n        }\n    };\n\n    /**\n     * Return media stats. Since we have to wait for both the answer and offer to be available before starting\n     * statistics, we'll return a promise for the stats object.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.getStats\n     * @returns {Promise<{respoke.MediaStatsParser}>|undefined}\n     * @param {object} params\n     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onSuccess] - Success handler for this\n     * invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @fires respoke.PeerConnection#stats\n     */\n    function getStats(params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        if (!respoke.MediaStats) {\n            deferred.reject(new Error(\"Statistics module is not loaded.\"));\n            return retVal;\n        }\n\n        function onConnect() {\n            var stats = respoke.MediaStatsParser({\n                peerConnection: pc,\n                interval: params.interval,\n                onStats: function statsHandler(stats) {\n                    if (!pc) {\n                        return;\n                    }\n\n                    /**\n                     * This event is fired every 5 seconds by default, configurable by the 'interval' property to\n                     * `call.startStats` and reports the current state of media statistics.\n                     * @event respoke.PeerConnection#stats\n                     * @type {respoke.Event}\n                     * @property {object} stats - an object with stats in it.\n                     * @property {string} name - the event name.\n                     * @property {respoke.PeerConnection}\n                     */\n                    that.fire('stats', {\n                        stats: stats\n                    });\n                }\n            });\n            that.listen('close', function closeHandler(evt) {\n\n                stats.stopStats();\n            }, true);\n            deferred.resolve();\n        }\n\n        if (!pc) {\n            that.once('stream-received', onConnect);\n        } else {\n            onConnect();\n        }\n\n        return retVal;\n    }\n\n    if (respoke.MediaStats) {\n        that.getStats = getStats;\n    }\n\n    /**\n     * Create the RTCPeerConnection and add handlers. Process any offer we have already received.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.init\n     */\n    that.init = function init() {\n        log.debug('PC.init');\n\n        if (pc) {\n            return;\n        }\n\n        that.report.callStarted = new Date().getTime();\n\n        pc = new RTCPeerConnection(that.servers, pcOptions);\n\n        /**\n         * Process a local ICE Candidate\n         *\n         * @param {RTCIceCandidate} oCan\n         */\n        pc.onicecandidate = function onIceCandidate(oCan) {\n                var candidate = oCan.candidate; // {candidate: ..., sdpMLineIndex: ... }\n                if (!pc) {\n                    return;\n                }\n\n                // From http://www.w3.org/TR/webrtc/#operation\n                // If the intent of the ICE Agent is to notify the script that:\n                //  [snip]\n                //  * The gathering process is done.\n                //    Set connection's ice gathering state to completed and let newCandidate be null.\n                if (!candidate || !candidate.candidate) {\n                    if (pc.iceGatheringState === 'complete') {\n                        localCandidatesComplete = true;\n                        localCandidatesFSM.dispatch('localIceCandidate');\n                    }\n                    return;\n                }\n\n                if (that.forceTurn === true && candidate.candidate.indexOf(\"typ relay\") === -1) {\n                    log.debug(\"Dropping candidate because forceTurn is on.\");\n                    return;\n                } else if (that.disableTurn === true && candidate.candidate.indexOf(\"typ relay\") !== -1) {\n                    log.debug(\"Dropping candidate because disableTurn is on.\");\n                    return;\n                }\n\n                localCandidatesFSM.dispatch('localIceCandidate', {candidate: candidate});\n            }\n        ;\n\n        /**\n         * Handle ICE state change\n         */\n        pc.oniceconnectionstatechange = function onIceConnectionStateChange(/* evt */) {\n                if (!pc) {\n                    return;\n                }\n\n                if (pc.iceConnectionState === 'connected') {\n                    /**\n                     * Indicate that we've successfully connected to the remote side. This is only helpful for the\n                     * outgoing connection.\n                     * @event respoke.PeerConnection#connect\n                     * @type {respoke.Event}\n                     * @property {string} name - the event name.\n                     * @property {respoke.PeerConnection}\n                     */\n                    that.fire('connect');\n                }\n            }\n        ;\n\n        pc.onaddstream = function onaddstream(evt) {\n            /**\n             * Indicate the RTCPeerConnection has received remote media.\n             * @event respoke.PeerConnection#stream-added\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('stream-added', {\n                stream: evt.stream\n            });\n        };\n\n        pc.onremovestream = function onremovestream(evt) {\n            /**\n             * Indicate the remote side has stopped sending media.\n             * @event respoke.PeerConnection#stream-removed\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('stream-removed', {\n                stream: evt.stream\n            });\n        };\n\n        pc.ondatachannel = function ondatachannel(evt) {\n            /**\n             * CAUTION: This event is only called for the callee because RTCPeerConnection#ondatachannel\n             * is only called for the callee.\n             * @event respoke.PeerConnection#direct-connection\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('direct-connection', {\n                channel: evt.channel\n            });\n        };\n\n        that.state.listen('offering:entry', function (evt) {\n            if (that.state.caller) {\n                initOffer();\n            }\n        });\n    };\n\n    /**\n     * Return an array of remote media streams.\n     * @muremberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.getRemoteStreams\n     */\n    that.getRemoteStreams = function () {\n        if (!pc) {\n            return [];\n        }\n        return pc.getRemoteStreams.apply(pc, Array.prototype.slice.call(arguments));\n    };\n\n    /**\n     * Return an array of local media streams.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.getLocalStreams\n     */\n    that.getLocalStreams = function () {\n        if (!pc) {\n            return [];\n        }\n        return pc.getLocalStreams.apply(pc, Array.prototype.slice.call(arguments));\n    };\n\n    /**\n     * Create a data channel.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.createDataChannel\n     */\n    that.createDataChannel = function () {\n        if (!pc) {\n            return;\n        }\n        return pc.createDataChannel.apply(pc, Array.prototype.slice.call(arguments));\n    };\n\n    /**\n     * Add any tracks from the provided stream to the peer connection.\n     *\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.addLocalTracksFromStream\n     */\n    that.addLocalTracksFromStream = function (stream) {\n        if (!pc) {\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.call.fire('error', {\n                message: \"Got local stream in a precall state.\"\n            });\n            return;\n        }\n\n        if (webrtcDetectedBrowser === 'firefox') {\n            stream.getTracks().forEach(function (track) {\n                pc.addTrack(track, stream);\n            });\n        } else {\n            pc.addStream(stream);\n        }\n    };\n\n    /**\n     * Remove and stop any local streams that are already added to the peer connection.\n     * This releases the resources used by those streams when renegotiating media.\n     *\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.removeLocalTracks\n     */\n    that.removeLocalTracks = function () {\n        if (webrtcDetectedBrowser === 'firefox') {\n            pc.getLocalStreams().forEach(function (stream) {\n                stream.getTracks().forEach(function (track) {\n                    track.stop();\n                });\n            });\n            pc.getSenders().forEach(function (sender) {\n                pc.removeTrack(sender);\n            });\n        } else {\n            pc.getLocalStreams().forEach(function (stream) {\n                stream.getTracks().forEach(function (track) {\n                    track.stop();\n                });\n                pc.removeStream(stream);\n            });\n        }\n    };\n\n    /**\n     * Process any ICE candidates that we received from the other side while we were waiting on the other\n     * party's SDP to arrive and be processed.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.processReceivingQueue\n     * @private\n     */\n    function processReceivingQueue() {\n        candidateReceivingQueue.trigger(function processIce(can) {\n            if (!pc) {\n                return;\n            }\n\n            pc.addIceCandidate(new RTCIceCandidate(can.candidate), function onSuccess() {\n                log.debug((that.state.caller ? 'caller' : 'callee'), 'got a remote candidate.', can.candidate);\n                that.report.candidatesReceived.push(can.candidate);\n            }, function onError(e) {\n                log.error(\"Couldn't add ICE candidate\", e, can.candidate);\n            });\n        });\n    }\n\n    /**\n     * Send DTMF tones to the first audio track on the call. This allows interaction with a phone system expecting keys\n     * to be pressed on a normal phone, such as when calling a company for customer support and having to \"Press 1 for English\".\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.sendTones\n     * @param {object} params\n     * @param {string} params.tones - The tones to send. Can be any combination of the characters '0123456789ABCD#*', or\n     *  a ',' (comma) to insert a 2 second pause before sending the next tone.\n     * @param {number} [params.duration] - Optional number in milliseconds to indicate how long to play each tone. This\n     *  value needs to be between 40 and 6000. Defaults to 100.\n     * @param {number} [params.gap] - Optional number in mlliseconds to indicate the gap between playing the tones.\n     *  This value needs to be larger than 30. Defaults to 70.\n     * @param {respoke.Call.onSuccess} [params.onSuccess] - Callback called when all requested DTMF tones have been played.\n     * @param {respoke.Call.onError} [params.onError] - Callback called when an error occurs while playing back the DTMF\n     *  tones, or when the request has been cancelled.\n     * @fires respoke.PeerConnection#tone-sent\n     * @fires respoke.PeerConnection#tone-sending-complete\n     * @returns {Promise|null} Returns a promise if no onSuccess nor onError callbacks are specified. Otherwise, returns null.\n     */\n    that.sendTones = function (params) {\n        var deferred = Q.defer();\n\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        params = typeof params === 'object' ? params : {};\n\n        params.duration = params.duration || 100;\n        params.gap = params.gap || 50;//chrome says minimum is 50 not 30 like the spec\n\n        var err;\n\n        if (!pc) {\n            err = new Error('No Peer Connection available');\n        }\n        if (!params.tones) {\n            err = new Error('Unable to send tones as none passed in');\n        }\n\n        if (params.duration > 6000 || params.duration < 40) {\n            err = new Error('Unable to send tones as duration needs to be between 40 and 6000 milliseconds');\n        }\n\n        if (params.gap < 50 ) {\n            err = new Error('Unable to send tones as gap needs to be greater than 50 milliseconds');\n        }\n\n        if (params.tones && !params.tones.match(/^([A-D0-9,#*])+$/ig)) {\n            err = new Error('Unable to send tones as tones passed in were not in correct format');\n        }\n\n        if (pc && !pc.createDTMFSender) {\n            err = new Error('Unable to send tones in this browser');\n        }\n\n        if (err) {\n            log.warn(err);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        if (digitSender) {\n            err = new Error('Unable to queue tones on audio track as a digitSender already exists');\n            log.warn(err);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        var audioTracks = that.call.outgoingMedia.getAudioTracks();\n        if (!audioTracks || audioTracks.length < 1) {\n            err = new Error('Could not send tones \"' + params.tones + '\". No audio track available.');\n            log.warn(err);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        digitSender = pc.createDTMFSender(audioTracks[0]);\n\n        digitSender.ontonechange = function onToneChange(evt) {\n            if (evt.tone !== '') {\n                /**\n                 * Indicate the RTCPeerConnection has sent a tone.\n                 * @event respoke.PeerConnection#tone-sent\n                 * @type {respoke.Event}\n                 * @property {string} evt.tone\n                 * @property {number} evt.duration\n                 * @property {number} evt.gap\n                 */\n                that.call.fire('tone-sent', {\n                    tone: evt.tone,\n                    duration: digitSender.duration,\n                    gap: digitSender.interToneGap\n                });\n                return;\n            }\n\n            /*\n             * The tone string is empty, which is how the DTMFSender represents the end\n             * of the tone queue. Cleanup our handlers, wrap up the promises, and fire\n             * the appropriate events.\n             */\n            digitSender = null;\n\n            if (cancellingTones) {\n                cancellingTones = false;\n                deferred.reject(new Error('Tone playback cancelled'));\n                return;\n            }\n\n            /**\n             * Indicate the RTCPeerConnection has finished sending tones, unless they were cancelled.\n             * @event respoke.PeerConnection#tone-sending-complete\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             */\n            deferred.resolve();\n            that.call.fire('tone-sending-complete');\n        };\n\n        if (!digitSender.canInsertDTMF) {\n            err = new Error('Unable to insert tones into audio track');\n            log.warn(err);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        try {\n            digitSender.insertDTMF(params.tones, params.duration, params.gap);\n        } catch (e) {\n            err = new Error('Unable to queue tones on audio track due to an error');\n            log.warn(err, params, e);\n            deferred.reject(err);\n            return retVal;\n        }\n        log.debug('successfully queued playback of tones', {\n            tones: digitSender.toneBuffer,\n            duration: digitSender.duration,\n            gap: digitSender.interToneGap\n        });\n\n        return retVal;\n    };\n\n    /**\n     * Cancel any tones currently being sent via sendTones.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.cancelTones\n     * @param {object} params\n     * @param {function} [params.onSuccess] - Success handler for this invocation of this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this method only.\n     * @fires respoke.PeerConnection#tone-sending-cancelled\n     * @returns {Promise|null} Returns a promise if no onSuccess nor onError callbacks are specified. Otherwise, returns null.\n     */\n    that.cancelTones = function (params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        var err;\n\n        if (!pc) {\n            err = new Error('No Peer Connection available');\n            log.warn(err);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        if (!digitSender) {\n            err = new Error('Unable to queue tones on audio track as a digitSender does not exist');\n            log.warn(err);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        if (!digitSender.canInsertDTMF) {\n            err = new Error('Unable to cancel playback of tones as cannot change tones on audio track');\n            log.warn(err);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        cancellingTones = true;\n        var tonesToCancel = digitSender.toneBuffer;\n\n        try {\n            digitSender.insertDTMF('');\n        } catch (e) {\n            err = new Error('Unable to cancel playback of tones');\n            log.warn(err, e);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        /**\n         * Indicate the RTCPeerConnection has finished cancelling tones.\n         * @event respoke.PeerConnection#tone-sending-cancelled\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         */\n        deferred.resolve();\n        that.call.fire('tone-sending-cancelled', {\n            cancelledTones: tonesToCancel\n        });\n\n        return retVal;\n    };\n\n    /**\n     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n     * signal is not false and we have not received a hangup signal from the remote party.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.close\n     * @param {object} params\n     * @param {boolean} [params.signal] - Optional flag to indicate whether to send or suppress sending\n     *  a hangup signal to the remote side. This is set to false by the library if we're responding to a\n     *  hangup signal.\n     * @fires respoke.PeerConnection#close\n     */\n    that.close = function (params) {\n        params = params || {};\n        toSendHangup = true;\n\n        if (that.state.caller === true) {\n            if (!that.state.sentSDP) {\n                // Never send hangup if we are the caller but we haven't sent any other signal yet.\n                toSendHangup = false;\n            }\n        }\n\n        toSendHangup = (typeof params.signal === 'boolean' ? params.signal : toSendHangup);\n        if (toSendHangup) {\n            log.info('sending hangup');\n            signalHangup({\n                call: that.call\n            });\n        }\n\n        that.report.callStopped = new Date().getTime();\n\n        /**\n         * Indicate that the RTCPeerConnection is closed.\n         * @event respoke.PeerConnection#close\n         * @type {respoke.Event}\n         * @property {boolean} sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n         * @property {string} name - the event name.\n         * @property {respoke.PeerConnection}\n         */\n        that.fire('close', {\n            sentSignal: toSendHangup\n        });\n        that.ignore();\n\n        if (pc && that.report) {\n            pc.close();\n        }\n        pc = null;\n\n        if (that.call.enableCallDebugReport) {\n            signalReport({\n                report: that.report\n            });\n        }\n        that.report = null;\n    };\n    that.close = respoke.callOnce(that.close);\n\n    /**\n     * Indicate whether a call is being setup or is in progress.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.isActive\n     * @returns {boolean}\n     */\n    that.isActive = function () {\n        return !!(pc && ['completed', 'connected', 'new', 'checking'].indexOf(pc.iceConnectionState) > -1);\n    };\n\n    /**\n     * Send the initiate signal to start the modify process. This method is only called by the caller of the\n     * renegotiation.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.startModify\n     * @param {object} params\n     * @param {object} [params.constraints] - Indicate this is a request for media and what type of media.\n     * @param {boolean} [params.directConnection] - Indicate this is a request for a direct connection.\n     */\n    that.startModify = function (params) {\n        defModify = Q.defer();\n        signalModify({\n            action: 'initiate',\n            call: that.call,\n            constraints: params.constraints,\n            directConnection: params.directConnection\n        });\n        that.state.dispatch('modify');\n    };\n\n    /**\n     * Save the candidate. If we initiated the call, place the candidate into the queue so\n     * we can process them after we receive the answer.\n     * @memberof! respoke.PeerConnection\n     * @method respoke.PeerConnection.addRemoteCandidate\n     * @param {object} params\n     * @param {RTCIceCandidate} params.candidate\n     */\n    that.addRemoteCandidate = function (params) {\n        if (!pc && (that.state.sentSDP || that.state.receivedSDP)) { // we hung up.\n            return;\n        }\n\n        if (!params || !params.candidate || !params.candidate.hasOwnProperty('sdpMLineIndex')) {\n            log.warn(\"addRemoteCandidate got wrong format!\", params);\n            return;\n        }\n\n        candidateReceivingQueue.push(params);\n    };\n\n    /**\n     * Save the answer and tell the browser about it.\n     */\n    that.call.listen('signal-answer', function handleAnswerSignal(evt) {\n        log.debug('PC handleAnswerSignal', evt);\n\n        if (!pc) {\n            return;\n        }\n\n        log.debug('got answer', evt.signal);\n\n        that.report.sdpsReceived.push(evt.signal.sessionDescription);\n        that.state.sendOnly = respoke.sdpHasReceiveOnly(evt.signal.sessionDescription.sdp);\n        that.report.lastSDPString = evt.signal.sessionDescription.sdp;\n\n        if (that.state.caller) {\n            that.report.calleeconnection = evt.signal.fromConnection;\n        }\n\n        that.call.connectionId = evt.signal.fromConnection;\n        // TODO don't signal connected more than once.\n        signalConnected({\n            call: that.call\n        });\n\n        pc.setRemoteDescription(\n            new RTCSessionDescription(evt.signal.sessionDescription),\n            function successHandler() {\n                processReceivingQueue();\n                that.state.dispatch('receiveAnswer');\n            }, function errorHandler(p) {\n                var errorMessage = 'Exception calling setRemoteDescription on answer I received.';\n                var newErr = new Error(errorMessage);\n                log.error(errorMessage, p);\n                that.report.callStoppedReason = newErr.message;\n                /**\n                 * This event is fired on errors that occur during call setup or media negotiation.\n                 * @event respoke.Call#error\n                 * @type {respoke.Event}\n                 * @property {string} reason - A human readable description about the error.\n                 * @property {respoke.Call} target\n                 * @property {string} name - the event name.\n                 */\n                that.call.fire('error', {\n                    message: newErr.message\n                });\n                log.error('set remote desc of answer failed', evt.signal.sessionDescription, p);\n                that.report.callStoppedReason = 'setRemoteDescription failed at answer.';\n                that.close();\n            }\n        );\n    }, true);\n\n    /**\n     * Figure out who won the call. This necessary to prevent two connections of\n     * the same endpoint from thinking they are both on the same call.\n     */\n    that.call.listen('signal-connected', function handleConnectedSignal(evt) {\n        log.debug('PC handleConnectedSignal', evt);\n\n        if (evt.signal.connectionId !== client.connectionId) {\n            log.debug(\"Hanging up because I didn't win the call.\", evt.signal, client);\n            that.call.hangup({signal: false});\n        }\n    }, true);\n\n    /**\n     * Indicate a desire from the other side to renegotiate media.\n     */\n    that.call.listen('signal-modify', function handleModifySignal(evt) {\n        var err;\n        log.debug('PC handleModifySignal', evt);\n\n        if (evt.signal.action === 'accept') {\n            if (defModify.promise.isPending()) {\n                defModify.resolve();\n                /**\n                 * Indicate that the remote party has accepted our invitation to begin renegotiating media.\n                 * @event respoke.PeerConnection#modify-accept\n                 * @type {respoke.Event}\n                 * @property {string} name - the event name.\n                 * @property {respoke.PeerConnection}\n                 */\n\n                // reset the ice candidate queue for the renegotiation\n                candidateReceivingQueue = respoke.queueFactory();\n\n                // let the world know we're ready to re-negotiate\n                that.fire('modify-accept', {signal: evt.signal});\n            }\n            return;\n        } else if (evt.signal.action === 'reject') {\n            if (defModify.promise.isPending()) {\n                err = new Error(\"Remote party cannot negotiate.\");\n                log.debug(err.message);\n                defModify.reject(err);\n                /**\n                 * Indicate that the remote party has rejected our invitation to begin renegotiating media.\n                 * @event respoke.PeerConnection#modify-reject\n                 * @type {respoke.Event}\n                 * @property {Error} err\n                 * @property {string} name - the event name.\n                 * @property {respoke.PeerConnection}\n                 */\n                that.fire('modify-reject', {err: err});\n            }\n            return;\n        }\n\n        // This code only gets executed if signal.action === 'initiate'\n        if (defModify && defModify.promise.isPending()) {\n            // TODO compare signal request ID and accept if we have the higher request ID,\n            // reject if we have the lower request ID.\n            err = new Error(\"Got modify in a negotiating state.\");\n            log.debug(err.message);\n            defModify.reject(err);\n            /**\n             * Indicate that the remote party has rejected our invitation to begin renegotiating media.\n             * @event respoke.PeerConnection#modify-reject\n             * @type {respoke.Event}\n             * @property {Error} err\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('modify-reject', {err: err});\n            signalModify({\n                action: 'reject',\n                call: that.call\n            });\n            return;\n        }\n\n        defModify = Q.defer();\n\n        if (!that.state.sentSDP || that.state.isState('idle')) {\n            err = new Error(\"Got modify in a precall state.\");\n            /**\n             * Indicate that the remote party has rejected our invitation to begin renegotiating media.\n             * @event respoke.PeerConnection#modify-reject\n             * @type {respoke.Event}\n             * @property {Error} err\n             * @property {string} name - the event name.\n             * @property {respoke.PeerConnection}\n             */\n            that.fire('modify-reject', {err: err});\n            signalModify({\n                action: 'reject',\n                call: that.call\n            });\n            defModify.reject(err);\n            return;\n        }\n\n        /*\n         * Received an 'initiate' and we are in the correct state to receive it,\n         * so send the accept and prepare to receive an offer from the remote endpoint.\n         */\n\n        // reset ice candidate queueing\n        candidateReceivingQueue = respoke.queueFactory();\n\n        // accept the modify to allow re-negotiating media\n        signalModify({\n            action: 'accept',\n            call: that.call\n        });\n        defModify.resolve();\n    }, true);\n\n    return that;\n}; // End respoke.PeerConnection\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/peerConnection.js\n ** module id = 18\n ** module chunks = 0\n **/","// Copyright (c) 2010 David Durman\n//\n// The contents of this file are subject to the MIT License (the \"License\");\n// you may not use this file except in compliance with the License. You may obtain a copy of the License at\n// http://opensource.org/licenses/MIT.\n//\n// This hierarchical state machine implementation has been inspired\n// by the QP active object framework, see http://www.state-machine.com/\n\n\n(function(root, factory){\n    \"use strict\";\n\n    if (typeof exports === 'object') {\n\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like enviroments that support module.exports,\n        // like Node.\n        module.exports = factory();\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        // AMD. Register as an anonymous module.\n        define(factory);\n\n    } else {\n\n        // Browser globals (root is window)\n        root.Statechart = factory();\n    }\n\n}(this, function(){\n\n    \"use strict\";\n\n    var assert = function(assertion){\n        if (!assertion) {\n            throw new Error(\"Assertion failed.\");\n        }\n    };\n\n\n    // Statechart.\n    // -----------\n\n    // `myState` - the current state\n    // `mySource` - the source of the current transition\n\n    var Statechart = {\n\n        run: function(opt){\n            opt = opt || {};\n            this.debug = opt.debug ? opt.debug : function(){};\n            this.construct(this.initialState);\n            this.init(null);\n        },\n\n        construct: function(initialState){\n            this.myState = this.top();\n            this.mySource = this.state(\"Initial\");\n\n            // Initial pseudo-state\n            this.states.Initial = {\n                empty: function(){\n                    this.newInitialState(initialState);\n                }\n            };\n            var handled = function(){ return null; };\n\n            // TOP state\n            this.states.TOP = {\n                entry: handled,\n                exit:  handled,\n                init:  handled,\n                empty: handled\n            };\n            this.flatten();\n        },\n\n        // Trigger the initial transition and recursively enter the submachine of the top state.\n        // Must be called only once for a given Statechart before dispatching any events to it.\n        init: function(anEventOrNull){\n            assert(this.myState === this.top() && this.mySource !== null);\n            var s = this.myState;    // save top in temp\n            this.mySource.trigger(anEventOrNull);    // topmost initial transition\n            assert(s.equals(this.myState.superstate()));    // verify that we only went one level deep\n            s = this.myState;\n            s.enter();\n            while (s.init() === null) {    // while init is handled (i.e. till we reach a leaf node)\n                assert(s.equals(this.myState.superstate()));    // verify that we only went one level deep\n                s = this.myState;\n                s.enter();\n            }\n        },\n\n        state: function(stateOrName){\n            return (stateOrName && stateOrName instanceof QState) ? stateOrName : new QState(this, stateOrName);\n        },\n\n        top: function(stateOrName){\n            // create the top state only once and store it to an auxiliary property\n            return (this._topState || (this._topState = new QState(this, \"TOP\")));\n        },\n\n        currentState: function(){\n            return this.myState;\n        },\n\n        flatten: function(){\n            this.statesTable = this.statesTable || {};\n            this._flatten(this.states, this.top().name);\n        },\n\n        _flatten: function(states, parent){\n            if (!states) {\n                return;\n            }\n\n            for (var state in states) {\n                if (states.hasOwnProperty(state)) {\n                    this.statesTable[state] = states[state];\n                    this.statesTable[state].parent = parent;\n                    this._flatten(states[state].states, state);\n                }\n            }\n        },\n\n        selectState: function(stateName){\n            return this.statesTable[stateName];\n        },\n\n        dispatchEvent: function(anEvent, state, act){\n            act = act || state[anEvent.type];\n\n            // Action might also be an array in which case it is assumed that evaluating guards decides\n            // which target to enter.\n            if (act instanceof Array) {\n                for (var i = 0; i < act.length; i++) {\n                    this.dispatchEvent(anEvent, state, act[i]);\n                }\n            }\n\n            // @todo This is terrible edge case used just for more fancy Statechart representation\n            // It allows using \"MyState\": { init: \"MySubState\", ... } intead of\n            // \"MyState\": { init: function(){ this.newInitialState(\"MySubState\"); }, ... }\n            // In some cases the latter form can be useful for better control of the Statechart\n            if (anEvent.type === \"init\" && typeof act === \"string\") {\n                this.newInitialState(act);\n                return null; // handled\n            }\n\n            if (act instanceof Function){\n                act.call(this, anEvent.args);\n                return null;  // handled\n            } else if (act) {\n                // no guard at all or the guard condition is met\n                if (!act.guard || (act.guard && act.guard.call(this, anEvent.args))){\n                    if (act.action) {\n                        act.action.call(this, anEvent.args);\n                    }\n                    if (act.target) {\n                        this.newState(act.target);\n                    }\n                    return null;  // handled\n                }\n            } else {        // act is undefined (no handler in state for anEvent)\n                if (state === this.selectState(\"TOP\")) {\n                    this.handleUnhandledEvent(anEvent); // not-handled\n                    return null;    // handled (TOP state handles all events)\n                }\n            }\n            return this.state(state.parent); // not-handled\n        },\n\n        // Override this when needed.\n        handleUnhandledEvent: function(anEvent){\n            this.debug(\"Unhandled event: \" + anEvent.type);\n            return null;\n        },\n\n        // Traverse the state hierarchy starting from the currently active state myState.\n        // Advance up the state hierarchy (i.e., from substates to superstates), invoking all\n        // the state handlers in succession. At each level of state nesting, it intercepts the value\n        // returned from a state handler to obtain the superstate needed to advance to the next level.\n        dispatch: function(anEvent, args){\n            if (!anEvent || !(anEvent instanceof QEvent)) {\n                anEvent = new QEvent(anEvent, args);\n            }\n            this.mySource = this.myState;\n            while (this.mySource) {\n                this.mySource = this.mySource.trigger(anEvent);\n            }\n        },\n\n        // Performs dynamic transition. (macro Q_TRAN_DYN())\n        newState: function(aStateName){\n            this.transition(this.state(aStateName));\n        },\n\n        // Used by handlers only in response to the #init event. (macro Q_INIT())\n        // USAGE: return this.newInitialState(\"whatever\");\n        // @return null for convenience\n\n        newInitialState: function(aStateOrName){\n            this.myState = this.state(aStateOrName);\n            return null;\n        },\n\n        // Dynamic transition. (Q_TRAN_DYN())\n        transition: function(target){\n            assert(!target.equals(this.top()));\n\n            var entry = [];\n            var mySource = this.mySource;\n            var s = this.myState;\n\n            // exit all the nested states between myState and mySource\n            assert(s !== null);\n            assert(mySource !== null);\n            while (!s.equals(mySource)) {\n                s = s.exit() || s.superstate();\n            }\n\n            // check all seven possible source/target state combinations\n\n\t    entry.push(target);\n\n            // (a) mySource == target (self transition)\n            if (mySource.equals(target)) {\n                mySource.exit();\n                return this.enterVia(target, entry);\n            }\n\n            // (b) mySource == target.superstate (one level deep)\n            var p = target.superstate();\n            if (mySource.equals(p)) {\n                return this.enterVia(target, entry);\n            }\n\n            assert(mySource !== null);\n\n            // (c) mySource.superstate == target.superstate (most common - fsa)\n            var q = mySource.superstate();\n            if (q.equals(p)) {\n                mySource.exit();\n                return this.enterVia(target, entry);\n            }\n\n            // (d) mySource.superstate == target (one level up)\n            if (q.equals(target)) {\n                mySource.exit();\n                entry.pop();    // do not enter the LCA\n                return this.enterVia(target, entry);\n            }\n\n            // (e) mySource == target.superstate.superstate... hierarchy (many levels deep)\n\t    entry.push(p);\n            s = p.superstate();\n            while (s !== null) {\n                if (mySource.equals(s)) {\n                    return this.enterVia(target, entry);\n                }\n\n\t\tentry.push(s);\n                s = s.superstate();\n            }\n\n            // otherwise we're definitely exiting mySource\n            mySource.exit();\n\n            // entry array is complete, save its length to avoid computing it repeatedly\n            var entryLength = entry.length;\n\n            // (f) mySource.superstate == target.superstate.superstate... hierarchy\n            var lca;\n            for (lca = entryLength - 1; lca >= 0; lca -= 1) {\n                if (q.equals(entry[lca])) {\n                    return this.enterVia(target, entry.slice(0, lca)); // do not enter lca\n                }\n            }\n\n            // (g) each mySource.superstate.superstate... for each target.superstate.superstate...\n            s = q;\n            while (s !== null) {\n                for (lca = entryLength - 1; lca >= 0; lca -= 1) {\n                    if (s.equals(entry[lca])) {\n                        return this.enterVia(target, entry.slice(0, lca)); // do not enter lca\n                    }\n                }\n                s.exit();\n                s = s.superstate();\n            }\n        },\n\n        // tail of transition()\n        // We are in the LCA of mySource and target.\n        enterVia: function(target, entry){\n\n            // retrace the entry path in reverse order\n            var idx = entry.length;\n            while (idx > 0) {\n                idx--;\n                entry[idx].enter();\n            }\n\n            this.myState = target;\n            while (target.init() === null) {\n                // initial transition must go one level deep\n                assert(target.equals(this.myState.superstate()));\n                target = this.myState;\n                target.enter();\n            }\n        }\n    };\n\n    // QState.\n    // -------\n\n    function QState(fsm, name){\n        this.fsm = fsm;\n        this.name = name;\n    }\n\n    QState.prototype = {\n        equals: function(state){\n            return (this.name === state.name && this.fsm === state.fsm);\n        },\n\n        dispatchEvent: function(anEvent, state){\n            return this.fsm.dispatchEvent(anEvent, state);\n        },\n\n        trigger: function(anEvent){\n            var evt = anEvent || QEventEmpty;\n            var state = this.fsm.selectState(this.name);\n            return this.dispatchEvent(evt, state);\n        },\n\n        enter: function(){\n            this.fsm.debug(\"[\" + this.name + \"] enter\");\n            return this.trigger(QEventEntry);\n        },\n\n        exit: function(){\n            this.fsm.debug(\"[\" + this.name + \"] exit\");\n            return this.trigger(QEventExit);\n        },\n\n        init: function(){\n            this.fsm.debug(\"[\" + this.name + \"] init\");\n            return this.trigger(QEventInit);\n        },\n\n        // Answer my superstate. Default is to return fsm top state.\n        superstate: function(){\n            var superstate = this.trigger(QEventEmpty);\n            if (superstate && superstate instanceof QState) {\n                return superstate;\n            }\n            superstate = this.fsm.top();\n            if (this.name === superstate.name) {\n                return null;\n            }\n            return superstate;\n        }\n    };\n\n    // QEvent\n    // ------\n\n    function QEvent(type, args){\n        this.type = type;\n        this.args = args;\n    }\n\n    // these events are static, they do not carry any arguments\n    // -> create them only once\n    // moreover, they don't have to be exposed to the outer world\n    var QEventEntry = new QEvent(\"entry\");\n    var QEventExit = new QEvent(\"exit\");\n    var QEventInit = new QEvent(\"init\");\n    var QEventEmpty = new QEvent(\"empty\");\n\n\n    return Statechart;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/statechart/lib/statechart.js\n ** module id = 19\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar respoke = require('./respoke');\nvar log = respoke.log;\nvar Statechart = require('statechart');\n\n/**\n * State machine for WebRTC calling, data channels, and screen sharing.\n * NOTE: All state transitions are synchronous! However,\n * listeners to the events this class fires will be called asynchronously.\n *\n * @class respoke.CallState\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @link https://cdn.respoke.io/respoke.min.js\n * @returns {respoke.CallState}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var fsm;\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    that.className = 'respoke.CallState';\n    delete that.instanceId;\n\n    var client = respoke.getClient(instanceId);\n    var allTimers = [];\n    var answerTimer;\n    var answerTimeout = params.answerTimeout || 10000;\n    var receiveAnswerTimer;\n    var receiveAnswerTimeout = params.receiveAnswerTimeout || 60000;\n    var connectionTimer;\n    var connectionTimeout = params.connectionTimeout || 10000;\n    var modifyTimer;\n    var modifyTimeout = params.modifyTimeout || 60000;\n    var oldRole;\n\n    function assert(condition) {\n        if (!condition) {\n            throw new Error(\"Assertion failed.\");\n        }\n    }\n\n    that.hasLocalMediaApproval = false;\n    that.hasLocalMedia = false;\n    that.receivedBye = false;\n    that.isAnswered = false;\n    that.sentSDP = false;\n    that.receivedSDP = false;\n    that.processedRemoteSDP = false;\n    that.needDirectConnection = !!that.needDirectConnection;\n    that.sendOnly = !!that.sendOnly;\n    that.receiveOnly = !!that.receiveOnly;\n    that.isModifying = false;\n\n    // Event\n    var rejectEvent = [{\n        action: function () {\n            [answerTimer, receiveAnswerTimer, connectionTimer, modifyTimer].forEach(function (timer) {\n                if (timer) {\n                    timer.clear();\n                }\n            });\n\n            // we have any media flowing or data channel open\n            if (typeof oldRole === 'boolean') {\n                // Reset the role if we have aborted a modify.\n                that.caller = oldRole;\n            }\n\n            that.isModifying = false;\n        }\n    }, {\n        target: 'connected',\n        guard: function () {\n            return that.hasMedia();\n        }\n    }, {\n        target: 'terminated',\n        guard: function (params) {\n            params = params || {};\n            // we have no media flowing or data channel open\n            that.hangupReason = params.reason || \"no media\";\n            return !that.hasMedia();\n        }\n    }];\n\n    // Event\n    function rejectModify() {\n        // reject modification\n        if (modifyTimer) {\n            modifyTimer.clear();\n            that.isModifying = false;\n        }\n    }\n\n    // Event\n    function clearReceiveAnswerTimer() {\n        that.processedRemoteSDP = true;\n        if (receiveAnswerTimer) {\n            receiveAnswerTimer.clear();\n        }\n    }\n\n    // Event\n    var hangupEvent = {\n        target: 'terminated',\n        action: function (params) {\n            params = params || {};\n            that.signalBye = params.signal;\n            that.hangupReason = that.hangupReason || params.reason || \"none\";\n        }\n    };\n\n    function needToObtainMedia() {\n        return (\n            that.needDirectConnection !== true &&\n            that.receiveOnly !== true &&\n            that.hasLocalMedia !== true\n        );\n    }\n\n    function needToApproveDirectConnection(params) {\n        return (that.needDirectConnection === true && typeof params.previewLocalMedia === 'function');\n    }\n\n    function automaticOffering(params) {\n        if (that.caller !== true) {\n            return false;\n        }\n\n        // TODO: this will need to be change with media negotiation\n        if ((!that.needDirectConnection && that.receiveOnly) || that.hasLocalMedia) {\n            return true;\n        }\n\n        return (that.needDirectConnection === true && typeof params.previewLocalMedia !== 'function');\n    }\n\n    function hasListener() {\n        return ((client.hasListeners('call') && !that.needDirectConnection) ||\n                (client.hasListeners('direct-connection') && that.needDirectConnection));\n    }\n\n    function createTimer(func, name, time) {\n        var id = setTimeout(function () {\n            id = null;\n            log.error((that.caller ? \"caller's\" : \"callee's\"), name, \"timer expired.\");\n            func();\n        }, time);\n        log.debug('setting timer', name, 'for', time / 1000, 'secs');\n        var timer  = {\n            name: name,\n            clear: function () {\n                if (id === null) {\n                    return;\n                }\n                log.debug('clearing', (that.caller ? \"caller's\" : \"callee's\"), 'timer', name);\n                clearTimeout(id);\n                id = null;\n            }\n        };\n        allTimers.push(timer);\n        return timer;\n    }\n\n    var stateParams = {\n        initialState: 'idle',\n        states: {\n            // State\n            idle: {\n                // Event\n                exit: function () {\n                    that.fire('idle:exit');\n                },\n                // Event\n                initiate: [{\n                    target: 'negotiatingContainer',\n                    guard: function (params) {\n                        assert(typeof params.caller === 'boolean');\n                        return (params.caller === true || hasListener());\n                    }\n                }, {\n                    target: 'terminated',\n                    guard: function (params) {\n                        return (params.caller !== true && !hasListener());\n                    }\n                }],\n                receiveLocalMedia: function () {\n                    that.hasLocalMedia = true;\n                },\n                // Event\n                receiveOffer: {\n                    action: function (params) {\n                        that.receivedSDP = true;\n                    }\n                },\n                // Event\n                hangup: hangupEvent\n            },\n            // State\n            negotiatingContainer: {\n                init: \"preparing\",\n                // Event\n                hangup: hangupEvent,\n                // Event\n                modify: rejectModify,\n                // Event\n                receiveLocalMedia: function () {\n                    that.hasLocalMedia = true;\n                },\n                states: {\n                    preparing: {\n                        // Event\n                        entry: {\n                            action: function () {\n                                that.hasLocalMediaApproval = false;\n                                that.hasLocalMedia = false;\n                                that.sentSDP = false;\n                                that.receivedSDP = false;\n                                that.processedRemoteSDP = false;\n                                that.isAnswered = false;\n                                if (!that.isModifying) {\n                                    answerTimer = createTimer(function () {\n                                        that.dispatch('reject', {reason: \"answer own call timer \" + that.caller});\n                                    }, 'answer own call', (that.caller ? answerTimeout : receiveAnswerTimeout));\n                                }\n                                that.fire('preparing:entry');\n                            }\n                        },\n                        // Event\n                        exit: function () {\n                            if (answerTimer) {\n                                answerTimer.clear();\n                            }\n                        },\n                        // Event\n                        reject: rejectEvent,\n                        // Event\n                        receiveOffer: [{\n                            action: function (params) {\n                                that.receivedSDP = true;\n                                if (that.isAnswered) {\n                                    // If we get here, we are the callee and we've answered the call before the call\n                                    // creation/receive offer promise chain completed.\n                                    setTimeout(function () {\n                                        that.dispatch('answer', params);\n                                    });\n                                }\n                            }\n                        }, {\n                            target: 'connecting',\n                            guard: function () {\n                                return that.isModifying;\n                            }\n                        }],\n                        // Event\n                        answer: [{\n                            action: function (params) {\n                                assert(!params.previewLocalMedia || typeof params.previewLocalMedia === 'function');\n                                that.isAnswered = true;\n                                if (typeof params.previewLocalMedia !== 'function') {\n                                    that.hasLocalMediaApproval = true;\n                                }\n                            }\n                        }, {\n                            // we are going to send media\n                            target: 'approvingDeviceAccess',\n                            guard: needToObtainMedia\n                        }, {\n                            // we are sending a direct connection & developer wants to approve\n                            target: 'approvingContent',\n                            guard: needToApproveDirectConnection\n                        }, {\n                            target: 'offering',\n                            guard: automaticOffering\n                        }, {\n                            // we are not sending anything or developer does not want to approve media.\n                            target: 'connecting',\n                            guard: function (params) {\n                                // caller will always answer before sending offer.\n                                // callee will usually answer after receiving offer if media is requested.\n                                if (!that.receivedSDP) {\n                                    return false;\n                                }\n\n                                if (needToObtainMedia() || needToApproveDirectConnection(params) ||\n                                        automaticOffering(params)) {\n                                    return false;\n                                }\n\n                                if (!params.previewLocalMedia || that.receiveOnly) {\n                                    setTimeout(function () {\n                                        params.approve();\n                                    });\n                                }\n                                return (that.receiveOnly === true || that.needDirectConnection === true);\n                            }\n                        }]\n                    },\n                    // State\n                    gettingMedia: {\n                        reject: rejectEvent,\n                        // Event\n                        receiveLocalMedia: [{\n                            action: function () {\n                                that.hasLocalMedia = true;\n                            }\n                        }, {\n                            target: 'offering',\n                            guard: function (params) {\n                                return (that.caller === true && that.hasLocalMediaApproval === true &&\n                                    that.hasLocalMedia === true);\n                            }\n                        }, {\n                            target: 'connecting',\n                            guard: function (params) {\n                                return (that.caller === false && that.hasLocalMediaApproval === true &&\n                                    that.hasLocalMedia === true);\n                            }\n                        }],\n                        states: {\n                            // State\n                            approvingDeviceAccess: {\n                                // Event\n                                approve: [{\n                                    target: 'approvingContent',\n                                    guard: function (params) {\n                                        return (typeof params.previewLocalMedia === 'function');\n                                    }\n                                }, {\n                                    target: 'connecting',\n                                    guard: function (params) {\n                                        return (that.caller === false &&\n                                            (that.hasLocalMedia === true || that.needDirectConnection === true) &&\n                                            typeof params.previewLocalMedia !== 'function');\n                                    }\n                                }, {\n                                    target: 'offering',\n                                    guard: function (params) {\n                                        return (that.caller === true && that.hasLocalMedia === true &&\n                                            typeof params.previewLocalMedia !== 'function');\n                                    }\n                                }]\n                            },\n                            // State\n                            approvingContent: {\n                                // Event\n                                approve: [function (params) {\n                                    that.hasLocalMediaApproval = true;\n                                }, {\n                                    target: 'offering',\n                                    guard: function (params) {\n                                        return (that.caller === true && that.hasLocalMedia === true);\n                                    }\n                                }, {\n                                    target: 'connecting',\n                                    guard: function (params) {\n                                        return (that.caller === false && that.hasLocalMedia === true);\n                                    }\n                                }]\n                            }\n                        }\n                    },\n                    // State\n                    offeringContainer: {\n                        init: 'offering',\n                        reject: rejectEvent,\n                        sentOffer: function () {\n                            // start answer timer\n                            receiveAnswerTimer = createTimer(function () {\n                                that.dispatch('reject', {reason: \"receive answer timer\"});\n                            }, 'receive answer', receiveAnswerTimeout);\n                        },\n                        states: {\n                            offering: {\n                                // Event\n                                entry: function () {\n                                    that.fire('offering:entry');\n                                },\n                                // Event\n                                receiveLocalMedia: [function () {\n                                    that.hasLocalMedia = true;\n                                }, {\n                                    target: 'connected',\n                                    guard: function (params) {\n                                        // for direct connection, local media is the same as remote media\n                                        return (that.needDirectConnection === true);\n                                    }\n                                }],\n                                // Event\n                                receiveRemoteMedia: {\n                                    target: 'connected'\n                                },\n                                // Event\n                                receiveAnswer: [clearReceiveAnswerTimer, {\n                                    target: 'connecting',\n                                    guard: function () {\n                                        return !that.isModifying;\n                                    }\n                                }, {\n                                    target: 'connected',\n                                    guard: function () {\n                                        return that.isModifying;\n                                    }\n                                }]\n                            }\n                        }\n                    },\n                    // State\n                    connectingContainer: {\n                        init: 'connecting',\n                        reject: rejectEvent,\n                        receiveAnswer: clearReceiveAnswerTimer,\n                        states: {\n                            connecting: {\n                                // Event\n                                entry: function () {\n                                    that.fire('connecting:entry');\n\n                                    // set connection timer\n                                    connectionTimer = createTimer(function () {\n                                        that.dispatch('reject', {reason: \"connection timer\"});\n                                    }, 'connection', connectionTimeout);\n                                },\n                                // Event\n                                exit: function () {\n                                    if (connectionTimer) {\n                                        connectionTimer.clear();\n                                    }\n                                },\n                                // Event\n                                receiveLocalMedia: [{\n                                    action: function () {\n                                        that.hasLocalMedia = true;\n                                    }\n                                }, {\n                                    target: 'connected',\n                                    guard: function (params) {\n                                        // for direct connection, local media is the same as remote media\n                                        return (that.needDirectConnection === true && that.caller === false);\n                                    }\n                                }],\n                                // Event\n                                receiveRemoteMedia: {\n                                    target: 'connected'\n                                },\n                                removeRemoteMedia: {\n                                    target: 'connected'\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            // State\n            // This state is for when we are in limbo between connected and negotiating and we are\n            // trying to figure out if the other side will allow us to modify. If we receive modify in\n            // this state, we will reject it. If the other party is in connected, we will be able to modify.\n            modifyingContainer: {\n                init: 'modifying',\n                reject: rejectEvent,\n                // Event\n                modify: rejectModify,\n                // Event\n                hangup: hangupEvent,\n                states: {\n                    modifying: {\n                        // Event\n                        entry: function () {\n                            modifyTimer = createTimer(function () {\n                                that.dispatch('reject', {reason: \"modify timer\"});\n                            }, 'modify for caller', modifyTimeout);\n                        },\n                        // Event\n                        accept: [function () {\n                            that.caller = true;\n                        }, {\n                            target: 'preparing'\n                        }]\n                    }\n                }\n            },\n            // State\n            connectedContainer: {\n                init: 'connected',\n                reject: {\n                    target: 'terminated',\n                    action: function (params) {\n                        that.hangupReason = params.reason || \"got reject while connected\";\n                    }\n                },\n                receiveAnswer: clearReceiveAnswerTimer,\n                // Event\n                hangup: hangupEvent,\n                states: {\n                    connected: {\n                        // Event\n                        entry: function () {\n                            oldRole = that.caller;\n                            that.needDirectConnection = false;\n                            that.isModifying = false;\n                            that.sendOnly = false;\n                            that.receiveOnly = false;\n\n                            if (modifyTimer) {\n                                modifyTimer.clear();\n                            }\n                        },\n                        // Event\n                        modify: [{\n                            action: function () {\n                                that.isModifying = true;\n                            }\n                        }, {\n                            // be notified that the other side would like modification\n                            target: 'preparing',\n                            guard: function (params) {\n                                params = params || {};\n                                if (params.receive === true) {\n                                    that.caller = false;\n                                    modifyTimer = createTimer(function () {\n                                        // If modify gets interrupted, go back to previous roles.\n                                        that.dispatch('reject', {reason: \"modify timer\"});\n                                    }, 'modify', modifyTimeout);\n                                    return true;\n                                }\n                            }\n                        }, {\n                            // request to begin modification\n                            target: 'modifying',\n                            guard: function (params) {\n                                params = params || {};\n                                return (params.receive !== true);\n                            }\n                        }]\n                    }\n                }\n            },\n            // State\n            terminatedContainer: {\n                init: 'terminated',\n                states: {\n                    terminated: {\n                        // Event\n                        entry: {\n                            action: function () {\n                                that.fire('terminated:entry');\n                                allTimers.forEach(function (timer) {\n                                    timer.clear();\n                                });\n                                setTimeout(function () {\n                                    fsm = null;\n                                    that.ignore();\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    stateParams.that = Object.create(Statechart);\n    fsm = respoke.Class(stateParams);\n    fsm.run({\n        // rename to 'debug' to enable\n        debugOff: function () {\n            // So we can print the caller. Debug most often used when testing & tests run in the same tab.\n            var args = Array.prototype.slice.call(arguments);\n            args.unshift(\"state change:\");\n            log.debug.apply(log, args);\n        }\n    });\n\n    /**\n     * Return the name of the current state.\n     * @memberof! respoke.CallState\n     * @method respoke.Call.getState\n     * @returns {string}\n     */\n    that.getState = function () {\n        if (!fsm) {\n            return 'terminated';\n        }\n        return fsm.currentState().name;\n    };\n\n    /**\n     * Synchronously dispatch an event, which may or may not change the state.\n     * @memberof! respoke.CallState\n     * @method respoke.Call.dispatch\n     */\n    that.dispatch = function (evt, args) {\n        var oldState;\n        var newState;\n\n        /*\n         * These can quite often result in a condition in which they do not\n         * cause a transition to occur. There is at least one \"universal\" (air quotes)\n         * event which probably? shouldn't? but may result in a non-transition error\n         * when it's OK, and that is the 'reject' event.\n         */\n        var nontransitionEvents = ['receiveLocalMedia', 'receiveRemoteMedia', 'removeRemoteMedia',\n            'approve', 'answer', 'sentOffer', 'receiveAnswer'];\n\n        if (!fsm) {\n            return;\n        }\n\n        oldState = that.getState();\n        log.debug(\"dispatching '\" + evt + \"', from '\" + oldState + \"'. caller?\", that.caller, \"args:\", args);\n\n        try {\n            fsm.dispatch(evt, args);\n        } catch (err) {\n            log.debug(\"error dispatching '\" + evt + \"' from '\" + oldState + \"'.\", { args: args, error: err });\n            throw err;\n        }\n\n        newState = that.getState();\n\n        if (oldState === newState && nontransitionEvents.indexOf(evt) === -1) {\n            log.debug(\"Possible bad event '\" + evt + \"', no transition occurred. caller?\", that.caller);\n        } else {\n            log.debug(\"dispatch complete. new state: '\" + newState + \"'.\");\n        }\n    };\n\n    /**\n     * Helper for testing state name\n     * @memberof! respoke.CallState\n     * @method respoke.Call.isState\n     * @param {string} name\n     * @returns {boolean}\n     */\n    that.isState = function (name) {\n        return (that.getState() === name);\n    };\n\n    assert(typeof that.hasMedia === 'function');\n    assert(typeof that.caller === 'boolean');\n    return that;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/callState.js\n ** module id = 20\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar respoke = require('./respoke');\nvar log = respoke.log;\n\n/**\n * A `respoke.Call` is Respoke's interface into a WebRTC call, including getUserMedia,\n * path and codec negotation, and call state.\n * There are several methods on an instance of `respoke.Client` which return a `respoke.Call`.\n *\n * ```\n * var jim = client.getEndpoint({ id: 'jim' });\n * var call = jim.startAudioCall();\n * ```\n *\n * @class respoke.Call\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.instanceId - client id\n * @param {boolean} params.caller - whether or not we initiated the call\n * @param {boolean} [params.receiveOnly] - whether or not we accept media\n * @param {boolean} [params.sendOnly] - whether or not we send media\n * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n * relay servers. If it cannot flow through relay servers, the call will fail.\n * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n * required to flow peer-to-peer. If it cannot, the call will fail.\n * @param {respoke.Endpoint} params.remoteEndpoint - The endpoint who is being called.\n * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint.\n * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n * wants to perform an action between local media becoming available and calling approve().\n * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n * @param {function} params.signalReport - Signaling action from SignalingChannel.\n * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n * @param {Array<RTCConstraints>} params.constraints - Array of WebRTC constraints. This is ignored when\n * `params.outgoingMedia` is passed into the Call object.\n * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n * media renegotiation.\n * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n * element with the local audio and/or video attached.\n * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n * it was ended in a graceful manner.\n * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n * This callback will be called when media is muted or unmuted.\n * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n * for the user to give permission to start getting audio or video.\n * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n * the approval was automatic.\n * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n * granted by the browser without asking the user to approve it.\n * @param {respoke.Call.onToneSent} [params.onToneSent] - Callback for when a DTMF tone gets sent from the client.\n * @param {respoke.Call.onToneSendingStarted} [params.onToneSendingStarted] - Callback for when DTMF tones\n * have started sending.\n * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local\n * video attached to it.\n * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote\n * @param {respoke.LocalMedia} params.outgoingMedia - Pass in an optional LocalMedia object to override the one that is\n * built automatically when establishing the call. When this is defined then any constraints passed to the\n * call are ignored since the media object already exists.\n * video attached to it.\n * @returns {respoke.Call}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Call\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;\n    delete that.outgoingMedia;\n\n    /**\n     * A name to identify the type of object.\n     * @memberof! respoke.Call\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Call';\n\n    /**\n     * Whether or not the client is the caller of the call.\n     * @memberof! respoke.Call\n     * @name caller\n     * @type {boolean}\n     */\n    that.caller = !!that.caller;\n    Object.defineProperty(that, \"initiator\", {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            log.warn(\"The call.initiator flag is deprecated. Please use call.caller instead.\");\n            return that.caller;\n        },\n        set: function () {\n            // ignore\n        }\n    });\n\n    if (!that.caller) {\n        // Don't let Respoke.js pass any default constraints if we're accepting the call. We have no freaking clue\n        // what kind of media we are expected to provide at this point.\n        delete params.constraints;\n        that.constraints = [];\n    }\n\n    /**\n     * The call ID.\n     * @memberof! respoke.Call\n     * @name id\n     * @type {string}\n     */\n    that.id = that.caller ? respoke.makeGUID() : that.id;\n\n    // log the call id to the console for debugging purposes. Do not change this to `respoke.log`!\n    console.log(\"[Respoke] Creating call. id='\" + that.id + \"'\");\n\n    if (!that.id) {\n        throw new Error(\"Can't start a new call without a call id.\");\n    }\n\n    /**\n     * Promise used to trigger actions dependant upon having received media or a datachannel.\n     * @memberof! respoke.Call\n     * @name defMedia\n     * @private\n     * @type {Promise}\n     */\n    var defMedia = Q.defer();\n    /**\n     * Promise used to trigger notification of a request for renegotiating media. For the caller of the\n     * renegotiation (which doesn't have to be the same as the caller of the call), this is resolved\n     * or rejected as soon as the 'accept' or 'reject' signal is received. For the callee, it is\n     * resolved or rejected only after the developer or user approves or rejects the modify.\n     * @memberof! respoke.Call\n     * @name defModify\n     * @private\n     * @type {Promise}\n     */\n    var defModify;\n    /**\n     * @memberof! respoke.Call\n     * @name previewLocalMedia\n     * @private\n     * @type {respoke.Call.previewLocalMedia}\n     */\n    var previewLocalMedia = params.previewLocalMedia;\n    /**\n     * @memberof! respoke.Call\n     * @name client\n     * @private\n     * @type {respoke.getClient}\n     */\n    var client = respoke.getClient(instanceId);\n    /**\n     * @memberof! respoke.Call\n     * @name signalingChannel\n     * @private\n     * @type {respoke.signalingChannel}\n     */\n    var signalingChannel = params.signalingChannel;\n\n    /**\n     * Informational property. Whether call debugs were enabled on the client during creation.\n     * Changing this value will do nothing.\n     * @name enableCallDebugReport\n     * @type {boolean}\n     */\n    that.enableCallDebugReport = params.signalingChannel.isSendingReport();\n\n    /**\n     * Informational property indicating if this call has fired the public 'connect' event\n     * inside receiveRemoteMedia.\n     * @name hasReceivedRemoteMedia\n     * @type {boolean}\n     * @private\n     */\n    var hasReceivedRemoteMedia = false;\n\n    /**\n     * @memberof! respoke.Call\n     * @name pc\n     * @private\n     * @type {respoke.PeerConnection}\n     */\n    var pc = respoke.PeerConnection({\n        instanceId: instanceId,\n        state: respoke.CallState({\n            instanceId: instanceId,\n            caller: that.caller,\n            needDirectConnection: params.needDirectConnection,\n            sendOnly: params.sendOnly,\n            receiveOnly: params.receiveOnly,\n            // hasMedia is not defined yet.\n            hasMedia: function () {\n                return that.hasMedia();\n            }\n        }),\n        forceTurn: !!params.forceTurn,\n        call: that,\n        pcOptions: {\n            optional: [\n                { DtlsSrtpKeyAgreement: true },\n                { RtpDataChannels: false }\n            ]\n        },\n        offerOptions: params.offerOptions || null,\n        signalOffer: function (args) {\n            if (!pc) {\n                return;\n            }\n\n            params.signalOffer(args);\n            pc.state.dispatch('sentOffer');\n        },\n        signalConnected: params.signalConnected,\n        signalAnswer: params.signalAnswer,\n        signalModify: params.signalModify,\n        signalHangup: params.signalHangup,\n        signalReport: params.signalReport,\n        signalCandidate: params.signalCandidate\n    });\n\n    /**\n     * Array of streams of local media that we are sending to the remote party.\n     * @name outgoingMediaStreams\n     * @type {Array<respoke.LocalMedia>}\n     */\n    that.outgoingMediaStreams = [];\n    that.outgoingMediaStreams.hasAudio = function () {\n        if (that.outgoingMediaStreams.length === 0) {\n            return false;\n        }\n\n        return !that.outgoingMediaStreams.every(function (stream) {\n            return stream.getAudioTracks().length === 0;\n        });\n    };\n\n    that.outgoingMediaStreams.hasVideo = function () {\n        if (that.outgoingMediaStreams.length === 0) {\n            return false;\n        }\n\n        return !that.outgoingMediaStreams.every(function (stream) {\n            return stream.getVideoTracks().length === 0;\n        });\n    };\n\n    if (params.outgoingMedia) {\n        that.outgoingMediaStreams.push(params.outgoingMedia);\n    }\n\n    /**\n     * Local media that we are sending to the remote party. This will be undefined if we are sending no media.\n     * This property is just the first item in the `outgoingMediaStreams` array. If multiple streams are present,\n     * use that array to find the stream you need instead of relying on this property.\n     * @name outgoingMedia\n     * @type {respoke.LocalMedia}\n     */\n    Object.defineProperty(that, \"outgoingMedia\", {\n        configurable: false,\n        enumerable: true,\n        get: function () {\n            return that.outgoingMediaStreams[0];\n        },\n        set: function () {\n            // ignore\n        }\n    });\n\n    /**\n     * Array of streams of remote media that we are receiving from the remote party.\n     * @name incomingMediaStreams\n     * @type {Array<respoke.RemoteMedia>}\n     */\n    that.incomingMediaStreams = [];\n    that.incomingMediaStreams.hasAudio = function () {\n        if (that.incomingMediaStreams.length === 0) {\n            return false;\n        }\n\n        return !that.incomingMediaStreams.every(function (stream) {\n            return stream.getAudioTracks().length === 0;\n        });\n    };\n\n    that.incomingMediaStreams.hasVideo = function () {\n        if (that.incomingMediaStreams.length === 0) {\n            return false;\n        }\n\n        return !that.incomingMediaStreams.every(function (stream) {\n            return stream.getVideoTracks().length === 0;\n        });\n    };\n\n    /**\n     * Remote media that we are receiving from the remote party.  This will be undefined if we\n     * are receiving no media. This property is just the first item in the `incomingMediaStreams` array. If multiple\n     * streams are present, use that array to find the stream you need instead of relying on this property.\n     * @name incomingMedia\n     * @type {respoke.RemoteMedia}\n     */\n    Object.defineProperty(that, \"incomingMedia\", {\n        configurable: false,\n        enumerable: true,\n        get: function () {\n            return that.incomingMediaStreams[0];\n        },\n        set: function () {\n            // ignore\n        }\n    });\n\n    /**\n     * A flag indicating whether this call has audio or is expected to have audio coming in from the other side.\n     *\n     * @name hasAudio\n     * @type {boolean}\n     */\n    Object.defineProperty(that, \"hasAudio\", {\n        configurable: false,\n        enumerable: true,\n        get: that.incomingMediaStreams.hasAudio,\n        set: function () {\n            // ignore\n        }\n    });\n\n    /**\n     * A flag indicating whether this call has video or is expected to have video coming in from the other side.\n     *\n     * @name hasVideo\n     * @type {boolean}\n     */\n    Object.defineProperty(that, \"hasVideo\", {\n        configurable: false,\n        enumerable: true,\n        get: that.incomingMediaStreams.hasVideo,\n        set: function () {\n            // ignore\n        }\n    });\n\n    delete params.signalingChannel;\n    delete that.signalingChannel;\n\n    /**\n     * @memberof! respoke.Call\n     * @name videoIsMuted\n     * @private\n     * @type {boolean}\n     */\n    var videoIsMuted = false;\n    /**\n     * @memberof! respoke.Call\n     * @name audioIsMuted\n     * @private\n     * @type {boolean}\n     */\n    var audioIsMuted = false;\n    /**\n     * @memberof! respoke.Call\n     * @name directConnection\n     * @private\n     * @type {respoke.DirectConnection}\n     */\n    var directConnection = null;\n\n    /**\n     * Register any event listeners passed in as callbacks, save other params to answer() and accept().\n     * @memberof! respoke.Call\n     * @method respoke.Call.saveParameters\n     * @param {object} params\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n     * it was ended in a graceful manner.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will fire even if\n     * the approval was automatic.\n     * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n     * user's media.  This event gets fired even if the allow process is automatic, i. e., permission and media is\n     * granted by the browser without asking the user to approve it.\n     * @param {respoke.Call.onToneSent} [params.onToneSent] - Callback for when a DTMF tone gets sent from the client.\n     * @param {Array<RTCConstraints>} [params.constraints]\n     * @param {boolean} [params.forceTurn]\n     * @param {boolean} [params.receiveOnly]\n     * @param {boolean} [params.sendOnly]\n     * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n     * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local\n     * video attached to it.\n     * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote\n     * video attached to it.\n     * @private\n     * @fires respoke.Call#stats\n     */\n    function saveParameters(params) {\n        if (!pc) {\n            /* This happens when the call is hung up automatically, for instance due to the lack of an onCall\n             * handler. In this case, pc has been set to null in hangup. The call has already failed, and the\n             * invocation of this function is an artifact of async code not being finished yet, so we can just\n             * skip all of this setup.\n             */\n            return;\n        }\n\n        that.listen('local-stream-received', params.onLocalMedia);\n        that.listen('remote-stream-received', params.onRemoteMedia);\n        that.listen('connect', params.onConnect);\n        that.listen('hangup', params.onHangup);\n        that.listen('allow', params.onAllow);\n        that.listen('answer', params.onAnswer);\n        that.listen('approve', params.onApprove);\n        that.listen('mute', params.onMute);\n        that.listen('requesting-media', params.onRequestingMedia);\n        that.listen('tone-sent', params.onToneSent);\n        that.listen('tone-sending-started', params.onToneSendingStarted);\n        that.listen('tone-sending-cancelled', params.onToneSendingCancelled);\n\n        previewLocalMedia = typeof params.previewLocalMedia === 'function' ?\n            params.previewLocalMedia : previewLocalMedia;\n\n        pc.state.receiveOnly = typeof params.receiveOnly === 'boolean' ? params.receiveOnly : pc.state.receiveOnly;\n        pc.state.sendOnly = typeof params.sendOnly === 'boolean' ? params.sendOnly : pc.state.sendOnly;\n        pc.state.needDirectConnection = typeof params.needDirectConnection === 'boolean' ?\n            params.needDirectConnection : pc.state.needDirectConnection;\n        pc.disableTurn = typeof params.disableTurn === 'boolean' ? params.disableTurn : !!pc.disableTurn;\n        pc.forceTurn = typeof params.forceTurn === 'boolean' ? params.forceTurn : !!pc.forceTurn;\n\n        that.videoLocalElement = params.videoLocalElement ? params.videoLocalElement : that.videoLocalElement;\n        that.videoRemoteElement = params.videoRemoteElement ? params.videoRemoteElement : that.videoRemoteElement;\n\n        if (pc.state.receiveOnly) {\n            that.outgoingMediaStreams.length = 0;\n            that.constraints = [];\n        } else if (params.constraints) {\n            that.constraints = respoke.convertConstraints(params.constraints);\n            updateOutgoingMediaEstimate({constraints: that.constraints[0], source: params.source});\n        }\n\n        if (pc.state.sendOnly) {\n            that.incomingMediaStreams.length = 0;\n        } else if (params.constraints && pc.state.caller === true && that.incomingMediaStreams.length === 0) {\n            // TODO above condition is not good enough for media renegotiation.\n            // Only the person who initiated this round of media negotiation needs to estimate remote\n            // media based on what constraints local media is using.\n            // Also don't try to guess what media they'll send back if we're sending more than one stream.\n            that.constraints = respoke.convertConstraints(params.constraints);\n            updateIncomingMediaEstimate({constraints: params.constraints[0]});\n        }\n\n        pc.listen('stats', function fireStats(evt) {\n            /**\n             * This event is fired every time statistical information about audio and/or video on a call\n             * becomes available.\n             * @event respoke.Call#stats\n             * @type {respoke.Event}\n             * @property {respoke.MediaStats} stats - an object with stats in it.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.fire('stats', {stats: evt.stats});\n        }, true);\n\n        delete that.signalOffer;\n        delete that.signalConnected;\n        delete that.signalAnswer;\n        delete that.signalHangup;\n        delete that.signalReport;\n        delete that.signalCandidate;\n    }\n\n    /**\n     * Build respoke.LocalMedia after the call is answered.\n     * @memberof! respoke.Call\n     * @method respoke.Call.buildLocalMedia\n     * @param {RTCConstraint} constraint\n     * @private\n     */\n    function buildLocalMedia(constraint) {\n        var localMedia;\n\n        if (pc.state.receiveOnly) {\n            return Q.reject(new Error(\"Shouldn't have requested local media when receiveOnly is true.\"));\n        }\n\n        if (constraint.className === 'respoke.LocalMedia') {\n            localMedia = constraint;\n        } else {\n            localMedia = respoke.LocalMedia({\n                hasScreenShare: respoke.constraintsHasScreenShare(constraint),\n                constraints: constraint,\n                source: params.source\n            });\n            that.outgoingMediaStreams.push(localMedia);\n        }\n\n        // use passed video element if localMedia constraints contain video\n        if (respoke.constraintsHasVideo(localMedia.constraints)) {\n            localMedia.element = that.videoLocalElement;\n        }\n\n        localMedia.listen('requesting-media', function waitAllowHandler(evt) {\n            if (!pc) {\n                return;\n            }\n\n            /**\n             * The browser is asking for permission to access the User's media. This would be an ideal time\n             * to modify the UI of the application so that the user notices the request for permissions\n             * and approves it.\n             * @event respoke.Call#requesting-media\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.Call} target\n             */\n            that.fire('requesting-media');\n        }, true);\n\n        localMedia.listen('allow', function allowHandler(evt) {\n            if (!pc) {\n                return;\n            }\n\n            /**\n             * The user has approved the request for media. Any UI changes made to remind the user to click Allow\n             * should be canceled now. This event is the same as the `onAllow` callback.  This event gets fired\n             * even if the allow process is automatic, i. e., permission and media is granted by the browser\n             * without asking the user to approve it.\n             * @event respoke.Call#allow\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.Call} target\n             */\n            that.fire('allow');\n            pc.state.dispatch('approve', {\n                previewLocalMedia: previewLocalMedia\n            });\n        }, true);\n\n        return localMedia.start().then(function () {\n            streamReceivedHandler(localMedia);\n        });\n    }\n\n    /**\n     * Answer the call and start the process of obtaining media. This method is called automatically on the caller's\n     * side. This method must be called on the callee's side to indicate that the endpoint does wish to accept the\n     * call. The app will have a later opportunity, by passing a callback named previewLocalMedia, to approve or\n     * reject the call based on whether audio and/or video is working and is working at an acceptable level.\n     *\n     *     client.listen('call', function (evt) {\n     *         if (!evt.call.caller) {\n     *             evt.call.answer();\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.answer\n     * @fires respoke.Call#answer\n     * @param {object} [params]\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached. Corresponds to 'local-stream-received' event.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback indicating that the call is connected.\n     * This is fired once. Corresponds to 'connect' event.\n     * @param {respoke.Call.onRemoteMedia} [params.onRemoteMedia] - Callback called every time a remote\n     * stream is added to the call. Corresponds to 'remote-stream-received' event.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n     * it was ended in a graceful manner. Corresponds to 'hangup' event.\n     * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n     * This callback will be called when media is muted or unmuted.\n     * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n     * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n     * for the user to give permission to start getting audio or video.\n     * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n     * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n     * the approval was automatic.\n     * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n     * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n     * granted by the browser without asking the user to approve it.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {boolean} [params.receiveOnly] - Whether or not we accept media.\n     * @param {boolean} [params.sendOnly] - Whether or not we send media.\n     * @param {Array<RTCConstraints>} [params.constraints] - Pass in media constraints to specialize\n     * the media requested from the user.\n     * @param {HTMLVideoElement} [params.videoLocalElement] - Pass in an html video element to have local\n     * video attached to it, instead of having a video element created.\n     * @param {HTMLVideoElement} [params.videoRemoteElement] - Pass in an html video element to have remote\n     * video attached to it, instead of having a video element created.\n     */\n    that.answer = function (params) {\n        log.debug('Call.answer', params);\n        params = params || {};\n\n        saveParameters(params);\n\n        pc.listen('stream-added', onRemoteStreamAdded, true);\n        pc.listen('stream-removed', onRemoteStreamRemoved, true);\n\n        pc.state.dispatch('answer', {\n            previewLocalMedia: previewLocalMedia,\n            approve: that.approve\n        });\n\n        /**\n         * The call was answered.\n         * @event respoke.Call#answer\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('answer');\n    };\n\n    /**\n     * Accept a request to modify the media on the call. This method should be called within the Call#modify\n     * event listener, which gives the developer or website user a chance to see what changes are proposed and\n     * to accept or reject them.\n     *\n     *     call.listen('modify', function (evt) {\n     *         evt.call.accept();\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.accept\n     * @fires respoke.Call#accept\n     * @private\n     * @param {object} [params]\n     * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n     * wants to perform an action between local media becoming available and calling approve().\n     * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n     * element with the local audio and/or video attached.\n     * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the developer to receive the\n     * remote video element.\n     * @param {respoke.Call.onHangup} [params.onHangup] - Callback for the developer to be notified about hangup.\n     * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n     * required to flow peer-to-peer. If it cannot, the call will fail.\n     * @param {boolean} [params.receiveOnly] - Whether or not we accept media.\n     * @param {boolean} [params.sendOnly] - Whether or not we send media.\n     * @param {Array<RTCConstraints>} [params.constraints] - Information about the media for this call.\n     */\n    that.accept = that.answer;\n\n    /**\n     * Start the process of network and media negotiation. If the app passes in a callback named previewLocalMedia\n     * in order to allow the logged-in person a chance to base their decision to continue the call on whether\n     * audio and/or video is working correctly,\n     * this method must be called on both sides in order to begin the call. If call.approve() is called, the call\n     * will progress as expected. If call.reject() is called, the call will be aborted.\n     *\n     *     call.listen('local-stream-received', function (evt) {\n     *         if (userLikesVideo()) {\n     *             evt.call.approve();\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.approve\n     * @fires respoke.Call#approve\n     */\n    that.approve = function () {\n        log.debug('Call.approve');\n        /**\n         * Fired when the local media access is approved.\n         * @event respoke.Call#approve\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('approve');\n        pc.state.dispatch('approve', {\n            previewLocalMedia: previewLocalMedia\n        });\n\n        if (defModify && defModify.promise.isPending()) {\n            defModify.resolve(true);\n            defModify = undefined;\n        }\n    };\n\n    /**\n     * Listen for the remote side to remove media in the middle of the call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.onRemoteStreamRemoved\n     * @private\n     * @param {object}\n     */\n    function onRemoteStreamRemoved(evt) {\n        log.debug('pc event: remote stream removed');\n        pc.state.dispatch('removeRemoteMedia');\n    }\n\n    /**\n     * Listen for the remote side to add additional media in the middle of the call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.onRemoteStreamAdded\n     * @private\n     * @param {object}\n     * @fires respoke.Call#connect\n     */\n    function onRemoteStreamAdded(evt) {\n        var hasAudio = false;\n        var hasVideo = false;\n        var hasScreenShare = false;\n        var remoteMedia;\n\n        if (!pc) {\n            return;\n        }\n        log.debug('received remote media', evt);\n\n        // This is the first remote media we have received. The one we currently have is a guess. Rip it\n        // out and replace it with reality.\n        if (that.incomingMediaStreams.length === 1 && that.incomingMediaStreams[0].temporary === true) {\n            // have to do it this way because assigning a blank array to that.incomingMediaStreams will\n            // clobber the methods like hasAudio that we have added to the array.\n            that.incomingMediaStreams.length = 0;\n        }\n        if (that.incomingMediaStreams.length) {\n            while (that.incomingMediaStreams.length) {\n                log.debug('onRemoteStreamAdded removing incoming stream', that.incomingMediaStreams[0]);\n                that.incomingMediaStreams.shift().stop();\n            }\n        }\n        hasAudio = evt.stream.getAudioTracks().length > 0;\n        hasVideo = evt.stream.getVideoTracks().length > 0;\n        // TODO this is not good enough long term.\n        hasScreenShare = hasVideo && that.target === 'screenshare';\n\n        remoteMedia = respoke.RemoteMedia({\n            element: that.videoRemoteElement,\n            stream: evt.stream,\n            hasScreenShare: hasScreenShare,\n            constraints: {\n                audio: hasAudio,\n                video: hasVideo\n            }\n        });\n        that.incomingMediaStreams.push(remoteMedia);\n\n        pc.state.dispatch('receiveRemoteMedia');\n\n        if (!hasReceivedRemoteMedia) {\n            hasReceivedRemoteMedia = true;\n            /**\n             * Indicates that either remote media stream has been added to the call or if no\n             * media is expected, the other side is receiving our media. This will fire once,\n             * when the remote media becomes available.\n             * @event respoke.Call#connect\n             * @type {respoke.Event}\n             * @property {Element} element - The HTML5 Video element with the remote stream attached.\n             * @property {respoke.RemoteMedia} stream - The incomingMedia property on the call.\n             * @property {string} name - The event name.\n             * @property {respoke.Call} target\n             */\n            that.fire('connect', {\n                stream: remoteMedia.stream,\n                element: remoteMedia.element\n            });\n        }\n\n        /**\n         * Fires every time a new remote media stream is added to the call.\n         * @event respoke.Call#onRemoteMedia\n         * @type {respoke.Event}\n         * @property {Element} element - The HTML5 Video element with the remote stream attached.\n         * @property {respoke.RemoteMedia} stream - The incomingMedia property on the call.\n         * @property {string} name - The event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('remote-stream-received', {\n            stream: remoteMedia.stream,\n            element: remoteMedia.element\n        });\n    }\n\n    /**\n     * ## The plugin `respoke.MediaStats` must be loaded before using this method.\n     *\n     * Start the process of listening for a continuous stream of statistics about the flow of audio and/or video.\n     * Since we have to wait for both the answer and offer to be available before starting\n     * statistics, the library returns a promise for the stats object. The statistics object does not contain the\n     * statistics; rather it contains methods of interacting with the actions of obtaining statistics. To obtain\n     * the actual statistics one time, use stats.getStats(); use the onStats callback to obtain a continuous\n     * stream of statistics every `interval` seconds.  Returns null if stats module is not loaded.\n     *\n     *     call.getStats({\n     *         onStats: function (evt) {\n     *             console.log('Stats', evt.stats);\n     *         }\n     *     }).done(function () {\n     *         console.log('Stats started');\n     *     }, function (err) {\n     *         console.log('Call is already hung up.');\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.getStats\n     * @param {object} params\n     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive\n     * the stats. If no callback is provided, the call's report will contain stats but the developer will not\n     * receive them on the client-side.\n     * @param {respoke.Call.statsSuccessHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Call.errorHandler} [params.onError] - Error handler for this invocation of this method only.\n     * @returns {Promise<object>|null}\n     */\n    function getStats(params) {\n        if (pc && pc.getStats) {\n            that.listen('stats', params.onStats);\n            return pc.getStats(params);\n        }\n        return null;\n    }\n    if (respoke.MediaStats) {\n        that.getStats = getStats;\n    }\n\n    /**\n     * Return local video element with the logged-in endpoint's audio and/or video streams attached to it.\n     *\n     *     var el = call.getLocalElement();\n     *     container.append(el);\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.getLocalElement\n     * @returns {Video} An HTML5 video element.\n     */\n    that.getLocalElement = function () {\n        return that.outgoingMediaStreams[0] ? that.outgoingMediaStreams[0].element : undefined;\n    };\n\n    /**\n     * Return remote video element with the remote endpoint's audio and/or video streams attached to it.\n     *\n     *     var el = call.getRemoteElement();\n     *     container.append(el);\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.getRemoteElement\n     * @returns {Video} An HTML5 video element.\n     */\n    that.getRemoteElement = function () {\n        return that.incomingMediaStreams[0] ? that.incomingMediaStreams[0].element : undefined;\n    };\n\n    /**\n     * Set up the local media.\n     * @memberof! respoke.Call\n     * @method respoke.Call.streamReceivedHandler\n     * @param {respoke.LocalMedia} localMedia\n     * @private\n     */\n    function streamReceivedHandler(localMedia) {\n        if (!pc) {\n            return;\n        }\n\n        pc.addLocalTracksFromStream(localMedia.stream);\n        if (typeof previewLocalMedia === 'function' && localMedia.element) {\n            previewLocalMedia(localMedia.element, that);\n        }\n\n        localMedia.listen('stop', function stopHandler(/* evt */) {\n            // remove the media from the call's outgoing streams\n\n            var idx = that.outgoingMediaStreams.indexOf(localMedia);\n            if (idx > -1) {\n                that.outgoingMediaStreams.splice(idx, 1);\n            }\n\n            // TODO: See about adding this back\n            // if (!that.outgoingMediaStreams.length && !that.incomingMediaStreams.length) {\n            //     that.hangup({ reason: 'last stream ended' });\n            // }\n        }, true);\n\n        /**\n         * Indicate that the call has received local media from the browser.\n         * @event respoke.Call#local-stream-received\n         * @type {respoke.Event}\n         * @property {Element} element\n         * @property {respoke.LocalMedia} stream\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('local-stream-received', {\n            element: localMedia.element,\n            stream: localMedia\n        });\n\n        /**\n         * This event indicates that local video has been unmuted.\n         * @event respoke.Call#mute\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        localMedia.listen('mute', function (evt) {\n            that.fire('mute', {\n                type: evt.type,\n                muted: evt.muted\n            });\n        }, true);\n    }\n\n    /**\n     * Retrieve the constraints that describe the currently flowing outgoing media.\n     * TODO: we can probably use that.constraints instead\n     * @returns { audio, video }\n     * @private\n     */\n    function getOutgoingConstraints() {\n        return that.outgoingMediaStreams.reduce(function (constraints, localMedia) {\n            if (localMedia.temporary) {\n                return constraints;\n            }\n            localMedia.stream.getTracks().forEach(function (track) {\n                if (track.kind === 'audio') {\n                    constraints.audio = true;\n                } else {\n                    constraints.video = true;\n                }\n            });\n\n            return constraints;\n        }, { audio: false, video: false });\n    }\n\n    /**\n     * Renegotiate the call to have media that matches the passed constraints.\n     *\n     * @param {object} params\n     * @param {object|Array} params.constraints The constraints to renegotiate to\n     * @returns {Promise}\n     * @private\n     */\n    that.changeMedia = function changeMedia(params) {\n        log.debug('Call.changeMedia', params);\n        params = params || {};\n\n        if (!params.constraints || !params.constraints.length) {\n            return Q.reject(new Error('at least one set of constraints is required to change media'));\n        }\n\n        params.instanceId = instanceId;\n\n        pc.startModify({\n            constraints: params.constraints\n        });\n\n        defModify = Q.defer();\n        defModify.promise.then(function modifyAccepted() {\n            saveParameters(params);\n        });\n\n        return defModify.promise;\n    };\n\n    /**\n     * Renegotiate the call to add video. If a video track is already present\n     * on the call, no action will be taken and the promise will immediately resolve.\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.addVideo\n     * @returns {Promise}\n     * @private\n     */\n    that.addVideo = function () {\n        log.debug('Call.addVideo');\n        var outgoingConstraints = getOutgoingConstraints();\n\n        if (outgoingConstraints.video) {\n            log.debug('Call already contains an outgoing video track');\n            return Q.resolve();\n        }\n\n        return that.changeMedia({\n            constraints: [{\n                audio: outgoingConstraints.audio,\n                video: true\n            }]\n        });\n    };\n\n    /**\n     * Renegotiate the call to remove video. If a video track is not already present\n     * on the call, no action will be taken and the promise will immediately resolve.\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.addVideo\n     * @returns {Promise}\n     * @private\n     */\n    that.removeVideo = function () {\n        log.debug('Call.removeVideo');\n        var outgoingConstraints = getOutgoingConstraints();\n\n        if (!outgoingConstraints.video) {\n            log.debug('Call does not contain an outgoing video track');\n            return Q.resolve();\n        }\n\n        return that.changeMedia({\n            constraints: [{\n                audio: outgoingConstraints.audio,\n                video: false\n            }]\n        });\n    };\n\n    /**\n     * Renegotiate the call to add audio. If an audio track is already present\n     * on the call, no action will be taken and the promise will immediately resolve.\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.addVideo\n     * @returns {Promise}\n     * @private\n     */\n    that.addAudio = function () {\n        log.debug('Call.addAudio');\n        var outgoingConstraints = getOutgoingConstraints();\n\n        if (outgoingConstraints.audio) {\n            log.debug('Call already contains an outgoing audio track');\n            return Q.resolve();\n        }\n\n        return that.changeMedia({\n            constraints: [{\n                audio: true,\n                video: outgoingConstraints.video\n            }]\n        });\n    };\n\n    /**\n     * Renegotiate the call to remove audio. If an audio track is not already present\n     * on the call, no action will be taken and the promise will immediately resolve.\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.addVideo\n     * @returns {Promise}\n     * @private\n     */\n    that.removeAudio = function () {\n        log.debug('Call.removeAudio');\n        var outgoingConstraints = getOutgoingConstraints();\n\n        if (!outgoingConstraints.audio) {\n            log.debug('Call does not contain an outgoing audio track');\n            return Q.resolve();\n        }\n\n        return that.changeMedia({\n            constraints: [{\n                audio: false,\n                video: outgoingConstraints.video\n            }]\n        });\n    };\n\n    /**\n     * Get the direct connection on this call, if it exists.\n     *\n     *     var dc = call.getDirectConnection();\n     *     if (!dc) {\n     *         console.log(\"No direct connection has been started.\");\n     *     } else {\n     *         dc.sendMessage({message: 'hi'});\n     *     }\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.getDirectConnection\n     * @returns {respoke.DirectConnection}\n     */\n    that.getDirectConnection = function () {\n        return directConnection || null;\n    };\n\n    /**\n     * Remove a direct connection from the existing call. If there is no other media, this will hang up the call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.removeDirectConnection\n     * @private\n     * @param {object} params\n     * @arg {boolean} [params.skipModify] Do not restart media negotiation.\n     */\n    that.removeDirectConnection = function (params) {\n        params = params || {};\n        log.debug('Call.removeDirectConnection');\n\n        if (directConnection) {\n            directConnection.close({skipRemove: true});\n        }\n\n        if (!that.hasMedia()) {\n            log.debug('Hanging up because there are no local streams.');\n            that.hangup();\n            return;\n        }\n\n        if (params.skipModify === true) {\n            return;\n        }\n\n        pc.startModify({\n            directConnection: false\n        });\n        defModify = Q.defer();\n        defModify.promise.done(function onModifySuccess() {\n            defMedia.resolve();\n            defModify = undefined;\n        });\n    };\n\n    /**\n     * Add a direct connection to the existing call.\n     *\n     *     call.addDirectConnection({\n     *         onOpen: function (evt) {\n     *             console.log(\"Direct connection open!\");\n     *         }\n     *     });\n     *\n     * @memberof! respoke.Call\n     * @method respoke.Call.addDirectConnection\n     * @private\n     * @param {object} params\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for the developer to be notified about\n     * closing the connection.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for the developer to be notified about\n     * opening the connection.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for the developer to be notified\n     * about incoming messages. Not usually necessary to listen to this event if you are already listening to\n     * respoke.Endpoint#message.\n     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess]\n     * @param {respoke.Client.errorHandler} [params.onError]\n     * @returns {Promise<respoke.DirectConnection>}\n     */\n    that.addDirectConnection = function (params) {\n        log.debug('Call.addDirectConnection');\n        pc.startModify({\n            directConnection: true\n        });\n        defModify = Q.defer();\n        return defModify.promise.then(function onModifySuccess() {\n            return actuallyAddDirectConnection(params);\n        }, function onModifyError(err) {\n            throw err;\n        });\n    };\n\n    /**\n     * Add a direct connection to the existing call.\n     * @memberof! respoke.Call\n     * @method respoke.Call.actuallyAddDirectConnection\n     * @private\n     * @param {object} params\n     * @param {respoke.DirectConnection.onClose} [params.onClose] - Callback for the developer to be notified about\n     * closing the connection.\n     * @param {respoke.DirectConnection.onOpen} [params.onOpen] - Callback for the developer to be notified about\n     * opening the connection.\n     * @param {respoke.DirectConnection.onMessage} [params.onMessage] - Callback for the developer to be notified\n     * about incoming messages. Not usually necessary to listen to this event if you are already listening to\n     * respoke.Endpoint#message.\n     * @param {respoke.Call.directConnectionSuccessHandler} [params.onSuccess]\n     * @param {respoke.Client.errorHandler} [params.onError]\n     * @returns {Promise<respoke.DirectConnection>}\n     * @fires respoke.Client#direct-connection\n     * @fires respoke.Call#direct-connection\n     */\n    function actuallyAddDirectConnection(params) {\n        log.debug('Call.actuallyAddDirectConnection', params);\n        params = params || {};\n        defMedia.promise.then(params.onSuccess, params.onError);\n\n        if (directConnection && directConnection.isActive()) {\n            if (defMedia.promise.isPending()) {\n                defMedia.resolve(directConnection);\n            } else {\n                log.warn(\"Not creating a new direct connection.\");\n            }\n            return defMedia.promise;\n        }\n\n        params.instanceId = instanceId;\n        params.pc = pc;\n        params.call = that;\n\n        directConnection = respoke.DirectConnection(params);\n\n        directConnection.listen('close', function handleDirectConnectionClose() {\n            if (!that.hasMedia()) {\n                log.debug('Hanging up because there are no local streams.');\n                that.hangup();\n            } else {\n                that.removeDirectConnection({skipModify: true});\n            }\n        }, true);\n\n        directConnection.listen('accept', function handleDirectConnectionAccept() {\n            if (pc.state.caller === false) {\n                log.debug('Answering as a result of approval.');\n            } else {\n                defMedia.resolve(directConnection);\n            }\n        }, true);\n\n        directConnection.listen('open', function handleDirectConnectionOpen() {\n            pc.state.dispatch('receiveRemoteMedia');\n        }, true);\n\n        directConnection.listen('error', function handleDirectionConnectionError(err) {\n            defMedia.reject(new Error(err));\n        }, true);\n\n        that.remoteEndpoint.directConnection = directConnection;\n\n        /**\n         * This event is fired when the local end of the directConnection is available. It still will not be\n         * ready to send and receive messages until the 'open' event fires.\n         * @event respoke.Call#direct-connection\n         * @type {respoke.Event}\n         * @property {respoke.DirectConnection} directConnection\n         * @property {respoke.Endpoint} endpoint\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('direct-connection', {\n            directConnection: directConnection,\n            endpoint: that.remoteEndpoint\n        });\n\n        /**\n         * This event is fired when the logged-in endpoint is receiving a request to open a direct connection\n         * to another endpoint.  If the user wishes to allow the direct connection, calling\n         * evt.directConnection.accept() will allow the connection to be set up.\n         * @event respoke.Client#direct-connection\n         * @type {respoke.Event}\n         * @property {respoke.DirectConnection} directConnection\n         * @property {respoke.Endpoint} endpoint\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         * @private\n         */\n        client.fire('direct-connection', {\n            directConnection: directConnection,\n            endpoint: that.remoteEndpoint\n        });\n\n        if (pc.state.caller === true) {\n            directConnection.accept();\n        }\n\n        return defMedia.promise;\n    }\n\n    /**\n     * Close the direct connection.\n     * @memberof! respoke.Call\n     * @method respoke.Call.closeDirectConnection\n     */\n    that.closeDirectConnection = function () {\n        if (directConnection) {\n            directConnection.close();\n            directConnection = null;\n        }\n    };\n\n    /**\n     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n     * signal is not false and we have not received a hangup signal from the remote party.\n     * @memberof! respoke.Call\n     * @method respoke.Call.hangup\n     * @fires respoke.Call#hangup\n     * @param {object} params\n     * @arg {boolean} params.signal Optional flag to indicate whether to send or suppress sending\n     * a hangup signal to the remote side.\n     */\n    that.hangup = respoke.callOnce(function hangup(params) {\n        if (!pc) {\n            return;\n        }\n        params = params || {};\n        params.reason = params.reason || \"hangup method called.\";\n        pc.state.dispatch('hangup', params);\n    });\n\n    /**\n     * Tear down the call, release user media.  Send a hangup signal to the remote party if\n     * signal is not false and we have not received a hangup signal from the remote party. This is an event\n     * handler added to the state machine via `once`.\n     * @memberof! respoke.Call\n     * @method respoke.Call.hangup\n     * @fires respoke.Call#hangup\n     * @private\n     */\n    var doHangup = respoke.callOnce(function doHangup() {\n        log.debug('hangup', that.caller);\n\n        that.outgoingMediaStreams.forEach(function (localMediaInstance) {\n            // only call stop on the localMediaInstance if it was constructed explicitly for the call\n            if (localMediaInstance !== params.outgoingMedia) {\n                localMediaInstance.stop();\n            }\n        });\n\n        if (directConnection) {\n            directConnection.close();\n            directConnection = null;\n        }\n\n        if (pc) {\n            pc.close({signal: (pc.state.receivedBye ? false : pc.state.signalBye)});\n        }\n\n        /**\n         * This event is fired when the call has hung up.\n         * @event respoke.Call#hangup\n         * @type {respoke.Event}\n         * @property {boolean} sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n         * @property {string} name - the event name.\n         * @property {respoke.Call} target\n         */\n        that.fire('hangup', {\n            reason: pc.state.hangupReason || \"No reason specified.\"\n        });\n\n        pc.state.ignore();\n        pc.ignore();\n        that.ignore();\n        pc = null;\n    });\n\n    /**\n     * Expose hangup as reject for approve/reject workflow.\n     * @memberof! respoke.Call\n     * @method respoke.Call.reject\n     * @param {object} params\n     */\n    that.reject = function () {\n        if (!pc) {\n            return;\n        }\n        pc.state.dispatch('reject', {reason: 'call.reject() called'});\n    };\n\n    /**\n     * Indicate whether a call is being setup or is in progress.\n     * @memberof! respoke.Call\n     * @method respoke.Call.isActive\n     * @returns {boolean}\n     */\n    that.isActive = function () {\n        return !!(pc && pc.isActive() && (\n            that.outgoingMediaStreams.length > 0 ||\n            that.incomingMediaStreams.length > 0 ||\n            (directConnection && directConnection.isActive())\n        ));\n    };\n\n    /**\n     * Set the estimated media status on incoming media.\n     * @memberof! respoke.Call\n     * @method respoke.Call.updateIncomingMediaEstimate\n     * @param {object} params\n     * @param {RTCSessionDescriptor} [params.sdp] - optional sdp to use to estimate media\n     * @param {RTCConstraints} [params.constraints] - optional constraints to use to estimate media\n     * @private\n     */\n    function updateIncomingMediaEstimate(params) {\n        if (pc.state.sendOnly) {\n            that.incomingMediaStreams.length = 0;\n            return;\n        }\n\n        if (!params.sdp && !params.constraints) {\n            throw new Error(\"Can't estimate incoming media without sdp or constraints\");\n        }\n\n        if (that.incomingMediaStreams.length === 0) {\n            that.incomingMediaStreams.push(respoke.RemoteMedia({\n                hasScreenShare: (that.target === 'screenshare'),\n                temporary: true\n            }));\n        }\n\n        if (params.sdp) {\n            if (that.incomingMediaStreams[0] && that.incomingMediaStreams[0].temporary) {\n                that.incomingMediaStreams[0].setSDP(params.sdp);\n            }\n        }\n\n        if (params.constraints) {\n            if (that.incomingMediaStreams[0] && that.incomingMediaStreams[0].temporary) {\n                that.incomingMediaStreams[0].setConstraints(params.constraints);\n            }\n        }\n    }\n\n    /**\n     * Set the estimated media status on outgoing media. For this method, by the time we have constraints, we're\n     * already calling getUserMedia so we will have exactly the right information. No need to use constraints\n     * to estimate.\n     * @memberof! respoke.Call\n     * @method respoke.Call.updateOutgoingMediaEstimate\n     * @param {object} params\n     * @param {RTCSessionDescriptor} [params.sdp] - optional sdp to use to estimate media\n     * @param {RTCConstraints} [params.constraints] - optional constraints to use to estimate media\n     * @private\n     */\n    function updateOutgoingMediaEstimate(params) {\n        if (pc.state.receiveOnly) {\n            that.outgoingMediaStreams.length = 0;\n            that.constraints = [];\n            return;\n        }\n\n        if (!params.sdp && !params.constraints) {\n            throw new Error(\"Can't estimate outgoing media without sdp or constraints\");\n        }\n\n        if (that.outgoingMediaStreams.length === 0) {\n            that.outgoingMediaStreams.push(respoke.LocalMedia({\n                instanceId: instanceId,\n                temporary: true,\n                source: params.source\n            }));\n        }\n\n        if (params.sdp) {\n            if (that.outgoingMediaStreams[0] && that.outgoingMediaStreams[0].temporary) {\n                that.outgoingMediaStreams[0].setSDP(params.sdp);\n            }\n        }\n\n        if (params.constraints) {\n            if (that.outgoingMediaStreams[0] && that.outgoingMediaStreams[0].temporary) {\n                that.outgoingMediaStreams[0].setConstraints(params.constraints);\n            }\n        }\n    }\n\n    /**\n     * Save the offer so we can tell the browser about it after the PeerConnection is ready.\n     * Set the estimated media status on incoming and outgoing media.\n     * @memberof! respoke.Call\n     * @method respoke.Call.listenOffer\n     * @param {object} evt\n     * @param {object} evt.signal - The offer signal including the sdp\n     * @private\n     * @fires respoke.Call#modify\n     */\n    function listenOffer(evt) {\n        log.debug('listenOffer', evt.signal);\n\n        that.sessionId = evt.signal.sessionId;\n        pc.state.receiveOnly = respoke.sdpHasSendOnly(evt.signal.sessionDescription.sdp);\n        pc.state.sendOnly = respoke.sdpHasReceiveOnly(evt.signal.sessionDescription.sdp);\n        pc.state.once('connecting:entry', function () {\n            if (!pc.state.caller) {\n                pc.processOffer(evt.signal.sessionDescription);\n            }\n        });\n\n        // Only do this if we're still trying to guess what media is coming in.\n        // TODO not good enough for media renegotiation\n        updateIncomingMediaEstimate({sdp: evt.signal.sessionDescription});\n\n        /*\n         * Always overwrite constraints for callee on every offer, since answer() and accept() will\n         * always be called after parsing the SDP. However, if the caller isn't sending any media,\n         * use audio & video as our estimate.\n         * TODO not good enough for media renegotiation\n         */\n        // If sendOnly, we can't rely on the offer for media estimate. It doesn't have any media in it!\n        if (pc.state.sendOnly) {\n            updateOutgoingMediaEstimate({constraints: {\n                audio: true,\n                video: true\n            }});\n        } else {\n            updateOutgoingMediaEstimate({sdp: evt.signal.sessionDescription});\n        }\n\n        if (that.outgoingMedia) {\n            log.info(\"Default outgoingMedia constraints\", that.outgoingMedia.constraints);\n        }\n\n        pc.state.dispatch('receiveOffer', {\n            previewLocalMedia: previewLocalMedia,\n            approve: that.approve\n        });\n    }\n\n    /**\n     * If video is muted, unmute. If not muted, mute.\n     * @deprecated\n     * @memberof! respoke.Call\n     * @method respoke.Call.toggleVideo\n     */\n    that.toggleVideo = function () {\n        if (that.isActive()) {\n            if (!videoIsMuted) {\n                that.muteVideo();\n            } else {\n                that.unmuteVideo();\n            }\n        }\n    };\n\n    /**\n     * If audio is muted, unmute. If not muted, mute.\n     * @deprecated\n     * @memberof! respoke.Call\n     * @method respoke.Call.toggleAudio\n     */\n    that.toggleAudio = function () {\n        if (that.isActive()) {\n            if (!audioIsMuted) {\n                that.muteAudio();\n            } else {\n                that.unmuteAudio();\n            }\n        }\n    };\n\n    /**\n     * Indicate whether the call has media of any type flowing in either direction.\n     * @memberof! respoke.Call\n     * @method respoke.Call.hasMedia\n     * @returns {boolean}\n     */\n    that.hasMedia = function () {\n        var local;\n        var remote;\n\n        if (!pc || !pc.getLocalStreams) {\n            // PeerConnection.init() has not been called yet\n            return false;\n        }\n\n        local = pc.getLocalStreams();\n        remote = pc.getRemoteStreams();\n\n        if (directConnection && directConnection.isActive()) {\n            return true;\n        }\n\n        return (local.length > 0 || remote.length > 0);\n    };\n\n    /**\n     * Mute all local video streams.\n     * @memberof! respoke.Call\n     * @method respoke.Call.muteVideo\n     * @fires respoke.Call#mute\n     */\n    that.muteVideo = function () {\n        if (videoIsMuted) {\n            return;\n        }\n        that.outgoingMedia.muteVideo();\n        videoIsMuted = true;\n    };\n\n    /**\n     * Unmute all local video streams.\n     * @memberof! respoke.Call\n     * @method respoke.Call.unmuteVideo\n     * @fires respoke.Call#mute\n     */\n    that.unmuteVideo = function () {\n        if (!videoIsMuted) {\n            return;\n        }\n        that.outgoingMedia.unmuteVideo();\n        videoIsMuted = false;\n    };\n\n    /**\n     * Mute all local audio streams.\n     * @memberof! respoke.Call\n     * @method respoke.Call.muteAudio\n     * @fires respoke.Call#mute\n     */\n    that.muteAudio = function () {\n        if (audioIsMuted) {\n            return;\n        }\n        that.outgoingMedia.muteAudio();\n        audioIsMuted = true;\n    };\n\n    /**\n     * Unmute all local audio streams.\n     * @memberof! respoke.Call\n     * @method respoke.Call.unmuteAudio\n     * @fires respoke.Call#mute\n     */\n    that.unmuteAudio = function () {\n        if (!audioIsMuted) {\n            return;\n        }\n\n        that.outgoingMedia.unmuteAudio();\n        audioIsMuted = false;\n    };\n\n    /**\n     * Send DTMF tones to the first audio track on the call. This allows interaction with a phone system expecting keys\n     * to be pressed on a normal phone, such as when calling a company for customer support and having to \"Press 1 for English\".\n     * @memberof! respoke.Call\n     * @method respoke.Call.sendTones\n     * @param {object} params\n     * @param {string} params.tones - The tones to send. Can be any combination of the characters '0123456789ABCD#*', or\n     *  a ',' (comma) to insert a 2 second pause before sending the next tone.\n     * @param {number} [params.duration] - Optional number in milliseconds to indicate how long to play each tone. This\n     *  value needs to be between 40 and 6000. Defaults to 100.\n     * @param {number} [params.gap] - Optional number in mlliseconds to indicate the gap between playing the tones.\n     *  This value needs to be larger than 30. Defaults to 70.\n     * @param {respoke.Call.onSuccess} [params.onSuccess] - Callback called when all requested DTMF tones have been played.\n     * @param {respoke.Call.onError} [params.onError] - Callback called when an error occurs while playing back the DTMF\n     *  tones, or when the request has been cancelled.\n     * @fires respoke.Call#tone-sent\n     * @fires respoke.Call#tone-sending-complete\n     * @returns {Promise}\n     */\n    that.sendTones = function (params) {\n        return pc.sendTones(params);\n    };\n\n    /**\n     * Cancels playback of all queued tones on the first audio track in a stream\n     * @memberof! respoke.Call\n     * @method respoke.Call.cancelTones\n     * @param {respoke.Call.onSuccess} [params.onSuccess] - Callback called when all the outstanding DTMF tones that\n     *  have not yet been played have been cancelled.\n     * @param {respoke.Call.onError} [params.onError] - Callback called when an error occurs while attempting to cancel\n     *  outstanding DTMF tones.\n     * @fires respoke.Call#tone-sending-cancelled\n     * @returns {Promise}\n     */\n    that.cancelTones = function (params) {\n        return pc.cancelTones(params);\n    };\n\n    pc.state.once('terminated:entry', function (evt) {\n        doHangup();\n    }, true);\n\n    /**\n     * Set the estimated media status on incoming media.\n     */\n    that.listen('signal-answer', function handleAnswerSignal(evt) {\n        log.debug('Call handleAnswerSignal', evt);\n\n        that.hasDataChannel = respoke.sdpHasDataChannel(evt.signal.sessionDescription.sdp);\n        updateIncomingMediaEstimate({sdp: evt.signal.sessionDescription});\n    });\n\n    that.listen('signal-offer', function handleOfferSignal(evt) {\n        log.debug('Call handleOfferSignal', evt);\n\n        if (pc.state.getState() === 'idle') {\n            pc.state.once('preparing:entry', function () {\n                listenOffer(evt);\n            });\n        } else {\n            listenOffer(evt);\n        }\n    }, true);\n\n    /**\n     * Save the hangup reason and hang up.\n     */\n    that.listen('signal-hangup', function handleHangupSignal(evt) {\n        log.debug('Call handleHangupSignal', evt);\n\n        if (!pc) {\n            return;\n        }\n\n        pc.report.callStoppedReason = evt.signal.reason || \"Remote side hung up\";\n        pc.state.receivedBye = true;\n        pc.state.dispatch('hangup', {signal: false, reason: pc.report.callStoppedReason});\n    }, true);\n\n    /**\n     * Save the answer and tell the browser about it.\n     */\n    that.listen('signal-modify', function handleModifySignal(evt) {\n        log.debug('Call handleModifySignal', evt);\n\n        if (evt.signal.action === 'initiate') {\n            defModify = Q.defer();\n            pc.state.dispatch('modify', {receive: true});\n        }\n    }, true);\n\n    /**\n     * Ignore the modify.\n     */\n    pc.listen('modify-reject', function handlePeerConnectModifyReject(evt) {\n        log.debug('Call handlePeerConnectModifyReject', evt);\n\n        if (evt.signal.action !== 'initiate') {\n            defMedia.reject(evt.err);\n            defModify.reject(evt.err);\n            defModify = undefined;\n        }\n    }, true);\n\n    /**\n     * Set up state and media for the modify.\n     */\n    pc.listen('modify-accept', function handlePeerConnectionModifyAccept(evt) {\n        log.debug('Call handlePeerConnectionModifyAccept', evt);\n\n        pc.state.dispatch('accept');\n\n        if (evt.signal.action !== 'initiate') {\n            defModify.resolve(); // resolved later for callee\n            defModify = undefined;\n            return;\n        }\n\n        // callee only from here down\n\n        // init the directConnection if necessary. We don't need to do anything with\n        // audio or video right now.\n        if (evt.signal.directConnection === true) {\n            actuallyAddDirectConnection().done(function successHandler(dc) {\n                directConnection = dc;\n                directConnection.accept();\n            });\n        } else if (evt.signal.directConnection === false) {\n            if (directConnection) {\n                that.removeDirectConnection({skipModify: true});\n                defMedia.resolve(false);\n            }\n        }\n        pc.state.needDirectConnection = typeof evt.signal.directConnection === 'boolean' ?\n            evt.signal.directConnection : null;\n        that.outgoingMedia.constraints = evt.signal.constraints || that.outgoingMedia.constraints;\n    }, true);\n\n    /**\n     * Send received ice candidates to the peer connection for processing\n     */\n    that.listen('signal-icecandidates', function handleIceCandidatesSignal(evt) {\n        log.debug('Call handleIceCandidatesSignal', evt);\n\n        if (!pc || !evt.signal.iceCandidates || !evt.signal.iceCandidates.length) {\n            return;\n        }\n        evt.signal.iceCandidates.forEach(function processCandidate(candidate) {\n            if (!pc) {\n                return;\n            }\n            pc.addRemoteCandidate({candidate: candidate});\n        });\n    }, true);\n\n    that.listen('answer', function handleAnswer(evt) {\n        log.debug('Call handleAnswer', evt);\n\n        var mediaPromises = [];\n\n        if (pc.state.receiveOnly || pc.state.needDirectConnection) {\n            that.outgoingMediaStreams.length = 0;\n            return;\n        }\n\n        /*\n         * By the time we get to here, we could be in a couple of states.\n         *\n         * If receiveOnly is set to true, we could possibly have constraints (if the developer used the API wrong)\n         * but we will not have any media in that.outgoingMediaStreams. We should unset that.constraints and skip\n         * building any local media.\n         *\n         * If we have never received any constraints, and receiveOnly is NOT set to true, we will have an estimate\n         * at that.outgoingMediaStreams[0] with temporary set to true. This estimate was set by parsing the SDP.\n         *\n         * If we have received one or more constraints, that.constraints array will contain the most recent set\n         * AND we will have an estimate at that.outgoingMediaStreams[0] with temporary set to true. We must completely\n         * rebuild that.outgoingMediaStreams from that.constraints.\n         */\n        if (pc.state.receiveOnly) {\n            that.outgoingMediaStreams.length = 0;\n            that.constraints = [];\n            return;\n        }\n\n        if (that.constraints.length === 0) {\n            // We didn't get told what to do by constraints; use our guess.\n            that.outgoingMediaStreams[0].temporary = undefined;\n        } else if (that.outgoingMediaStreams.length > 0 && that.outgoingMediaStreams[0].temporary) {\n            // We got told what to do. Discard our guess. It's OK for that.outgoingMediaStreams to be empty now.\n            that.outgoingMediaStreams.shift();\n        }\n\n        // If outgoingMedia is passed into the Call then there is no need to build the LocalMedia here\n        if (params.outgoingMedia) {\n            return;\n        }\n\n        if (that.constraints.length > 0) {\n            if (pc.state.isModifying) {\n                pc.removeLocalTracks();\n            }\n            that.outgoingMediaStreams.length = 0;\n            that.constraints.forEach(function (constraint) {\n                if (!respoke.constraintsHasAudio(constraint) && !respoke.constraintsHasVideo(constraint)) {\n                    return;\n                }\n                mediaPromises.push(buildLocalMedia(constraint));\n            });\n        } else if (that.outgoingMediaStreams.length > 0) {\n            that.outgoingMediaStreams.forEach(function (localMediaInstance) {\n                mediaPromises.push(buildLocalMedia(localMediaInstance));\n            });\n        } else {\n            throw new Error(\"I have no idea what type of media I am supposed to build.\");\n        }\n\n        // These errors are handled elsewhere.\n        Q.all(mediaPromises).done(function () {\n            pc.state.dispatch('receiveLocalMedia');\n        }, function (err) {\n            pc.state.dispatch('reject', {reason: 'media stream error'});\n            pc.report.callStoppedReason = err.message;\n            /**\n             * This event is fired on errors that occur during call setup or media negotiation.\n             * @event respoke.Call#error\n             * @type {respoke.Event}\n             * @property {string} reason - A human readable description about the error.\n             * @property {respoke.Call} target\n             * @property {string} name - the event name.\n             */\n            that.fire('error', {\n                reason: err.message\n            });\n        });\n    }, true);\n\n    if (pc.state.needDirectConnection !== true) {\n        pc.state.once('preparing:entry', function () {\n            /**\n             * This event provides notification for when an incoming call is being received.  If the user wishes\n             * to allow the call, the app should call evt.call.answer() to answer the call.\n             * @event respoke.Client#call\n             * @type {respoke.Event}\n             * @property {respoke.Call} call\n             * @property {respoke.Endpoint} endpoint\n             * @property {string} name - the event name.\n             * @property {respoke.Client} target\n             */\n            client.fire('call', {\n                endpoint: that.remoteEndpoint,\n                call: that\n            });\n        }, true);\n    }\n\n    pc.state.listen('idle:exit', function (evt) {\n        saveParameters(params);\n    });\n\n    /**\n     * Set up promises. If we're not the caller, we need to listen for approval AND\n     * the remote SDP to come in before we can act on the call. Save parameters sent\n     * in with the constructor, then delete them off the call. If this call was initiated\n     * with a DirectConnection, set it up so answer() will be the approval mechanism.\n     */\n    pc.state.listen('preparing:entry', function (evt) {\n        if (defModify !== undefined) {\n            defMedia = Q.defer();\n        }\n\n        pc.init(); // instantiates RTCPeerConnection, can't call on modify\n        if (defModify === undefined && pc.state.needDirectConnection === true) {\n            actuallyAddDirectConnection(params);\n        }\n\n        if (params.outgoingMedia) {\n            streamReceivedHandler(params.outgoingMedia);\n            pc.state.dispatch('receiveLocalMedia');\n        }\n\n        if (pc.state.caller === true) {\n            that.answer();\n        }\n    }, true);\n\n    signalingChannel.getTurnCredentials().then(function (result) {\n        if (!pc) {\n            throw new Error(\"Already hung up.\");\n        }\n        if (!result) {\n            log.warn(\"Relay service not available.\");\n            pc.servers = {iceServers: []};\n        } else {\n            pc.servers = {iceServers: result};\n        }\n    }).fin(function () {\n        if (!pc) {\n            throw new Error(\"Already hung up.\");\n        }\n        pc.state.dispatch('initiate', {\n            caller: that.caller\n        });\n    }).done(null, function (err) {\n        if (err.message !== \"Already hung up.\") {\n            log.debug('Unexpected exception', err);\n        }\n    });\n\n    return that;\n}; // End respoke.Call\n\n/**\n * Handle an error that resulted from a method call.\n * @callback respoke.Call.errorHandler\n * @param {Error} err\n */\n/**\n * Handle the successful kick-off of stats on a call.\n * @callback respoke.Call.statsSuccessHandler\n * @param {respoke.MediaStatsParser} statsParser\n */\n/**\n * Handle obtaining media successfully.\n * @callback respoke.Call.mediaSuccessHandler\n * @param {respoke.LocalMedia} localMedia\n */\n/**\n * When on a call, receive local media when it becomes available. This is what you will need to provide if you want\n * to show the user their own video during a call. This callback is called every time\n * respoke.Call#local-stream-received is fired.\n * @callback respoke.Call.onLocalMedia Callback for receiving an HTML5 Video\n * element with the local audio and/or video attached.\n * @param {respoke.Event} evt\n * @param {Element} evt.element\n * @param {respoke.LocalMedia} - The outgoingMedia property on the call.\n * @param {string} evt.name - The event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * When on a call, receive remote media when it becomes available. This is what you will need to provide if you want\n * to show the user the other party's video during a call. This callback is called every time\n * respoke.Call#connect is fired.\n * @callback respoke.Call.onConnect\n * @param {respoke.Event} evt\n * @param {Element} evt.element - the HTML5 Video element with the new stream attached.\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * When a call is in setup or media renegotiation happens. This callback will be called every time\n * respoke.Call#error.\n * @callback respoke.Call.onError\n * @param {respoke.Event} evt\n * @param {boolean} evt.reason - A human-readable description of the error.\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * When on a call, receive notification the call has been hung up. This callback is called every time\n * respoke.Call#hangup is fired.\n * @callback respoke.Call.onHangup\n * @param {respoke.Event} evt\n * @param {boolean} evt.sentSignal - Whether or not we sent a 'hangup' signal to the other party.\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * Called when changing the mute state on any type of media. This callback will be called when media is muted or\n * unmuted. This callback is called every time respoke.Call#mute is fired.\n * @callback respoke.Call.onMute\n * @param {respoke.Event} evt\n * @param {respoke.Call} evt.target\n */\n/**\n * Called when the callee answers the call. This callback is called every time respoke.Call#answer is fired.\n * @callback respoke.Call.onAnswer\n * @param {respoke.Event} evt\n * @param {respoke.Call} evt.target\n */\n/**\n * Called when the user approves local media. This callback will be called whether or not the approval was based\n * on user feedback. I. e., it will be called even if the approval was automatic. This callback is called every time\n * respoke.Call#approve is fired.\n * @callback respoke.Call.onApprove\n * @param {respoke.Event} evt\n * @param {respoke.Call} evt.target\n */\n/**\n * When setting up a call, receive notification that the browser has granted access to media.  This callback is\n * called every time respoke.Call#allow is fired.\n * @callback respoke.Call.onAllow\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * When setting up a call, receive notification that the app has asked the browser for permission to get audio or\n * video and is waiting on the browser to grant or reject permission. This callback will be called every time\n * respoke.Call#requesting-media is fired.\n * @callback respoke.Call.onRequestingMedia\n * @param {respoke.Event} evt\n * @param {string} evt.name - the event name.\n * @param {respoke.Call} evt.target\n */\n/**\n * The use of stats requires an additional module to Respoke. When on a call, receive periodic statistical\n * information about the call, including the codec, lost packets, and bandwidth being consumed. This callback is\n * called every time respoke.Call#stats is fired.\n * @callback respoke.MediaStatsParser.statsHandler\n * @param {respoke.Event} evt\n * @param {respoke.MediaStats} evt.stats - an object with stats in it.\n * @param {respoke.Call} evt.target\n * @param {string} evt.name - the event name.\n */\n/**\n * When on a call, receive local media when it becomes available. This is what you will need to provide if you want\n * to allow the user to preview and approve or reject their own video before a call. If this callback is provided,\n * Respoke will wait for call.answer() to be called before proceeding. If this callback is not provided,\n * Respoke will proceed without waiting for user input. This callback is called every time\n * respoke.Call#local-stream-received is fired.\n * @callback respoke.Call.previewLocalMedia\n * @param {object} element - the HTML5 Video element with the new stream attached.\n * @param {respoke.Call} call\n */\n/**\n * Called when a tone is sent on an audio track. This callback is called every time respoke.Call#tone-sent is fired.\n * @callback respoke.Call.onToneSent\n * @param {respoke.Event} evt\n * @param {string} evt.tone\n * @param {number} evt.duration\n * @param {number} evt.gap\n */\n/**\n * Called when the playback queue of tones has started.\n * This callback is called every time respoke.Call#tone-sending-started is fired.\n * @callback respoke.Call.onToneSendingStarted\n * @param {respoke.Event} evt\n * @param {object} evt.target\n */\n/**\n * Receive the DirectConnection.\n * @callback respoke.Call.directConnectionSuccessHandler\n * @param {respoke.DirectConnection} directConnection\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/call.js\n ** module id = 21\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar respoke = require('./respoke');\nvar log = respoke.log;\nvar Q = respoke.Q;\n\n/**\n * A wrapper around the stream from `getUserMedia`,\n * which is attached to a call at `call.outgoingMedia`.\n *\n * @class respoke.LocalMedia\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {object} [params.constraints]\n * @param {HTMLVideoElement} params.element - Pass in an optional html video element to have local\n * video attached to it.\n * @returns {respoke.LocalMedia}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = respoke.EventEmitter(params);\n\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.LocalMedia';\n    /**\n     * Respoke media ID (different from a `MediaStream.id`).\n     * @memberof! respoke.LocalMedia\n     * @name id\n     * @type {string}\n     */\n    that.id = respoke.makeGUID();\n    /**\n     * The HTML element with video attached.\n     * @memberof! respoke.LocalMedia\n     * @name element\n     * @type {HTMLVideoElement}\n     */\n    that.element = params.element;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name hasScreenShare\n     * @private\n     * @type {boolean}\n     */\n    var hasScreenShare = params.hasScreenShare;\n    delete params.hasScreenShare;\n\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name screenShareSource\n     * @private\n     * @type {string}\n     */\n    var screenShareSource = params.source;\n    delete params.source;\n\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name sdpHasAudio\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasAudio = false;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name sdpHasVideo\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasVideo = false;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name sdpHasDataChannel\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasDataChannel = false;\n    /**\n     * A timer to make sure we only fire {respoke.LocalMedia#requesting-media} if the browser doesn't\n     * automatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.\n     * @memberof! respoke.LocalMedia\n     * @name allowTimer\n     * @private\n     * @type {number}\n     */\n    var allowTimer = 0;\n    /**\n     * @memberof! respoke.LocalMedia\n     * @name mediaOptions\n     * @private\n     * @type {object}\n     */\n    var mediaOptions = {\n        optional: [\n            { DtlsSrtpKeyAgreement: true },\n            { RtpDataChannels: false }\n        ]\n    };\n\n    /**\n     * The local `MediaStream` from `getUserMedia()`.\n     * @memberof! respoke.LocalMedia\n     * @name stream\n     * @type {RTCMediaStream}\n     */\n    that.stream = null;\n\n    /**\n     * The media deferred whose promise is returned from localMedia.start and resolved with the stream.\n     * @memberof! respoke.LocalMedia\n     * @name deferred\n     * @type {object}\n     * @private\n     */\n    var deferred = Q.defer();\n\n    /**\n     * Save the local stream. Kick off SDP creation.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.onReceiveUserMedia\n     * @private\n     * @param {RTCMediaStream} theStream\n     */\n    function onReceiveUserMedia(theStream) {\n        that.stream = theStream;\n        clearTimeout(allowTimer);\n        /**\n         * The user has approved the request for media. Any UI changes made to remind the user to click Allow\n         * should be canceled now. This event is the same as the `onAllow` callback.  This event gets fired\n         * even if the allow process is automatic, i. e., permission and media is granted by the browser\n         * without asking the user to approve it.\n         * @event respoke.LocalMedia#allow\n         * @type {respoke.Event}\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         */\n        that.fire('allow');\n        log.debug('User gave permission to use media.');\n        log.debug('onReceiveUserMedia');\n\n        that.element = that.element || document.createElement('video');\n\n        that.stream.numPc = 1;\n\n        attachMediaStream(that.element, that.stream);\n        // We won't want our local video outputting audio.\n        that.element.muted = true;\n        that.element.autoplay = true;\n\n        // perform cleanup on the LocalMedia instance if the underlying stream has ended\n        that.stream.addEventListener('ended', that.stop, false);\n        deferred.resolve();\n    }\n\n    /**\n     * Expose getAudioTracks.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.getAudioTracks\n     */\n    that.getAudioTracks = function () {\n        if (that.stream) {\n            return that.stream.getAudioTracks();\n        }\n        return [];\n    };\n\n    /**\n     * Expose getVideoTracks.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.getVideoTracks\n     */\n    that.getVideoTracks = function () {\n        if (that.stream) {\n            return that.stream.getVideoTracks();\n        }\n        return [];\n    };\n\n    /**\n     * Create the RTCPeerConnection and add handlers. Process any offer we have already received.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.requestMedia\n     * @private\n     */\n    function requestMedia() {\n        log.debug('LocalMedia.requestMedia', that.constraints);\n\n        if (!that.constraints) {\n            deferred.reject(new Error('No constraints.'));\n            return;\n        }\n\n        if (respoke.useFakeMedia === true) {\n            that.constraints.fake = true;\n        }\n\n        allowTimer = setTimeout(function delayPermissionsRequest() {\n            /**\n             * The browser is asking for permission to access the User's media. This would be an ideal time\n             * to modify the UI of the application so that the user notices the request for permissions\n             * and approves it.\n             * @event respoke.LocalMedia#requesting-media\n             * @type {respoke.Event}\n             * @property {string} name - the event name.\n             * @property {respoke.LocalMedia} target\n             */\n            that.fire('requesting-media');\n        }, 500);\n\n        if (respoke.constraintsHasScreenShare(that.constraints)) {\n            if (respoke.isNwjs || (respoke.needsChromeExtension && respoke.hasChromeExtension)) {\n                respoke.chooseDesktopMedia({source: screenShareSource}, function (params) {\n                    if (!params.sourceId) {\n                        deferred.reject(new Error(\"Error trying to get screensharing source: \" + params.error));\n                        return;\n                    }\n                    that.constraints.video.mandatory.chromeMediaSourceId = params.sourceId;\n                    log.debug(\"Running getUserMedia with constraints\", that.constraints);\n                    getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n                });\n                return;\n            } else if (respoke.needsFirefoxExtension && respoke.hasFirefoxExtension) {\n                log.debug(\"Running getUserMedia with constraints\", that.constraints);\n                getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n                return;\n            } else {\n                deferred.reject(new Error(\"Screen sharing not implemented on this platform yet.\"));\n                return;\n            }\n        }\n        log.debug(\"Running getUserMedia with constraints\", that.constraints);\n        getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n    }\n\n    /**\n     * Handle any error that comes up during the process of getting user media.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.onUserMediaError\n     * @private\n     * @param {object}\n     */\n    function onUserMediaError(p) {\n        log.debug('Local media error.', p);\n        var errorMessage = p.code === 1 ? \"Permission denied.\" : \"Unknown.\";\n        deferred.reject(new Error(\"Error getting user media: \" + errorMessage));\n    }\n\n    /**\n     * Whether the video stream is muted, or undefined if no stream of this type exists.\n     *\n     * All video tracks must be muted for this to return `false`.\n     * @returns boolean\n     */\n    that.isVideoMuted = function () {\n        if (!that.stream || !that.stream.getVideoTracks().length) {\n            return undefined;\n        }\n\n        return that.stream.getVideoTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };\n\n    /**\n     * Mute local video stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.muteVideo\n     * @fires respoke.LocalMedia#mute\n     */\n    that.muteVideo = function () {\n        if (that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });\n        /**\n         * Indicate that the mute status of local audio or video has changed.\n         * @event respoke.LocalMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'video',\n            muted: true\n        });\n    };\n\n    /**\n     * Unmute local video stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.unmuteVideo\n     * @fires respoke.LocalMedia#mute\n     */\n    that.unmuteVideo = function () {\n        if (!that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });\n        /**\n         * Indicate that the mute status of local audio or video has changed.\n         * @event respoke.LocalMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'video',\n            muted: false\n        });\n    };\n\n    /**\n     * Whether the audio stream is muted, or undefined if no track of this type exists.\n     *\n     * All audio tracks must be muted for this to return `false`.\n     * @returns boolean\n     */\n    that.isAudioMuted = function () {\n        if (!that.stream || !that.stream.getAudioTracks().length) {\n            return undefined;\n        }\n        return that.stream.getAudioTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };\n\n    /**\n     * Mute local audio stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.muteAudio\n     * @fires respoke.LocalMedia#mute\n     */\n    that.muteAudio = function () {\n        if (that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });\n        /**\n         * Indicate that the mute status of local audio or video has changed.\n         * @event respoke.LocalMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'audio',\n            muted: true\n        });\n    };\n\n    /**\n     * Unmute local audio stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.unmuteAudio\n     * @fires respoke.LocalMedia#mute\n     */\n    that.unmuteAudio = function () {\n        if (!that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });\n        /**\n         * Indicate that the mute status of local audio or video has changed.\n         * @event respoke.LocalMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'audio',\n            muted: false\n        });\n    };\n\n    /**\n     * Stop the stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.stop\n     * @fires respoke.LocalMedia#stop\n     */\n    that.stop = function () {\n        if (!that.stream) {\n            return;\n        }\n\n        that.stream.numPc -= 1;\n        if (that.stream.numPc === 0) {\n            that.stream.getTracks().forEach(function (track) {\n                track.stop();\n            });\n        }\n        that.stream = null;\n        /**\n         * Indicate that local media has stopped.\n         * @event respoke.LocalMedia#stop\n         * @property {string} name - the event name.\n         * @property {respoke.LocalMedia} target\n         */\n        that.fire('stop');\n    };\n\n    /**\n     * Indicate whether we are sending a screenshare.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.hasScreenShare\n     * @return {boolean}\n     */\n    that.hasScreenShare = function () {\n        if (that.stream) {\n            return (that.stream.getVideoTracks().length > 0 && hasScreenShare);\n        }\n        return hasScreenShare;\n    };\n\n    /**\n     * Indicate whether we are sending video.\n     *\n     * Note: This method will return true when the video is a screenshare.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.hasVideo\n     * @return {boolean}\n     */\n    that.hasVideo = function () {\n        if (that.stream) {\n            return (that.stream.getVideoTracks().length > 0);\n        }\n        return sdpHasVideo;\n    };\n\n    /**\n     * Indicate whether we are sending audio.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.hasAudio\n     * @return {boolean}\n     */\n    that.hasAudio = function () {\n        if (that.stream) {\n            return (that.stream.getAudioTracks().length > 0);\n        }\n        return sdpHasAudio;\n    };\n\n    /**\n     * Indicate whether we have media yet.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.hasMedia\n     * @return {boolean}\n     */\n    that.hasMedia = function () {\n        return !!that.stream;\n    };\n\n    /**\n     * Save and parse the SDP.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.setSDP\n     * @param {RTCSessionDescription} oSession\n     * @private\n     */\n    that.setSDP = function (oSession) {\n        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n\n        // We don't have media yet & this can still be changed so create the defaults based on what the sdp says.\n        if (that.temporary) {\n            that.constraints = {\n                video: sdpHasVideo,\n                audio: sdpHasAudio,\n                mandatory: {},\n                optional: []\n            };\n        }\n    };\n\n    /**\n     * Parse the constraints.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.setConstraints\n     * @param {MediaConstraints} constraints\n     * @private\n     */\n    that.setConstraints = function (constraints) {\n        that.constraints = constraints;\n        sdpHasVideo = respoke.constraintsHasVideo(that.constraints);\n        sdpHasAudio = respoke.constraintsHasAudio(that.constraints);\n    };\n\n    /**\n     * Start the stream.\n     * @memberof! respoke.LocalMedia\n     * @method respoke.LocalMedia.start\n     * @fires respoke.LocalMedia#start\n     * @param {object} [params]\n     * @param {respoke.Client.successHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n     * method only.\n     * @returns {Promise|undefined}\n     */\n    that.start = function (params) {\n        var retVal;\n        params = params || {};\n\n        if (that.temporary) {\n            deferred.reject(new Error(\"Temporary local media started!\"));\n        } else {\n            requestMedia();\n        }\n\n        retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        return retVal;\n    };\n\n    return that;\n}; // End respoke.LocalMedia\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/localMedia.js\n ** module id = 22\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar respoke = require('./respoke');\n\n/**\n * Class for managing the remote media stream,\n * which is attached to a call at `call.outgoingMedia`.\n *\n * @class respoke.RemoteMedia\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {object} params.constraints\n * @param {boolean} params.temporary - whether this instance represents our best guess of future media. If so,\n * this object will be deleted when real media comes in. It will be replaced by different instance of\n * respoke.RemoteMedia representing the actual state of media.\n * @param {HTMLVideoElement} params.element - Pass in an optional html video element to have remote\n * video attached to it.\n * @returns {respoke.RemoteMedia}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var that = respoke.EventEmitter(params);\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.RemoteMedia';\n    /**\n     * Respoke media ID (different from a `MediaStream.id`).\n     * @memberof! respoke.RemoteMedia\n     * @name id\n     * @type {string}\n     */\n    that.id = respoke.makeGUID();\n    /**\n     * The HTML element with attached video.\n     * @memberof! respoke.RemoteMedia\n     * @name element\n     * @type {HTMLVideoElement}\n     */\n    that.element = params.element || document.createElement('video');\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name hasScreenShare\n     * @private\n     * @type {boolean}\n     */\n    var hasScreenShare = params.hasScreenShare;\n    delete params.hasScreenShare;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name sdpHasAudio\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasAudio = false;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name sdpHasVideo\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasVideo = false;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name sdpHasDataChannel\n     * @private\n     * @type {boolean}\n     */\n    var sdpHasDataChannel = false;\n    /**\n     * A timer to make sure we only fire {respoke.RemoteMedia#requesting-media} if the browser doesn't\n     * automatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.\n     * @memberof! respoke.RemoteMedia\n     * @name allowTimer\n     * @private\n     * @type {number}\n     */\n    var allowTimer = 0;\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name mediaOptions\n     * @private\n     * @type {object}\n     */\n    var mediaOptions = {\n        optional: [\n            { DtlsSrtpKeyAgreement: true },\n            { RtpDataChannels: false }\n        ]\n    };\n    /**\n     * @memberof! respoke.RemoteMedia\n     * @name pc\n     * @private\n     * @type {respoke.PeerConnection}\n     */\n    var pc = params.pc;\n    delete that.pc;\n    /**\n     * The remote `MediaStream`.\n     * @memberof! respoke.RemoteMedia\n     * @name stream\n     * @type {RTCMediaStream}\n     */\n    that.stream = params.stream;\n\n    if (!that.temporary && that.stream) {\n        attachMediaStream(that.element, that.stream);\n        that.element.autoplay = true;\n        setTimeout(that.element.play.bind(that.element)); // stupid Firefox requires this.\n    }\n\n    /**\n     * Indicate whether we are receiving a screenshare.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.hasScreenShare\n     * @return {boolean}\n     */\n    that.hasScreenShare = function () {\n        if (that.stream) {\n            return (that.stream.getVideoTracks().length > 0 && hasScreenShare);\n        }\n        return hasScreenShare;\n    };\n\n    /**\n     * Indicate whether we are receiving video.\n     *\n     * Note: This method will return true when the video is a screenshare.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.hasVideo\n     * @return {boolean}\n     */\n    that.hasVideo = function () {\n        if (that.stream) {\n            return (that.stream.getVideoTracks().length > 0);\n        }\n        return sdpHasVideo;\n    };\n\n    /**\n     * Indicate whether we are receiving audio.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.hasAudio\n     * @return {boolean}\n     */\n    that.hasAudio = function () {\n        if (that.stream) {\n            return (that.stream.getAudioTracks().length > 0);\n        }\n        return sdpHasAudio;\n    };\n\n    /**\n     * Indicate whether we have media yet.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.hasMedia\n     * @return {boolean}\n     */\n    that.hasMedia = function () {\n        return !!that.stream;\n    };\n\n    /**\n     * Save and parse the SDP\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.setSDP\n     * @param {RTCSessionDescription} oSession\n     * @private\n     */\n    that.setSDP = function (oSession) {\n        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n    };\n\n    /**\n     * Parse the constraints.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.setConstraints\n     * @param {MediaConstraints} constraints\n     * @private\n     */\n    that.setConstraints = function (constraints) {\n        that.constraints = constraints;\n        sdpHasVideo = respoke.constraintsHasVideo(that.constraints);\n        sdpHasAudio = respoke.constraintsHasAudio(that.constraints);\n    };\n\n    /**\n     * Expose getAudioTracks.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.getAudioTracks\n     */\n    that.getAudioTracks = function () {\n        if (that.stream) {\n            return that.stream.getAudioTracks();\n        }\n        return [];\n    };\n\n    /**\n     * Expose getVideoTracks.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.getVideoTracks\n     */\n    that.getVideoTracks = function () {\n        if (that.stream) {\n            return that.stream.getVideoTracks();\n        }\n        return [];\n    };\n\n    /**\n     * Stop the stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.stop\n     * @fires respoke.RemoteMedia#stop\n     */\n    that.stop = function () {\n        if (!that.stream) {\n            return;\n        }\n\n        that.stream.numPc -= 1;\n        if (that.stream.numPc === 0) {\n            that.stream.getTracks().forEach(function (track) {\n                track.stop();\n            });\n        }\n        that.stream = null;\n        /**\n         * Indicate that remote media has stopped.\n         * @event respoke.RemoteMedia#stop\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         */\n        that.fire('stop');\n    };\n\n    /**\n     * Whether the video stream is muted.\n     *\n     * All video tracks must be muted for this to return `false`.\n     * @returns boolean\n     */\n    that.isVideoMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getVideoTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };\n\n    /**\n     * Mute remote video stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.muteVideo\n     * @fires respoke.RemoteMedia#mute\n     */\n    that.muteVideo = function () {\n        if (that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });\n        /**\n         * Indicate that the muted status of remote video or audio has changed.\n         * @event respoke.RemoteMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'video',\n            muted: true\n        });\n    };\n\n    /**\n     * Unmute remote video stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.unmuteVideo\n     * @fires respoke.RemoteMedia#mute\n     */\n    that.unmuteVideo = function () {\n        if (!that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });\n        /**\n         * Indicate that the muted status of remote video or audio has changed.\n         * @event respoke.RemoteMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'video',\n            muted: false\n        });\n    };\n\n    /**\n     * Whether the audio stream is muted.\n     *\n     * All audio tracks must be muted for this to return `false`.\n     * @returns boolean\n     */\n    that.isAudioMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getAudioTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };\n\n    /**\n     * Mute remote audio stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.muteAudio\n     * @fires respoke.RemoteMedia#mute\n     */\n    that.muteAudio = function () {\n        if (that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });\n        /**\n         * Indicate that the muted status of remote video or audio has changed.\n         * @event respoke.RemoteMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'audio',\n            muted: true\n        });\n    };\n\n    /**\n     * Unmute remote audio stream.\n     * @memberof! respoke.RemoteMedia\n     * @method respoke.RemoteMedia.unmuteAudio\n     * @fires respoke.RemoteMedia#mute\n     */\n    that.unmuteAudio = function () {\n        if (!that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });\n        /**\n         * Indicate that the muted status of remote video or audio has changed.\n         * @event respoke.RemoteMedia#mute\n         * @property {string} name - the event name.\n         * @property {respoke.RemoteMedia} target\n         * @property {string} type - Either \"audio\" or \"video\" to specify the type of stream whose muted state\n         * has been changed.\n         * @property {boolean} muted - Whether the stream is now muted. Will be set to false if mute was turned off.\n         */\n        that.fire('mute', {\n            type: 'audio',\n            muted: false\n        });\n    };\n\n    return that;\n}; // End respoke.RemoteMedia\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/remoteMedia.js\n ** module id = 23\n ** module chunks = 0\n **/","/*\n * Copyright 2015, Digium, Inc.\n * All rights reserved.\n *\n * This source code is licensed under The MIT License found in the\n * LICENSE file in the root directory of this source tree.\n *\n * For all details and documentation:  https://www.respoke.io\n */\n\nvar Q = require('q');\nvar respoke = require('./respoke');\n\n/**\n * A conference call to one or more people with audio. Eventually this will handle video, too.\n * @class respoke.Conference\n * @constructor\n * @augments respoke.EventEmitter\n * @param {object} params\n * @param {string} params.id - The id that should be used to create the conference call or the ID\n * of the call to join.\n * @param {string} params.instanceId - client id\n * @param {boolean} params.caller - whether or not we initiated the call\n * @param {boolean} [params.receiveOnly] - whether or not we accept media\n * @param {boolean} [params.sendOnly] - whether or not we send media\n * @param {boolean} [params.needDirectConnection] - flag to enable skipping media & opening direct connection.\n * @param {boolean} [params.forceTurn] - If true, media is not allowed to flow peer-to-peer and must flow through\n * relay servers. If it cannot flow through relay servers, the call will fail.\n * @param {boolean} [params.disableTurn] - If true, media is not allowed to flow through relay servers; it is\n * required to flow peer-to-peer. If it cannot, the call will fail.\n * @param {respoke.Endpoint} params.remoteEndpoint - The endpoint who is being called.\n * @param {string} [params.connectionId] - The connection ID of the remoteEndpoint.\n * @param {respoke.Call.previewLocalMedia} [params.previewLocalMedia] - A function to call if the developer\n * wants to perform an action between local media becoming available and calling approve().\n * @param {function} params.signalOffer - Signaling action from SignalingChannel.\n * @param {function} params.signalConnected - Signaling action from SignalingChannel.\n * @param {function} params.signalAnswer - Signaling action from SignalingChannel.\n * @param {function} params.signalHangup - Signaling action from SignalingChannel.\n * @param {function} params.signalReport - Signaling action from SignalingChannel.\n * @param {function} params.signalCandidate - Signaling action from SignalingChannel.\n * @param {Array<RTCConstraints>} params.constraints - Array of WebRTC constraints.\n * @param {respoke.Conference.onJoin} [params.onJoin] - Callback for when a participant joins the conference.\n * @param {respoke.Conference.onLeave} [params.onLeave] - Callback for when a participant leaves the conference.\n * @param {respoke.Conference.onMessage} [params.onMessage] - Callback for when a message is sent to the conference.\n * @param {respoke.Conference.onMute} [params.onMute] - Callback for when local or remote media is muted or unmuted.\n * @param {respoke.Conference.onTopic} [params.onTopic] - Callback for the conference topic changes.\n * @param {respoke.Conference.onPresenter} [params.onPresenter] - Callback for when the presenter changes.\n * @param {respoke.Call.onError} [params.onError] - Callback for errors that happen during call setup or\n * media renegotiation.\n * @param {respoke.Call.onLocalMedia} [params.onLocalMedia] - Callback for receiving an HTML5 Video\n * element with the local audio and/or video attached.\n * @param {respoke.Call.onConnect} [params.onConnect] - Callback for the remote video element.\n * @param {respoke.Call.onHangup} [params.onHangup] - Callback for when the call is ended, whether or not\n * it was ended in a graceful manner.\n * @param {respoke.Call.onMute} [params.onMute] - Callback for changing the mute state on any type of media.\n * This callback will be called when media is muted or unmuted.\n * @param {respoke.Call.onAnswer} [params.onAnswer] - Callback for when the callee answers the call.\n * @param {respoke.Call.onRequestingMedia} [params.onRequestingMedia] - Callback for when the app is waiting\n * for the user to give permission to start getting audio or video.\n * @param {respoke.Call.onApprove} [params.onApprove] - Callback for when the user approves local media. This\n * callback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\n * the approval was automatic.\n * @param {respoke.Call.onAllow} [params.onAllow] - Callback for when the browser gives us access to the\n * user's media.  This event gets called even if the allow process is automatic, i. e., permission and media is\n * granted by the browser without asking the user to approve it.\n * @param {HTMLVideoElement} params.videoLocalElement - Pass in an optional html video element to have local\n * video attached to it.\n * @param {HTMLVideoElement} params.videoRemoteElement - Pass in an optional html video element to have remote\n * video attached to it.\n * @returns {respoke.Conference}\n */\nmodule.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    /**\n     * @memberof! respoke.Client\n     * @name instanceId\n     * @private\n     * @type {string}\n     */\n    var instanceId = params.instanceId;\n    var signalingChannel = params.signalingChannel;\n    var that = respoke.EventEmitter({\n        id: params.id\n    });\n\n    that.listen('join', params.onJoin);\n    that.listen('leave', params.onLeave);\n    that.listen('message', params.onMessage);\n    that.listen('mute', params.onMute);\n    that.listen('topic', params.onTopic);\n    that.listen('presenter', params.onPresenter);\n    delete params.onJoin;\n    delete params.onLeave;\n    delete params.onMessage;\n    delete params.onMute;\n    delete params.onTopic;\n    delete params.onPresenter;\n\n    params.caller = true;\n    params.conferenceId = params.id;\n    delete params.id;\n    params.remoteEndpoint = that;\n    that.call = respoke.Call(params);\n\n    // Redirect a bunch of events.\n    [\n        'mute', 'hangup', 'connect', 'stats', 'error', 'local-stream-received',\n         'remote-stream-received', 'requesting-media', 'approve', 'allow'\n    ].forEach(function (eventName) {\n        that.call.listen(eventName, function (evt) {\n            evt.call = that.call; // target will be updated to point to this conference object.\n            that.fire(eventName, evt);\n        });\n    });\n\n    delete that.instanceId;\n\n    /**\n     * A name to identify this class\n     * @memberof! respoke.Conference\n     * @name className\n     * @type {string}\n     */\n    that.className = 'respoke.Conference';\n\n    /**\n     * @memberof! respoke.Conference\n     * @name client\n     * @type {respoke.Client}\n     * @private\n     */\n    var client = respoke.getClient(instanceId);\n\n    /**\n     * Leave the conference.\n     * @memberof! respoke.Conference\n     * @method respoke.Conference.leave\n     */\n    that.leave = that.call.hangup;\n\n    /**\n     * Mute local user's audio.\n     * @memberof! respoke.Conference\n     * @method respoke.Conference.muteAudio\n     */\n    that.muteAudio = that.call.muteAudio;\n\n    /**\n     * ## The plugin `respoke.MediaStats` must be loaded before using this method.\n     *\n     * Start the process of listening for a continuous stream of statistics about the flow of audio and/or video.\n     * Since we have to wait for both the answer and offer to be available before starting\n     * statistics, the library returns a promise for the stats object. The statistics object does not contain the\n     * statistics; rather it contains methods of interacting with the actions of obtaining statistics. To obtain\n     * the actual statistics one time, use stats.getStats(); use the onStats callback to obtain a continuous\n     * stream of statistics every `interval` seconds.  Returns null if stats module is not loaded.\n     *\n     *     conference.getStats({\n     *         onStats: function (evt) {\n     *             console.log('Stats', evt.stats);\n     *         }\n     *     }).done(function () {\n     *         console.log('Stats started');\n     *     }, function (err) {\n     *         console.log('Call is already hung up.');\n     *     });\n     *\n     * @memberof! respoke.Conference\n     * @method respoke.Conference.getStats\n     * @param {object} params\n     * @param {number} [params.interval=5000] - How often in milliseconds to fetch statistics.\n     * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - An optional callback to receive\n     * the stats. If no callback is provided, the call's report will contain stats but the developer will not\n     * receive them on the client-side.\n     * @param {respoke.Call.statsSuccessHandler} [params.onSuccess] - Success handler for this invocation of\n     * this method only.\n     * @param {respoke.Call.errorHandler} [params.onError] - Error handler for this invocation of this method only.\n     * @returns {Promise<object>|null}\n     */\n    if (respoke.MediaStats) {\n        that.getStats = that.call.getStats;\n    }\n\n    /**\n     * Get an array containing a Connection object for each participant in the conference.\n     * @memberof! respoke.Conference\n     * @method respoke.Conference.getParticipants\n     * @returns {Promise<Array>}\n     */\n    that.getParticipants = function () {\n        return signalingChannel.getConferenceParticipants({\n            id: that.id\n        });\n    };\n\n    /**\n     * If the logged-in endpoint has permission through its Respoke role, forcibly remove another participant\n     * from the conference, ending its conference call.\n     * @memberof! respoke.Conference\n     * @method respoke.Conference.removeParticipant\n     * @param {object} params\n     * @param {string} [endpointId] - The endpoint id of the endpoint to be removed\n     * @param {string} [connectionId] - The connection id of the connection to be removed\n     * @returns {Promise}\n     */\n    that.removeParticipant = function (params) {\n        params = params || {};\n        params.conferenceId = that.id;\n        return signalingChannel.removeConferenceParticipant(params);\n    };\n\n    /**\n     * If the logged-in endpoint has permission through its Respoke role, shut down the conference, removing all\n     * participants.\n     * @memberof! respoke.Conference\n     * @method respoke.Conference.destroy\n     * @returns {Promise}\n     */\n    that.destroy = function (params) {\n        return signalingChannel.destroyConference({\n            conferenceId: that.id\n        });\n    };\n\n    return that;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./respoke/conference.js\n ** module id = 24\n ** module chunks = 0\n **/"],"sourceRoot":""}